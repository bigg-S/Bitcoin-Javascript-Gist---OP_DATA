{"version":3,"file":"bundle.js","mappings":"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B;AAClB,mBAAmB;AACnB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,eAAe,mBAAO,CAAC,oDAAW;AAClC,gBAAgB,mBAAO,CAAC,gDAAS;AACjC;AACA;AACA;AACA;;AAEA,cAAc;AACd,kBAAkB;AAClB,yBAAyB;;AAEzB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,yBAAyB,QAAQ;AACjC;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qBAAqB,WAAW,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,gBAAgB,WAAW,GAAG,IAAI,KAAK,aAAa;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;;AAEA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,KAAK,mDAAmD,cAAc;AACzF,GAAG;AACH;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;AACtD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB,cAAc,oBAAoB,EAAE,IAAI;AACxC;AACA,YAAY,gBAAgB,EAAE,IAAI;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,SAAS,GAAG,KAAK,qBAAqB,EAAE,EAAE;AACpE,QAAQ;AACR,yBAAyB,GAAG,KAAK,yBAAyB,EAAE,EAAE;AAC9D,mBAAmB,yBAAyB,EAAE,EAAE;AAChD;AACA,MAAM;AACN,oBAAoB,IAAI,EAAE,GAAG,SAAS,IAAI,EAAE,EAAE;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc,SAAS,OAAO;AACxE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;ACzjEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,SAAS,WAAW;;AAEpB;AACA;AACA,SAAS,UAAU;;AAEnB;AACA;;;;;;;;;;;;;;;;;;;;ACpFA;AAC0C;AACqB;AACP;AACxD;AACO;AACP;AACA;AACA,gCAAgC,wDAAI,YAAY,gEAAW;AAC3D,mBAAmB;AACnB;AACA;AACO;AACP,6BAA6B,qEAAW,GAAG,+BAA+B;AAC1E,2BAA2B,4BAA4B;AACvD;AACA;;;;;;;;;;;;;;;;;;AChBA;AACA;AACsD;AACV;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,yCAAyC;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,IAAI,0DAAa;AACjB,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,oDAAO;AAClB;AACA,aAAa,mBAAmB;AAChC,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;AC3JmC;AAC6D;AAChG;AACA,QAAQ,kDAAO;AACf;AACA;AACA,eAAe,sDAAW;AAC1B;AACA;AACA;AACA,cAAc,sDAAe;AAC7B;AACA;AACA;AACA,iDAAiD,OAAO,SAAS,OAAO;AACxE;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS,kDAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAW,CAAC,sDAAW;AACvC,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA,4CAA4C;AAC5C;AACA,kBAAkB,sDAAW;AAC7B,aAAa,sDAAW;AACxB,oBAAoB,UAAU;AAC9B;AACA,iBAAiB,sDAAW;AAC5B;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,SAAS,sDAAW;AACpD;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAA6E;AACjG;AACA;AACO;AACP,IAAI,yDAAc;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mBAAmB,gDAAG;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iDAAiD;AACjD,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,wCAAwC;AACtF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5KA;AACA;AACuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qEAAqE,QAAQ,MAAM,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,kBAAkB,2CAA2C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;AACA,gCAAgC;AAChC;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA,iCAAiC;AACjC;AACA;AACA,4DAA4D;AAC5D,4BAA4B;AAC5B,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD;AACA,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,kDAAkD;AAClD,sDAAsD;AACtD,sDAAsD;AACtD,0CAA0C;AAC1C,0CAA0C;AAC1C,sDAAsD;AACtD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,yDAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACO;AACP,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sDAAsD;AAC7D;AACA,yDAAyD,MAAM;AAC/D,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAe,eAAe,0DAAe;AAC/E;AACA;AACA,0DAA0D,MAAM,QAAQ,aAAa;AACrF,0BAA0B,0DAAe,UAAU,0DAAe;AAClE,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAW;AACtB;AACA;AACA;AACA,yDAAyD,OAAO,4BAA4B,QAAQ;AACpG,uBAAuB,0DAAe,SAAS,0DAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,4BAA4B,IAAI;AAC3E,uBAAuB,0DAAe,QAAQ,0DAAe;AAC7D;AACA;AACA,kBAAkB,0DAAe,sBAAsB,0DAAe;AACtE;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,IAAI;AACpC;AACO;AACP;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,iCAAiC,IAAI,YAAY,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO,WAAW,gBAAgB,aAAa,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACO;AACP;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AACnD,8DAA8D;AACrE;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB,GAAG,KAAK,GAAG,WAAW,cAAc,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,WAAW,YAAY,IAAI;AACpD,kCAAkC,oBAAoB,IAAI,aAAa,GAAG;AAC1E;AACA,kCAAkC,UAAU,IAAI,SAAS;AACzD,kCAAkC,oBAAoB,IAAI,SAAS;AACnE,kCAAkC,2BAA2B;AAC7D,kCAAkC,wBAAwB;AAC1D;;;;;;;;;;;;;;;;;;;;;;AChSA;AACA;AACoC;AACH;AACQ;AACQ;AACjD;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,QAAQ,wCAAwC,EAAE,sCAAE;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAA0C;AAC3D,KAAK;AACL;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,aAAa,8CAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,sBAAsB;AACtC;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,KAAK,SAAS;AAC1B;AACA;AACA;AACA,mBAAmB,kDAAc;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,8BAA8B;AAC9B,kCAAkC;AAClC,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAoE;AACpF;AACA,gBAAgB,8CAAU;AAC1B,sBAAsB,iDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAkB,CAAC,sDAAW;AACpD;AACA;AACA,mDAAmD,aAAa,4BAA4B,WAAW;AACvG;AACA;AACA,kBAAkB,4CAAO,UAAU;AACnC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,oCAAoC;AACpC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C,0DAA0D;AAC1D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,uBAAuB;AAC/C,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAa;AAC9B,IAAI,qDAAiB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,qBAAqB;AAChD;AACO;AACP;AACA,YAAY,qBAAqB;AACjC,wCAAwC;AACxC,8CAA8C;AAC9C;AACA,4CAA4C;AAC5C;AACA;AACA,eAAe,4CAAO;AACtB;AACA;AACA,eAAe,+CAAU;AACzB;AACA,YAAY,2FAA2F;AACvG;AACA;AACA;AACA;AACA,wBAAwB,kDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAkB;AAC5C;AACA;AACA,mDAAmD;AACnD,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,mDAAmD,KAAK,wBAAwB,eAAe,sBAAsB,iBAAiB;AACtI;AACA,SAAS;AACT,KAAK;AACL,mCAAmC,iDAAa,CAAC,sDAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sDAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO,YAAY,sDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C,oCAAoC,sDAAW,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,sCAAsC;AACtC,qCAAqC;AACrC,kEAAkE;AAClE;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA,mBAAmB,iDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAoB;AAC/C,mBAAmB,uDAAkB;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,wBAAwB,sDAAkB,SAAS;AACnD,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,uBAAuB,8CAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA,eAAe,sDAAkB;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,cAAc,mCAAmC,QAAQ;AACzD;AACA,yBAAyB;AACzB,kBAAkB,sDAAW;AAC7B;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,kEAAkE;AAClE,0BAA0B,sDAAW,sBAAsB;AAC3D;AACA,qBAAqB,kDAAc,eAAe;AAClD,yBAAyB;AACzB;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wBAAwB;AACxB,gCAAgC;AAChC,yDAAyD;AACzD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,oEAAoE;AACpE;AACA;AACA,uCAAuC;AACvC,+BAA+B;AAC/B;AACA,sDAAsD;AACtD;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,mCAAmC;AACjE;AACA,qBAAqB,qDAAiB;AACtC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B,oBAAoB,sDAAW;AAC/B;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,0CAA0C,8CAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,0CAA0C;AAC1C,4BAA4B;AAC5B,iCAAiC;AACjC,iCAAiC;AACjC,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA,kBAAkB;AAClB,2DAA2D;AAC3D;AACA;AACA;AACA,uCAAuC;AACvC,iCAAiC;AACjC,iCAAiC;AACjC,6BAA6B;AAC7B,8BAA8B;AAC9B,4CAA4C;AAC5C;AACA,sBAAsB;AACtB,iCAAiC;AACjC,+BAA+B;AAC/B,8BAA8B;AAC9B,kCAAkC;AAClC,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,8BAA8B;AAC9B,oCAAoC;AACpC,+BAA+B;AAC/B,wCAAwC;AACxC,+BAA+B;AAC/B,gCAAgC;AAChC,uCAAuC;AACvC,uCAAuC;AACvC;AACA,yBAAyB,SAAS;AAClC,+BAA+B;AAC/B,sCAAsC;AACtC,yCAAyC;AACzC,6CAA6C;AAC7C,oCAAoC;AACpC,oCAAoC;AACpC,qCAAqC;AACrC,yCAAyC;AACzC,0CAA0C;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C;AAC3C,uCAAuC;AACvC;AACA,iCAAiC;AACjC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,kCAAkC;AAClC,uCAAuC;AACvC,+CAA+C,kBAAkB;AACjE,yCAAyC;AACzC,2CAA2C;AAC3C,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,sDAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mCAAmC;AACnC,2BAA2B;AAC3B,gCAAgC;AAChC,mCAAmC;AACnC,mCAAmC;AACnC,mEAAmE;AACnE,mCAAmC;AACnC,2BAA2B;AAC3B,2BAA2B;AAC3B,mCAAmC;AACnC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,mCAAmC;AACnC,gCAAgC;AAChC,8BAA8B;AAC9B,gBAAgB,iBAAiB,uBAAuB;AACxD,4BAA4B;AAC5B,8BAA8B;AAC9B,sCAAsC;AACtC,wCAAwC;AACxC,gDAAgD;AAChD,uCAAuC;AACvC,4BAA4B;AAC5B,iBAAiB;AACjB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/hCA;AAC8C;AACI;AACO;AACO;AACiC;AAC1B;AACtB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,iBAAiB,0DAAI;AACrB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,kBAAkB,0DAAI;AACtB,gBAAgB,0DAAI;AACpB,gBAAgB,0DAAI;AACpB,iBAAiB,0DAAI;AACrB;AACA;AACA;AACA;AACA,WAAW,2DAAK,qCAAqC,eAAe;AAC7D,kBAAkB,6DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,qBAAqB,yDAAG;AACxB,qBAAqB,yDAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL,CAAC,EAAE,wDAAM;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAM;AAC3B,eAAe,+DAAW;AAC1B;AACA;AACA,WAAW,4DAAM,CAAC,+DAAW;AAC7B;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC,oBAAoB,yDAAG;AACvB,oBAAoB,yDAAG;AACvB;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,sCAAsC,aAAa;AACnD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,wCAAwC;AACxC,wBAAwB;AACxB;AACA,sBAAsB;AACtB,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,oDAAoD,gEAAW;AAC/D,cAAc,+DAAW;AACzB,YAAY,uBAAuB,mCAAmC;AACtE,cAAc,+DAAW,0BAA0B;AACnD,2BAA2B,mEAAe,iCAAiC;AAC3E,wDAAwD;AACxD,oBAAoB,mEAAe,SAAS;AAC5C;AACA,mDAAmD;AACnD,YAAY,uBAAuB,2BAA2B;AAC9D,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAW;AAC3B,cAAc,+DAAW;AACzB,gBAAgB,+DAAW;AAC3B;AACA,yBAAyB,mEAAe,QAAQ,wBAAwB;AACxE,kBAAkB,mEAAe,uBAAuB,2BAA2B;AACnF;AACA;AACA,kBAAkB,mEAAe,wBAAwB,4BAA4B;AACrF;AACA;AACA,8DAA8D;AAC9D,2CAA2C;AAC3C;AACA,0BAA0B;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,WAAW;AACX,KAAK;AACL,CAAC;AACD,sCAAsC,sEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA;AACA,CAAC;AACD,mCAAmC,wEAAY;AAC/C,YAAY,OAAO;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAM;AAChB,CAAC;AACM;AACA;AACP;;;;;;;;;;;;;;;;;;;;;AC7PA;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,kBAAkB,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,IAAI;AACrF;AACA;AACqD;AACrD,iBAAiB;AACjB,iEAAe,MAAM,EAAC;AACtB;;;;;;;;;;;;;;;;;ACzC8C;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,2CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAU;AAC9B;AACA;AACA,QAAQ,kDAAM;AACd,gBAAgB,yBAAyB;AACzC,eAAe,kDAAO;AACtB;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA,iCAAiC,qDAAU;AAC3C,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAM;AACd,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiL;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC;AACnB;;;;;;;;;;;;;;;AC7DO;AACP;;;;;;;;;;;;;;;;;;ACDgG;AACrD;AAC3C;AACO,mBAAmB,2CAAI;AAC9B;AACA;AACA;AACA;AACA,QAAQ,gDAAU;AAClB,oBAAoB,kDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,kDAAY;AACpB,QAAQ,iDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;AC5E0E;AACzC;AACsC;AACvE;AACA;AACA,IAAI,gDAAU;AACd,iBAAiB,oDAAS,GAAG,0BAA0B;AACvD,YAAY,sBAAsB;AAClC,IAAI,kDAAY;AAChB,IAAI,kDAAY;AAChB,IAAI,kDAAY;AAChB;AACA;AACA,qBAAqB,kDAAO;AAC5B,iBAAiB,kDAAO;AACxB;AACA;AACA;AACA,gBAAgB,0CAAI;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACO;AACP,YAAY,6BAA6B;AACzC,cAAc;AACd;AACA,iBAAiB,qDAAU;AAC3B;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,wCAAwC;AACpD,cAAc;AACd;AACA,iBAAiB,qDAAU;AAC3B;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAS;AACvB;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrFkC;AACW;AAC7C;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,0CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA,oDAAoD;AACpD,sDAAsD;AACtD,4DAA4D;AAC5D,4BAA4B,QAAQ;AACpC;AACA,2EAA2E;AAC3E;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,0DAAe;AACxD;;;;;;;;;;;;;;;;;;ACvGkC;AACiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C,uBAAuB,+CAAI,WAAW,+CAAI;AAC1C;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D;AACA,2BAA2B,+CAAI,SAAS,+CAAI,UAAU,+CAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;AC7HkC;AACN;AACiB;AAC7C;AACA;AACA,sDAAsD,qDAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF,wBAAwB,sDAAU,kBAAkB,sDAAU,kBAAkB,qDAAS;AACzF;AACA;AACA;AACA,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF,wBAAwB,sDAAU,iBAAiB,sDAAU,iBAAiB,qDAAS;AACvF;AACA,yBAAyB,qDAAS;AAClC,yBAAyB,qDAAS;AAClC;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAS;AAClC,wBAAwB,qDAAS;AACjC;AACA;AACA,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF,4BAA4B,sDAAU,eAAe,sDAAU,eAAe,sDAAU;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,EAAE,mDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAS;AACjC,iBAAiB,qDAAS;AAC1B;AACA;AACA;AACA,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC,WAAW,eAAe,EAAE,mDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,0DAAe;AAC9C,mCAAmC,0DAAe;AAClD,mCAAmC,0DAAe;AAClD,+BAA+B,0DAAe;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4DAA4D,WAAW;AACvE,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AACT;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,wDAAM,WAAW,wDAAM;AAC/B,eAAe,wDAAM;AACrB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,GAAG,aAAa,gBAAgB;AACrG;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA,wDAAwD,OAAO,cAAc,SAAS;AACtF;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,EAAE;AACvE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,EAAE;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wEAAwE,EAAE;AAC1E;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA,kDAAkD,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,EAAE;AAChD,KAAK;AACL;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA,mDAAmD,GAAG;AACtD;AACA,8DAA8D,MAAM,KAAK,IAAI,YAAY,sBAAsB;AAC/G;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gEAAgE,GAAG,OAAO,KAAK;AAC/E;AACA;AACA,iEAAiE,KAAK,OAAO,KAAK;AAClF;AACA,eAAe,WAAW;AAC1B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,cAAc;AACxF;AACA,mFAAmF,aAAa;AAChG;AACA;AACA,0CAA0C,cAAc,gBAAgB,MAAM;AAC9E;AACA;AACA,kBAAkB,QAAQ,GAAG,4BAA4B,EAAE,IAAI;AAC/D;AACA;AACA;AACA,yEAAyE,WAAW;AACpF;AACA,wDAAwD,YAAY,GAAG,IAAI,kBAAkB,MAAM;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI,cAAc,IAAI;AACzE,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,iBAAiB;AACjB;AACA,aAAa;AACb;AACO;AACA;AACA;AACP;AACA;AACA;AACO;AACP;AACA,gEAAgE,UAAU,cAAc,SAAS;AACjG;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;;ACrdP;AAC0C;AACU;AACN;AACA;AACe;AACsC;AACvC;AACP;AACL;AAChD,cAAc,8DAAI;AAClB,oBAAoB,8DAAiB,CAAC,wDAAM;AAC5C;AACA,uBAAuB,+DAAU,QAAQ;AACzC;AACA;AACA,WAAW,+DAAU;AACrB;AACA,sBAAsB,gEAAW;AACjC;AACA,2BAA2B;AACpB;AACP,0BAA0B,kEAAS,CAAC,4DAAM;AAC1C,0BAA0B,+DAAU;AACpC;AACA;AACA,0CAA0C,EAAE;AAC5C;AACA;AACA,IAAI,+DAAU;AACd;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAW;AACnB;AACA,wDAAwD,YAAY,sCAAsC;AAC1G;AACA,kBAAkB,wDAAI,CAAC,wDAAM;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,+DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAI;AACrB;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAI;AAC9B;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAW;AAC9B;AACA;AACA;AACA,mBAAmB,gEAAW;AAC9B;AACA,kBAAkB,wDAAI,CAAC,wDAAM;AAC7B;AACA;AACA,aAAa,8DAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAG,4BAA4B,8DAAI;AACjE,qBAAqB,8DAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAW;AACnB,eAAe,8DAAI;AACnB;AACA;AACA,QAAQ,2DAAW;AACnB,QAAQ,2DAAW;AACnB;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAI;AACtB;AACA;AACA;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAW;AACnB;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5QA;AACqF;AAC1B;AACb;AACA;AACI;AACD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,IAAI,2DAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,4DAAY;AAChB;AACA;AACA,6BAA6B,gEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,EAAE;AAC/D,KAAK;AACL,WAAW,8CAAS,OAAO,8CAAS,4BAA4B,8CAAS,mBAAmB,8CAAS;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,iEAAW,CAAC,wDAAM,gDAAgD,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,4DAAM,CAAC,wDAAM,gDAAgD,oBAAoB;AAC5F;;;;;;;;;;;;;;;;ACrIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC//DA;AACsE;AACxB;AACM;AACkB;AACpC;AAClC,QAAQ,wEAAwE,EAAE,8DAAK;AACvF,oBAAoB,8DAAK;AACzB;AACA;AACA,gBAAgB,iDAAS;AACzB,yBAAyB,kEAAS,CAAC,4DAAM;AACzC,8BAA8B,4DAAM,CAAC,4DAAM;AAC3C,eAAe,qDAAa;AAC5B;AACO,oBAAoB,8DAAiB,CAAC,wDAAM;AAC5C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,GAAG,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAO,cAAc,4DAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD,6BAA6B,+CAAO;AACpC,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAO;AACrB,gDAAgD;AAChD,iDAAiD;AACjD;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACO;AACP,cAAc,4DAAO;AACrB,mCAAmC;AACnC,mDAAmD;AACnD,kDAAkD;AAClD,yCAAyC;AACzC,wCAAwC;AACxC;AACA;AACA,oBAAoB,kDAAU,CAAC,+CAAO;AACtC,sBAAsB,kDAAU,CAAC,+CAAO;AACxC,yBAAyB,kDAAU,CAAC,+CAAO;AAC3C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,4CAAG;AACvB;AACA,0DAA0D,YAAY,4CAAG,SAAS;AAClF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACO,gBAAgB,gDAAQ;AAC/B;AACO;AACP;AACA,6CAA6C,UAAU,IAAI,SAAS;AACpE;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,8CAAM;AAC5B;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,GAAG,GAAG,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAO;AAC/B;AACA;AACA;AACA,wBAAwB,+CAAO;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAI;AAC9B;AACA,0BAA0B,+CAAO;AACjC;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACO;AACP,WAAW,8CAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,IAAI,sBAAsB,WAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,8CAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,6CAA6C,UAAU;AACvD;AACA,KAAK;AACL,CAAC;AACD;AACA,uBAAuB,+CAAO,cAAc,gDAAQ;AACpD;AACO,wBAAwB,+CAAO;AACtC;AACO,iBAAiB,+CAAO;AACxB,iBAAiB,gDAAQ;AAChC,UAAU,+CAAO;AACjB,WAAW,+CAAO;AAClB;AACA,cAAc,+CAAO;AACrB,CAAC;AACM,kBAAkB,gDAAQ,GAAG,QAAQ,+CAAO,oBAAoB;AACvE;AACA;AACA,YAAY,+CAAO;AACnB;AACA;AACO,mBAAmB,+CAAO;AACjC;AACA,eAAe,gDAAQ;AACvB,aAAa,+CAAO;AACpB,gBAAgB,8CAAM;AACtB;AACA;AACA,eAAe,iDAAS,eAAe,+CAAO;AAC9C;AACA;AACA;AACA,cAAc,+CAAO;AACrB,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,cAAc,kDAAU;AAC/B;AACA;AACA,aAAa;AACb;AACA,iBAAiB,gDAAQ;AACzB,iBAAiB,+CAAO;AACxB,UAAU,+CAAO,OAAO,+CAAO;AAC/B,CAAC;AACD;AACA;AACA,6BAA6B,gDAAQ;AACrC,aAAa,4CAAI;AACjB,iBAAiB,+CAAO;AACxB,gBAAgB,+CAAO,OAAO,+CAAO;AACrC,CAAC;AACM,4BAA4B,kDAAU;AAC7C;AACA;AACA;AACA,CAAC;AACD,wBAAwB,gDAAQ;AAChC,YAAY,+CAAO,iBAAiB,+CAAO;AAC3C;AACA,CAAC;AACD;AACA,mBAAmB,+CAAO;AAC1B,wBAAwB,gDAAQ,GAAG,iCAAiC,+CAAO,MAAM;AACjF,IAAI,0FAA0F;AAC9F,gBAAgB,+CAAO,OAAO,gDAAQ;AACtC,WAAW,4CAAI;AACf,aAAa,4CAAI;AACjB;AACA,CAAC;AACD,iBAAiB,+CAAO,QAAQ;AAChC,gBAAgB,+CAAO;AACvB,gBAAgB,+CAAO;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAO;AACpC,oCAAoC,+CAAO;AAC3C;AACA;AACA,gCAAgC,4CAAI;AACpC,2BAA2B,+CAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAO;AAChC,4BAA4B,+CAAO;AACnC,wCAAwC,+CAAO;AAC/C,0CAA0C,+CAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAO,CAAC,8CAAM,EAAE,gDAAQ;AAC5C;AACA,SAAS,gDAAQ,iBAAiB,gDAAQ,GAAG,2BAA2B,+CAAO,QAAQ;AACvF;AACA,WAAW,+CAAO;AAClB,CAAC;AACD,uBAAuB,gDAAQ,GAAG,2BAA2B,+CAAO,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,WAAW,+CAAO,EAAE,yBAAyB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO,WAAW,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,OAAO,4CAAG,cAAc,QAAQ,4CAAG,eAAe;AAC3H;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,OAAO,KAAK,QAAQ,MAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gFAAgF,MAAM,MAAM,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS,oDAAY,SAAS,4DAAM;AACpC;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA,iBAAiB,oDAAY;AAC7B;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uBAAuB;AACpF;AACA;AACA;AACA,8DAA8D,yBAAyB;AACvF;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA,cAAc,oDAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,4CAAG;AACxB;AACA;AACA,+DAA+D,MAAM,MAAM,MAAM;AACjF;AACA;AACA,CAAC;AACD,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA,CAAC;AACD,wBAAwB,kDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,mBAAmB,gDAAQ;AAClC,WAAW,+CAAO,CAAC,gDAAQ;AAC3B;AACA,YAAY,+CAAO;AACnB,aAAa,+CAAO;AACpB,CAAC;AACM,mBAAmB,gDAAQ;AAClC,WAAW,+CAAO,CAAC,gDAAQ;AAC3B;AACA,YAAY,+CAAO;AACnB,aAAa,+CAAO;AACpB,CAAC;AACM,mBAAmB,gDAAQ;AAClC,WAAW,+CAAO,CAAC,gDAAQ;AAC3B,WAAW,+CAAO,OAAO,+CAAO,CAAC,+CAAO,CAAC,8CAAM,EAAE,+CAAO,EAAE,6CAAK,kBAAkB,+CAAO,kBAAkB,gDAAQ;AAClH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,oCAAoC,QAAQ,UAAU,GAAG;AACzD;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,oCAAoC,QAAQ,2BAA2B,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,+DAA+D,QAAQ,IAAI,GAAG,gCAAgC,SAAS;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,EAAE;AAChD;AACA;AACA;AACA,kDAAkD,EAAE;AACpD;AACA,+DAA+D,4CAAG;AAClE,+DAA+D,4CAAG;AAClE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAAG;AACtC,mCAAmC,4CAAG;AACtC;AACA,kDAAkD,IAAI,cAAc,MAAM,SAAS,QAAQ,SAAS,OAAO;AAC3G;AACA;AACA,iCAAiC,4CAAG;AACpC;AACA;AACA;AACA,iCAAiC,4CAAG;AACpC;AACA;AACA;AACA,0EAA0E,IAAI,GAAG,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAAG;AAClC;AACA;AACA,iBAAiB,oDAAY;AAC7B,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,kDAAU;AAC5B,kBAAkB,kDAAU;AACnC;AACA,kBAAkB,gDAAQ,GAAG,MAAM,+CAAO,mBAAmB,+CAAO,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACO;AACP;AACA;AACA,yCAAyC,UAAU;AACnD,iBAAiB,4DAAM;AACvB,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,uCAAuC,wBAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,gBAAgB,oDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA,0DAA0D,oDAAY,qBAAqB,+CAAO;AAClG;AACA,wDAAwD,4CAAG;AAC3D;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC,4DAAO;AACvD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,4DAAM;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,UAAU,4CAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,+CAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE,2CAA2C,mCAAmC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB,+BAA+B,kBAAkB;AAC7E;AACA;AACA,6BAA6B,WAAW;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAO,SAAS,gDAAQ;AAC3C;AACO,kBAAkB,kDAAU;AACnC;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,+CAAM,GAAG,gDAAO;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC;AACA,iEAAiE,aAAa;AAC9E;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA,2DAA2D,WAAW;AACtE;AACA,6BAA6B,+CAAM;AACnC;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACA,4DAA4D,4DAAO;AAC1E,mEAAmE,+CAAO;AAC1E,QAAQ,oDAAY;AACpB;AACA,iBAAiB,4DAAO;AACxB;AACA,aAAa;AACb;AACA,gBAAgB;AAChB;AACA;AACA,sEAAsE,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA,IAAI,+CAAO,yBAAyB;AACpC;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,8DAA8D,EAAE,GAAG,GAAG,GAAG,SAAS;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uBAAuB;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAG;AAClB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,qCAAqC,6DAA6D;AAClG;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA,qCAAqC,yCAAyC;AAC9E;AACA;AACA;AACA,4BAA4B,+CAAO;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,wCAAwC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,+CAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,+CAAO;AAC9E,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAG;AAClB;AACA;AACA;AACA;AACA,eAAe,4CAAG;AAClB;AACA;AACA;AACA;AACA,eAAe,4CAAG;AAClB;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAG;AACxB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAoE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA,iDAAiD,IAAI;AACrD;AACA,mBAAmB,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,+DAA+D,+CAAO;AACtE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+BAA+B,+CAAO;AACtC;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+CAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAO,gDAAgD,+CAAO,+BAA+B,+CAAO,sDAAsD,+CAAO,iBAAiB,+CAAO,qCAAqC,+CAAO,wBAAwB,+CAAO;AAC5R;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA,2DAA2D,cAAc;AACzE;AACA,YAAY,4CAAI;AAChB,YAAY,4CAAI;AAChB,YAAY,+CAAO;AACnB,YAAY,+CAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAO;AAClC;AACA,kCAAkC,+CAAO;AACzC,yBAAyB,4DAAM;AAC/B;AACA;AACA,qBAAqB,4DAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAO,2DAA2D,+CAAO;AACrH;AACA;AACA,qBAAqB,+CAAO;AAC5B;AACA,qBAAqB,4DAAM,0BAA0B,+CAAO;AAC5D;AACA,4CAA4C,4DAAM;AAClD;AACA,uDAAuD,4CAAI,YAAY,+CAAO;AAC9E,eAAe,4DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA,qBAAqB,oDAAY;AACjC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8EAA8E,uBAAuB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ,aAAa,0BAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA,0GAA0G,IAAI;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4DAAO;AACpC,oDAAoD,+CAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,oBAAoB,oDAAY;AAChC;AACA,uCAAuC,4DAAO,gGAAgG,+CAAO;AACrJ,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,oDAAY;AACzF;AACA;AACA;AACA;AACA,uCAAuC,4DAAO,kGAAkG,+CAAO;AACvJ,4CAA4C,kBAAkB,oCAAoC,SAAS;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAY,eAAe,oDAAY;AAC1E;AACA;AACA;AACA,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAwC;AACxF;AACA;AACA;AACA,sEAAsE,iBAAiB;AACvF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,oDAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oDAAY;AAClF;AACA;AACA,gDAAgD,+CAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oDAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C,qFAAqF,oDAAY;AACjG;AACA;AACA,qCAAqC;AACrC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oDAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,GAAG,IAAI,gBAAgB,aAAa,kBAAkB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAO;AACtC;AACA;AACA,wDAAwD,EAAE;AAC1D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,4DAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,GAAG,OAAO,cAAc,QAAQ,cAAc;AAChH;AACA;AACA;AACA;AACA,kEAAkE,GAAG,cAAc,gBAAgB,QAAQ,gBAAgB;AAC3H;AACA;AACA,6FAA6F,+CAAO;AACpG,gGAAgG,+CAAO;AACvG,aAAa,oDAAY;AACzB;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,4DAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,iBAAiB,+CAAO;AACxB;AACA;AACA;AACA,qCAAqC,oDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,oCAAoC,OAAO;AAC3C,wCAAwC,+CAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAO;AACtC;AACA;AACA,wDAAwD,EAAE;AAC1D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,wDAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,4FAA4F;AAC5F,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,gCAAgC;AAChC,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E,2BAA2B,kDAAkD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,+BAA+B,0DAA0D;AACzF;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA,oBAAoB;AACpB;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACl8FgC;AACI;AACF;AACa;;AAE/C;AACA,QAAQ,gDAAW;AACnB,OAAO,+CAAU;AACjB;;AAEA,iDAAK;AACL;AACA;AACA,yCAAyC,MAAM;AAC/C,MAAM;AACN;AACA;AACA,8CAA8C,MAAM;AACpD;AACA,CAAC;;AAED,sCAAsC,OAAO;;AAE7C,sCAAsC,iDAAK;;AAE3C,iEAAe;AACf;AACA,eAAe,iDAAK;;AAEpB,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,2DAAU,qBAAqB,GAAG;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,2DAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EY;;AAEqB;AACO;AACK;AACE;AACK;AACS;AACC;AAChB;AACQ;AACC;AACZ;AACO;AACC;;AAEpD;AACA;AACA,uBAAuB,mEAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,iEAAe;AACf;AACA;AACA,2BAA2B,6DAAY;AACvC,SAAS,6BAA6B;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,iDAAK;AACb,UAAU,0DAAQ,0BAA0B,0DAAQ;AACpD,8CAA8C;AAC9C,QAAQ;AACR;AACA,oEAAoE;AACpE,yFAAyF;AACzF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kEAAa;;AAElC,8CAA8C,gEAAQ;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,2DAAM;AACZ;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2DAAU,oBAAoB,2DAAU;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,2DAAU,kBAAkB,2DAAU;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,iEAAoB;AACtE;AACA;AACA;AACA,iBAAiB,2DAAU;AAC3B;AACA,2CAA2C,2DAAU,aAAa,2DAAU;AAC5E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,0DAAQ;AACf,uBAAuB,iDAAK;;AAE5B,uDAAuD,uEAAe;AACtE;AACA,4EAA4E,4DAAO;;AAEnF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,iDAAK;AACX;AACA,OAAO;AACP;;AAEA;AACA,SAAS,iDAAK;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAa;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sEAAa;;AAElC,oBAAoB,0DAAQ;AAC5B,iBAAiB,2DAAU,2CAA2C,2DAAU;AAChF;AACA;;;AAGA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnQY;;AAEkB;AACM;AACD;AACY;AACL;AACc;AACH;AACJ;AACN;AACN;AACW;AACH;AACL;AACY;AACH;AACJ;AACW;;AAEzD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA,sBAAsB,sDAAK;AAC3B,mBAAmB,4DAAI,CAAC,sDAAK;;AAE7B;AACA,EAAE,iDAAK,kBAAkB,sDAAK,sBAAsB,iBAAiB;;AAErE;AACA,EAAE,iDAAK,kCAAkC,iBAAiB;;AAE1D;AACA;AACA,0BAA0B,gEAAW;AACrC;;AAEA;AACA;;AAEA;AACA,6BAA6B,0DAAQ;;AAErC;AACA,cAAc,sDAAK;;AAEnB;AACA,sBAAsB,gEAAa;AACnC,oBAAoB,8DAAW;AAC/B,iBAAiB,2DAAQ;AACzB,gBAAgB,iDAAO;AACvB,mBAAmB,8DAAU;;AAE7B;AACA,mBAAmB,4DAAU;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,2DAAM;;AAErB;AACA,qBAAqB,iEAAY;;AAEjC;AACA,oBAAoB,4DAAW;;AAE/B,qBAAqB,8DAAY;;AAEjC,4BAA4B,uEAAc,CAAC,iDAAK;;AAEhD,mBAAmB,8DAAQ;;AAE3B,uBAAuB,mEAAc;;AAErC;;AAEA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;;ACxFP;;AAEkC;;AAE/C;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,yDAAa;AACtC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;;ACxHd;;AAEkC;AACf;;AAEhC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,EAAE,2DAAU,oDAAoD,2DAAU;AAC1E;AACA;;AAEA,iDAAK,yBAAyB,2DAAU;AACxC;AACA,CAAC;;AAED,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;ACxBhB;;AAEE;AACf;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACJa;;AAEqB;AACY;AACW;AACN;AACR;AACI;AACC;AACH;;AAE7C,mBAAmB,6DAAS;;AAE5B;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAkB;AACrC,oBAAoB,8DAAkB;AACtC;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,aAAa,2DAAW;;AAExB,WAAW,yCAAyC;;AAEpD;AACA,MAAM,6DAAS;AACf;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,UAAU,iDAAK;AACf;AACA;AACA;AACA,QAAQ;AACR,QAAQ,6DAAS;AACjB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,iDAAK;AACzC;AACA;AACA;;AAEA,eAAe,iDAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wDAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,qBAAqB,2DAAe;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,2DAAe;AAC/B,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,2DAAW;AACxB,qBAAqB,6DAAa;AAClC,WAAW,gEAAQ;AACnB;AACA;;AAEA;AACA,iDAAK;AACL;AACA;AACA,wBAAwB,2DAAW,aAAa;AAChD;AACA;AACA,yBAAyB;AACzB,KAAK;AACL;AACA,CAAC;;AAED,iDAAK;AACL;;AAEA;AACA;AACA,0BAA0B,2DAAW,aAAa;AAClD;AACA;AACA;AACA,UAAU,IAAI;AACd;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;AC7NR;;AAEmB;;AAEhC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAK;AACnB;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,CAAC;;AAED;AACA,kDAAkD,YAAY;;AAE9D;AACA;AACA;;AAEA,EAAE,iDAAK;AACP;AACA,GAAG;AACH;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;ACnGb;;AAEmB;AACsB;;AAEtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,iDAAK;AACd;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM,iDAAK;AACX;AACA;;AAEA;AACA;AACA;;AAEA,OAAO,iDAAK;;AAEZ,MAAM,iDAAK;AACX;AACA;;AAEA,MAAM,iDAAK;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,uBAAuB,iDAAK;;AAE5B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iDAAK;;AAEvB;AACA;AACA;AACA;;AAEA;AACA,MAAM,iDAAK;;AAEX,QAAQ,iDAAK;AACb;AACA,MAAM,QAAQ,iDAAK;AACnB,iBAAiB,oEAAY;AAC7B,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,iDAAK;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,iDAAK;AACjB;AACA;;AAEA,YAAY,iDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,iDAAK;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,iDAAK;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,iDAAK;AACb;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI,iDAAK;AACT,kBAAkB,iDAAK;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI,iDAAK;AACT,sEAAsE,iDAAK;AAC3E,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAI,iDAAK;;AAET;AACA;AACA;;AAEA;;AAEA;AACA,iDAAK,6CAA6C,MAAM;AACxD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,iDAAK;;AAEL,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;ACzSf;;AAEqB;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,eAAe;AACf;AACA;AACA,IAAI,iDAAK;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;;ACtErB;;AAE2C;AACJ;;AAEpD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACe;AACf,kBAAkB,qEAAa;AAC/B,WAAW,mEAAW;AACtB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpBa;;AAEkC;AACF;AACD;AACW;AACJ;AACJ;;AAE/C;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gEAAa;AAC3B;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,SAAS;AACtB;AACe;AACf;;AAEA,mBAAmB,6DAAY;;AAE/B;AACA,gBAAgB,yDAAa;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,6DAAQ,8BAA8B,0DAAQ;;AAEhE;AACA;;AAEA;AACA,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;;AAEA,uBAAuB,6DAAY;;AAEnC;AACA,GAAG;AACH,SAAS,+DAAQ;AACjB;;AAEA;AACA;AACA,+BAA+B,yDAAa;AAC5C;AACA;AACA;AACA;AACA,kCAAkC,6DAAY;AAC9C;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;AChFa;;AAEmB;AACa;;AAE7C,oDAAoD,wDAAY;;AAEhE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;;AAEA;AACA,QAAQ,iDAAK,0BAA0B,iDAAK;AAC5C,aAAa,iDAAK,aAAa,SAAS;AACxC,MAAM,SAAS,iDAAK;AACpB,aAAa,iDAAK,SAAS;AAC3B,MAAM,SAAS,iDAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,iDAAK;AACd;AACA,MAAM,UAAU,iDAAK;AACrB;AACA;AACA;;AAEA;AACA;AACA,SAAS,iDAAK;AACd;AACA;AACA;;AAEA;AACA;AACA,SAAS,iDAAK;AACd;AACA,MAAM,UAAU,iDAAK;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,iDAAK,qCAAqC;AAC5C;AACA;AACA,KAAK,iDAAK;AACV,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;;;ACzGa;;AAE4B;;AAEzC;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;AACA,IAAI;AACJ,eAAe,sDAAU;AACzB;AACA,OAAO,sDAAU,kBAAkB,sDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1Ba;;AAEqB;AACU;AACO;;AAEnD;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACe;AACf,yBAAyB,0DAAQ;AACjC;AACA,kBAAkB,6DAAY;AAC9B;;AAEA,EAAE,iDAAK;AACP;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3Ba;;AAEmB;AACe;AACM;AACH;AACY;AAClB;AACc;;AAE1D;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA,aAAa,QAAQ;AACrB;AACA;AACA,MAAM,iDAAK;AACX;AACA;AACA,aAAa,iDAAK;AAClB,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gBAAgB,wDAAoB;;AAEpC;;AAEA;AACA;AACA;AACA,4BAA4B,iDAAK;;AAEjC,2BAA2B,iDAAK;AAChC;AACA;;AAEA,uBAAuB,iDAAK;;AAE5B;AACA;AACA;AACA;AACA,iDAAiD,sEAAc;AAC/D;;AAEA,QAAQ,iDAAK;AACb,MAAM,iDAAK;AACX,MAAM,iDAAK;AACX,MAAM,iDAAK;AACX,MAAM,iDAAK;AACX;AACA;AACA;AACA,QAAQ,iDAAK;AACb;AACA;AACA,QAAQ,iDAAK;AACb,gEAAgE;AAChE;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,wEAAgB;AAC/B;;AAEA,wBAAwB,iDAAK;AAC7B;;AAEA,eAAe,kEAAU;AACzB,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,gBAAgB,iDAAK;AACrB;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,kBAAkB,2DAAU,SAAS,2DAAU;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,0DAAQ;AACtB,UAAU,0DAAQ;AAClB,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAK;AACL;AACA,CAAC;;AAED,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;AC9JX;;AAEb,iEAAe;AACf;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;ACNK;;;;;;;;;;;;;;;;ACAM;;AAE4B;;AAEzC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC;AACA,aAAa;AACb;AACA;AACA;;AAEA,YAAY,0DAAU;AACtB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,GAAG;AACH;;AAEA,iEAAe,oBAAoB,EAAC;;;;;;;;;;;;;;;;ACzDpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;ACtEjB;;AAEE;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNa;;AAEmB;AACsC;;AAEtE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ,uBAAuB,iDAAK;AAC5B;AACA,UAAU,wEAAoB;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC9Da;;AAEb;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACe;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACdkC;AACU;;AAE5C,iEAAe,0DAAQ;;AAEvB;AACA;AACA;AACA;;AAEA,MAAM,iDAAK;;AAEX,MAAM,iDAAK;;AAEX,MAAM,iDAAK;;AAEX;;AAEA,uCAAuC;AACvC,KAAK;;AAEL;AACA,0DAA0D,wBAAwB;AAClF;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,KAAK;AACL;AACA,GAAG,EAAC;;;;;;;;;;;;;;;;;;ACxCS;;AAEmB;;AAEhC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAK;AACd;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,iDAAK;;AAEzB;AACA,UAAU,iDAAK;AACf;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA,0BAA0B,iDAAK;AAC/B;AACA;;AAEA;;AAEA,kBAAkB,iDAAK;AACvB;AACA;;AAEA;AACA;;AAEA,MAAM,iDAAK,yBAAyB,iDAAK;AACzC;;AAEA,IAAI,iDAAK;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;;AC9FjB;;AAEb;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,SAAS;AACtB;AACe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACda;;AAEqB;;AAElC;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACe;AACf,SAAS,iDAAK;AACd;;;;;;;;;;;;;;;;;;ACba;;AAEqB;AACU;;AAE5C,iEAAe,0DAAQ;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG,EAAC;;;;;;;;;;;;;;;;AClEP;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;ACDP;;AAEqB;;AAElC;AACA;AACA,0BAA0B,iDAAK;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA,iEAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;ACtDW;;AAEE;AACf,0BAA0B,KAAK;AAC/B;AACA;;;;;;;;;;;;;;;;ACLa;;AAEb;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA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,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;;AAGA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA,2BAA2B,oBAAoB,IAAI;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,4BAA4B;AAC5B;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,kCAAkC;AAClC,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA,gCAAgC,WAAW,IAAI;AAC/C;AACA;AACA,eAAe,4DAAI;AACnB,MAAM;AACN;AACA;AACA,GAAG,GAAG,WAAW;AACjB;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,eAAe;;AAEzC;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACltB6F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACO,gDAAgD;AAChD,kDAAkD;AAClD;AACP;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,cAAc,iBAAiB;AACzF,KAAK;AACL;AACA;AACA,iDAAiD,IAAI;AACrD;AACA,mDAAmD,IAAI,GAAG,KAAK,KAAK,MAAM;AAC1E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL,iDAAiD;AACjD;AACA,wBAAwB,MAAM,GAAG,SAAS;AAC1C,oBAAoB;AACpB;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,KAAK;AACL;AACO;AACP,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,MAAM,IAAI;AACpE;AACA;AACA;AACA,mCAAmC,yBAAyB,KAAK,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAkD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa,0BAA0B,4CAAO,mCAAmC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa,SAAS,IAAI,GAAG,OAAO,IAAI,4CAAO,+CAA+C;AAC1H;AACA,sDAAsD,WAAW,SAAS,iBAAiB;AAC3F;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,8BAA8B,gBAAgB,QAAQ,aAAa,0BAA0B,4CAAO,mCAAmC;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB,KAAK,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,MAAM,KAAK,MAAM,MAAM;AAC5E;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,gBAAgB,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC;AAChC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,KAAK;AACxF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,yBAAyB;AACzB;AACA,cAAc,uBAAuB,GAAG,YAAY,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,GAAG;AACrE,SAAS;AACT;AACA;AACO,iBAAiB;AACxB;AACO;AACP;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;AACA,KAAK;AACL,CAAC;AACD;AACA;AACO;AACP;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACM;AACP;AACA;AACA;AACA,0DAA0D,6CAAI;AAC9D,6BAA6B,6CAAI;AACjC,KAAK;AACL;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAO;AACjC;AACA,SAAS;AACT,sDAAsD,4CAAO;AAC7D,KAAK;AACL;AACA;AACO;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACO;AACP;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,0DAA0D,kDAAS;AACnE,6BAA6B,gDAAO;AACpC,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACO;AACP;AACA,wDAAwD,MAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,sEAAsE,MAAM,QAAQ,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,wDAAwD,MAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,MAAM,SAAS;AAC3E;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,6CAA6C,6CAAI;AACjD;AACA;AACO;AACP;AACA;AACA;AACA,2DAA2D,OAAO,QAAQ,EAAE;AAC5E,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,KAAK,OAAO,KAAK;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA,qDAAqD,MAAM;AAC3D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oDAAoD,SAAS,EAAE,gCAAgC;AAC/F;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD,qBAAqB;AACrB,SAAS;AACT,KAAK;AACL;AACA,UAAU;AACH;AACP;AACA,wDAAwD,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wDAAwD,MAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACO;AACP;AACA,sDAAsD,IAAI;AAC1D;AACA,wDAAwD,MAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAA8C;AACxE,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP,oCAAoC,mBAAmB;AACvD,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA,4BAA4B,+CAAM;AAClC;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;AACA;AACA,4BAA4B,+CAAM,wBAAwB;AAC1D,sBAAsB,UAAU,MAAM,KAAK,EAAE,QAAQ;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,+CAAM;AACnC;AACA,+BAA+B,+CAAM;AACrC;AACA,qEAAqE,IAAI,aAAa,OAAO;AAC7F;AACA;AACA,gCAAgC,+CAAM;AACtC,SAAS;AACT;AACA;AACA;AACO;AACA;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA,6BAA6B,KAAK,GAAG,uBAAuB,OAAO,2BAA2B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO,gCAAgC;;;;;;;UClqCvC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNA;;AAEA;AAC8C;AAE9C,IAAMiI,MAAM,GAAG,IAAIjI,uDAAe,CAAC,CAAC;AACpC,IAAMyH,QAAQ,GAAG,UAAU;AAE3B,SAASS,aAAaA,CAAA,EAAG;EAErB,IAAMC,SAAS,GAAGL,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;EACtD,IAAMK,SAAS,GAAGN,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;EACtD,IAAMF,SAAS,GAAGC,QAAQ,CAACC,cAAc,CAAC,QAAQ,CAAC;;EAEnD;EACA,IAAGI,SAAS,CAACE,KAAK,CAAClM,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAMqE,IAAI,GAAG2H,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC;IAC/BlI,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;IAC/B6H,MAAM,CAAC3G,mBAAmB,CAACd,IAAI,EAAE,UAACtC,KAAK,EAAEgD,SAAS,EAAK;MACnD,IAAGhD,KAAK,EAAE;QACN2J,SAAS,CAACG,SAAS,sDAAAtE,MAAA,CAAoDxF,KAAK,CAAC0J,OAAO,YAAS;MACjG,CAAC,MAAM;QACHC,SAAS,CAACG,SAAS,gEAAAtE,MAAA,CAA8DxC,SAAS,CAACoH,IAAI,CAAC,GAAG,CAAC,SAAM;QAC1GL,MAAM,CAACT,eAAe,CAACtG,SAAS,EAAEuG,QAAQ,CAAC;MAC/C;IACJ,CAAC,CAAC;EACN;;EAEA;EACA,IAAM/F,SAAS,GAAG0G,SAAS,CAACtQ,KAAK,CAACyQ,IAAI,CAAC,CAAC;EACxC,IAAG7G,SAAS,KAAK,EAAE,EAAE;IACjB,IAAM8G,aAAa,GAAGP,MAAM,CAACxG,eAAe,CAACC,SAAS,CAAC;IACvDmG,SAAS,CAACG,SAAS,kEAAAtE,MAAA,CAAgE8E,aAAa,CAACF,IAAI,CAAC,GAAG,CAAC,SAAM;EACpH;AACJ;;AAEA;AACAG,MAAM,CAACP,aAAa,GAAGA,aAAa,C","sources":["webpack:///./modules/helperfns/index.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/@noble/curves/esm/_shortw_utils.js","webpack:///./node_modules/@noble/curves/esm/abstract/curve.js","webpack:///./node_modules/@noble/curves/esm/abstract/hash-to-curve.js","webpack:///./node_modules/@noble/curves/esm/abstract/modular.js","webpack:///./node_modules/@noble/curves/esm/abstract/utils.js","webpack:///./node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack:///./node_modules/@noble/curves/esm/secp256k1.js","webpack:///./node_modules/@noble/hashes/esm/_assert.js","webpack:///./node_modules/@noble/hashes/esm/_sha2.js","webpack:///./node_modules/@noble/hashes/esm/_u64.js","webpack:///./node_modules/@noble/hashes/esm/crypto.js","webpack:///./node_modules/@noble/hashes/esm/hmac.js","webpack:///./node_modules/@noble/hashes/esm/pbkdf2.js","webpack:///./node_modules/@noble/hashes/esm/ripemd160.js","webpack:///./node_modules/@noble/hashes/esm/sha256.js","webpack:///./node_modules/@noble/hashes/esm/sha512.js","webpack:///./node_modules/@noble/hashes/esm/utils.js","webpack:///./node_modules/@scure/base/lib/esm/index.js","webpack:///./node_modules/@scure/bip32/lib/esm/index.js","webpack:///./node_modules/@scure/bip39/esm/index.js","webpack:///./node_modules/@scure/bip39/esm/wordlists/english.js","webpack:///./node_modules/@scure/btc-signer/lib/esm/index.js","webpack:///./node_modules/axios/lib/adapters/adapters.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/cancel/CanceledError.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/core/AxiosError.js","webpack:///./node_modules/axios/lib/core/AxiosHeaders.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/buildFullPath.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/mergeConfig.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/defaults/index.js","webpack:///./node_modules/axios/lib/defaults/transitional.js","webpack:///./node_modules/axios/lib/env/data.js","webpack:///./node_modules/axios/lib/helpers/AxiosURLSearchParams.js","webpack:///./node_modules/axios/lib/helpers/HttpStatusCode.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/helpers/formDataToJSON.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/isAxiosError.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/null.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/parseProtocol.js","webpack:///./node_modules/axios/lib/helpers/speedometer.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./node_modules/axios/lib/helpers/toFormData.js","webpack:///./node_modules/axios/lib/helpers/toURLEncodedForm.js","webpack:///./node_modules/axios/lib/helpers/validator.js","webpack:///./node_modules/axios/lib/platform/browser/classes/Blob.js","webpack:///./node_modules/axios/lib/platform/browser/classes/FormData.js","webpack:///./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","webpack:///./node_modules/axios/lib/platform/browser/index.js","webpack:///./node_modules/axios/lib/platform/common/utils.js","webpack:///./node_modules/axios/lib/platform/index.js","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/micro-packed/lib/esm/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./modules/main.js"],"sourcesContent":["// index.js\r\n\r\n// class with helper functions for reading file data and converting plain text to UTF-8 byte array\r\n\r\n// import necessary libraries\r\nimport * as bip39 from '@scure/bip39';\r\nimport { wordlist } from '@scure/bip39/wordlists/english';\r\nimport { HDKey } from '@scure/bip32';\r\nimport * as btc from '@scure/btc-signer';\r\nimport axios from 'axios';\r\n\r\nimport { Buffer } from 'buffer';\r\n\r\nclass HelperFunctions {\r\n    constructor() {\r\n        this.mnemonic = this.generateMnemonic();\r\n        console.log(\"Am in the constructor!\");\r\n        this.feeEstiamtor = ''; //new btc._Estimator({});\r\n    }\r\n\r\n    // read file using the FileReader API\r\n    async readFileAsByteArray(file, callback){\r\n        const reader = new FileReader();\r\n\r\n        // set up an event listener for when the file is loaded\r\n        reader.onload = function (event) {\r\n            // access the result property which contain the file content as an ArrayBuffer\r\n            const arrayBuffer = event.target.result;\r\n\r\n            // convert the ArrayBuffer to a Uint8Array (byte array)\r\n            const byteArray = new Uint8Array(arrayBuffer);\r\n\r\n            // call the provided callback with byte array\r\n            callback(null, byteArray);\r\n        };\r\n\r\n        // set up an event listener for when an error occurs\r\n        reader.onerror = function(event) {\r\n            // call the callback with an error object\r\n            callback(new Error('Error reading the file', event.target.error));\r\n        };\r\n\r\n        // read the file as an array buffer\r\n        reader.readAsArrayBuffer(file);\r\n    }\r\n\r\n    // convert plain text to UTF-8 array\r\n    textToUTF8Array(plainText) {\r\n        // create a TextEncoder instance\r\n        const textEncoder = new TextEncoder();\r\n\r\n        // use the encode method to convert the text to a UintArray (UTF-8 byte array)\r\n        const byteArray = textEncoder.encode(plainText);\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    // generate mnemonic\r\n    generateMnemonic() {\r\n        return bip39.generateMnemonic(wordlist, 128);\r\n    }\r\n\r\n    // validate menmonic\r\n    validateMnemonic(mnemonic) {\r\n        return bip39.validateMnemonic(mnemonic, wordlist);\r\n    }\r\n\r\n    // get estimated fee\r\n    async getEstimatedFee() {\r\n        try {\r\n            const feeRate = await this.feeEstiamtor.getFeeRate();\r\n            return feeRate;\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // get inputs\r\n    async getInputs(amount, privateKey) {\r\n        try {\r\n            const nodeUrl = process.env.BITCOIN_API;\r\n            const response = await axios.get(`${nodeUrl}/unspent/${privateKey.getAddress()}`);\r\n            const inputs = response.data;\r\n\r\n            // filter inputs until the required amount is covered\r\n            let totalAmount = 0;\r\n            const selectedInputs = [];\r\n            for(const input of inputs){\r\n                totalAmount += input.amount;\r\n                selectedInputs.push(input);\r\n                if(totalAmount >= amount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // check if inputs cover the required amount\r\n            if(totalAmount < amount) {\r\n                this.handleError(\"Insufficient funds\");\r\n            }\r\n\r\n            return selectedInputs;\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // derive key pairs\r\n    derivePrivateKey(seed){\r\n        console.log(\"Master key!\", seed);\r\n        const masterKey = HDKey.fromMasterSeed(seed);        \r\n        const path = \"m/44'/0'/0'/0/0\"; //bip44 path\r\n        const privateKey = masterKey.derive(path).privateKey;\r\n        return privateKey;\r\n    }\r\n\r\n    // create a transaction\r\n    async createTransaction(data, privateKey) {\r\n        try {\r\n            // initislize transaction builder\r\n            const txBuilder = new btc.Transaction();\r\n\r\n            txBuilder.unsignedTx;\r\n\r\n            // Assuming `data` is a byte array containing the correct data:\r\n            const dataHex = Buffer.from(data).toString('hex');\r\n\r\n            const script = btc.OutScript.encode(data).buffer('hex');\r\n                    \r\n            // Ensure even hex length:\r\n            const adjustedDataHex = dataHex.length % 2 === 0 ? dataHex : '0' + dataHex;\r\n                    \r\n            // Calculate correct push size:\r\n            const dataLength = adjustedDataHex.length / 2;\r\n            const pushSize = dataLength <= 75 ? dataLength : Math.ceil(Math.log2(dataLength) / 8) + 76;\r\n                    \r\n            // Construct complete output script:\r\n            const outputScript = `OP_RETURN ${pushSize.toString(16)}${adjustedDataHex}`;\r\n            //new Uint8Array([0x4c + data.length]).join(data);\r\n\r\n            console.log(\"Output script: \", outputScript);\r\n\r\n            // add the output with a value of 0 (no value transfer)\r\n            txBuilder.addOutput({\r\n                script: script,\r\n                amount: BigInt(\"0\")\r\n            });\r\n\r\n            // set teh network parameters\r\n            //txBuilder. // here you can use the other networks i.e mainnet, regtest as needed\r\n\r\n            console.log(\"Estimating transaction fee...\");\r\n            // estimate the transaction fee\r\n            const feeRate = await this.getEstimatedFee();\r\n            console.log(\"Fee rate: \", feeRate);\r\n            const estimatedFee = Math.ceil(txBuilder.fee({feeRate}));\r\n            console.log(\"Fee rate: \", estimatedFee);\r\n\r\n            console.log(\"Generating inputs...\")\r\n            // add inputs to cover the data output and transaction fee\r\n            const inputs = await this.getInputs(estimatedFee, privateKey);\r\n            console.log(\"Inputs: \", inputs);\r\n\r\n            // add the inputs to the transaction\r\n            for(const input of inputs){\r\n                txBuilder.addInput({\r\n                    txid: input.txid, \r\n                    index: input.index,\r\n                    witnessUtxo: {\r\n                        amount: input.amount,\r\n                        script: Buffer.from(input.script, 'hex')\r\n                    }\r\n                })\r\n            }\r\n\r\n            // sign the transaction\r\n            txBuilder.sign(0, privateKey);\r\n\r\n            // return the signed transaction\r\n            return txBuilder.build();\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // broadcast the transaction\r\n    async broadcastTx(signedTx) {\r\n        try {\r\n            // the bitcoin node API for broadcasting\r\n            const nodeUrl = process.env.BITCOIN_API;\r\n\r\n            // build the request body\r\n            const requestBody = {\r\n                txid: signedTx.id,\r\n                hex: signedTx.toHex(),\r\n            };\r\n\r\n             // send the POST request to broadcast the transaction\r\n            const response = await axios.post(nodeUrl, requestBody);\r\n\r\n            console.log(\"Transaction broadcast successfully: \", response.data);\r\n            this.displayResults(response.data);\r\n        } catch(error) {\r\n            console.error(\"Error broadcasting transaction: \", error);\r\n            this.handleError(error);\r\n        }\r\n        \r\n    }\r\n\r\n    // upload file or write plain text to bitcoin mainchain\r\n    uploadToBitcoin(data, password) {\r\n        console.log(\"Starting the upload process: \", data);\r\n        try {\r\n            const mnemonic = this.mnemonic;\r\n            console.log(\"Generated mnemonic: \", mnemonic);\r\n\r\n            // valiadet mnemonic for being 12 words\r\n            if(this.validateMnemonic(mnemonic)) {\r\n                // derive key data from mnemonic(generate seed)\r\n                const seed = bip39.mnemonicToSeedSync(mnemonic, password); // password is optional\r\n                console.log(\"The mnemonic was valid!\", seed);\r\n                //derive private key from master key for address (\"m/44' /0' /0' /0/0\")\r\n                const privateKey = this.derivePrivateKey(seed);\r\n                console.log(\"Private Key\", privateKey);\r\n\r\n                // build the transaction (signed)\r\n                const transaction = this.createTransaction(data, privateKey);\r\n                console.log(\"Transaction: \", transaction);\r\n\r\n                // broadcast the transaction\r\n                //this.broadcastTx(transaction);         \r\n            \r\n            } else {\r\n                this.handleError(\"Invalid mnemonic\");\r\n            }\r\n        } catch(error) {\r\n            this.handleError(\"Error during upload: \" + error);\r\n        }\r\n    }\r\n\r\n    // display results\r\n    displayResults(message) {\r\n        const resultDiv = document.getElementById('result');\r\n        resultDiv.innerHTML = `Broadcasting transaction: ${message}`;\r\n    }\r\n\r\n    // handle errors\r\n    handleError(message) {\r\n        console.log(message);\r\n        const resultDiv = document.getElementById('result');\r\n        resultDiv.innerHTML = `<span style=\"color: red;\">Error: ${message}</span>`;\r\n    }\r\n}\r\n\r\n// export class as a module\r\nexport {HelperFunctions};","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","import { mod } from './modular.js';\nimport { bytesToNumberBE, isBytes, concatBytes, utf8ToBytes, validateObject } from './utils.js';\nfunction validateDST(dst) {\n    if (isBytes(dst))\n        return dst;\n    if (typeof dst === 'string')\n        return utf8ToBytes(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexport function isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexport function createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!ut.isBytes(data))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    assertHash(hash);\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    assertNumber(c);\n    assertNumber(dkLen);\n    assertNumber(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = toBytes(_password);\n    const salt = toBytes(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexport async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await asyncLoop(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n","/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { bytes as assertBytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { createBase58check } from '@scure/base';\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${bytesToHex(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return hexToBytes(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        assertBytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string') {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this.pubKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = mod(this.privKey + childTweak, secp.CURVE.n);\n                if (!secp.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        assertBytes(hash, 32);\n        return secp.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        assertBytes(hash, 32);\n        assertBytes(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        assertBytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map","/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { bytes as assertBytes, number as assertNumber } from '@noble/hashes/_assert';\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    assertBytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    assertNumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n","export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n","/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, createBase58check, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nconst { ProjectivePoint: ProjPoint, sign: _signECDSA, getPublicKey: _pubECDSA } = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => (value === undefined ? def : value);\nconst isBytes = P.isBytes;\nconst hash160 = (msg) => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = createBase58check(sha256);\nexport function cloneDeep(obj) {\n    if (Array.isArray(obj))\n        return obj.map((i) => cloneDeep(i));\n    // slice of nodejs Buffer doesn't copy\n    else if (obj instanceof Uint8Array)\n        return Uint8Array.from(obj);\n    // immutable\n    else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj))\n        return obj;\n    // null is object\n    else if (obj === null)\n        return obj;\n    // should be last, so it won't catch other types\n    else if (typeof obj === 'object') {\n        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n    }\n    throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\nvar PubT;\n(function (PubT) {\n    PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n    PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n    const len = pub.length;\n    if (type === PubT.ecdsa) {\n        if (len === 32)\n            throw new Error('Expected non-Schnorr key');\n        ProjPoint.fromHex(pub); // does assertValidity\n        return pub;\n    }\n    else if (type === PubT.schnorr) {\n        if (len !== 32)\n            throw new Error('Expected 32-byte Schnorr key');\n        schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n        return pub;\n    }\n    else {\n        throw new Error('Unknown key type');\n    }\n}\nfunction isValidPubkey(pub, type) {\n    try {\n        validatePubkey(pub, type);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig) => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n    let sig = _signECDSA(hash, privateKey);\n    if (lowR && !hasLowR(sig)) {\n        const extraEntropy = new Uint8Array(32);\n        for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n            extraEntropy.set(P.U32LE.encode(cnt));\n            sig = _signECDSA(hash, privateKey, { extraEntropy });\n            if (hasLowR(sig))\n                break;\n        }\n    }\n    return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n    const u = schnorr.utils;\n    const t = u.taggedHash('TapTweak', a, b);\n    const tn = u.bytesToNumberBE(t);\n    if (tn >= CURVE_ORDER)\n        throw new Error('tweak higher than curve order');\n    return tn;\n}\nexport function taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n    const u = schnorr.utils;\n    const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n    const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n    // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n    const xP = u.pointToBytes(P);\n    // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n    const t = tapTweak(xP, merkleRoot);\n    // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n    const u = schnorr.utils;\n    const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n    const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n    const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n    const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n    return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), (pub) => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), (pub) => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), (sig) => {\n    if (sig.length !== 64 && sig.length !== 65)\n        throw new Error('Schnorr signature should be 64 or 65 bytes long');\n    return sig;\n});\nfunction uniqPubkey(pubkeys) {\n    const map = {};\n    for (const pub of pubkeys) {\n        const key = hex.encode(pub);\n        if (map[key])\n            throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n        map[key] = true;\n    }\n}\nexport const NETWORK = {\n    bech32: 'bc',\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nexport const TEST_NETWORK = {\n    bech32: 'tb',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n    if (!isBytes(a) || !isBytes(b))\n        throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n    // -1 -> a<b, 0 -> a==b, 1 -> a>b\n    const len = Math.min(a.length, b.length);\n    for (let i = 0; i < len; i++)\n        if (a[i] != b[i])\n            return Math.sign(a[i] - b[i]);\n    return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n    OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n    OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n    OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n    OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n    OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n    OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n    OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n    OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n    OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n    OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n    OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n    OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n    OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n    OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n    OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n    OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n    OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n    OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n    OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n    OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n    OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n    OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n    // Control\n    OP[OP[\"NOP\"] = 97] = \"NOP\";\n    OP[OP[\"VER\"] = 98] = \"VER\";\n    OP[OP[\"IF\"] = 99] = \"IF\";\n    OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n    OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n    OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n    OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n    OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n    OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n    OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n    // Stack\n    OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n    OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n    OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n    OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n    OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n    OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n    OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n    OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n    OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n    OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n    OP[OP[\"DROP\"] = 117] = \"DROP\";\n    OP[OP[\"DUP\"] = 118] = \"DUP\";\n    OP[OP[\"NIP\"] = 119] = \"NIP\";\n    OP[OP[\"OVER\"] = 120] = \"OVER\";\n    OP[OP[\"PICK\"] = 121] = \"PICK\";\n    OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n    OP[OP[\"ROT\"] = 123] = \"ROT\";\n    OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n    OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n    // Splice\n    OP[OP[\"CAT\"] = 126] = \"CAT\";\n    OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n    OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n    OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n    OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n    // Boolean logic\n    OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n    OP[OP[\"AND\"] = 132] = \"AND\";\n    OP[OP[\"OR\"] = 133] = \"OR\";\n    OP[OP[\"XOR\"] = 134] = \"XOR\";\n    OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n    OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n    OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n    OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n    // Numbers\n    OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n    OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n    OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n    OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n    OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n    OP[OP[\"ABS\"] = 144] = \"ABS\";\n    OP[OP[\"NOT\"] = 145] = \"NOT\";\n    OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n    OP[OP[\"ADD\"] = 147] = \"ADD\";\n    OP[OP[\"SUB\"] = 148] = \"SUB\";\n    OP[OP[\"MUL\"] = 149] = \"MUL\";\n    OP[OP[\"DIV\"] = 150] = \"DIV\";\n    OP[OP[\"MOD\"] = 151] = \"MOD\";\n    OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n    OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n    OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n    OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n    OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n    OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n    OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n    OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n    OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n    OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n    OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n    OP[OP[\"MIN\"] = 163] = \"MIN\";\n    OP[OP[\"MAX\"] = 164] = \"MAX\";\n    OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n    // Crypto\n    OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n    OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n    OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n    OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n    OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n    OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n    OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n    OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n    OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n    OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n    // Expansion\n    OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n    OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n    OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n    OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n    OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n    OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n    OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n    OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n    OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n    OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n    // BIP 342\n    OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n    // Invalid\n    OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script = P.wrap({\n    encodeStream: (w, value) => {\n        for (let o of value) {\n            if (typeof o === 'string') {\n                if (OP[o] === undefined)\n                    throw new Error(`Unknown opcode=${o}`);\n                w.byte(OP[o]);\n                continue;\n            }\n            else if (typeof o === 'number') {\n                if (o === 0x00) {\n                    w.byte(0x00);\n                    continue;\n                }\n                else if (1 <= o && o <= 16) {\n                    w.byte(OP.OP_1 - 1 + o);\n                    continue;\n                }\n            }\n            // Encode big numbers\n            if (typeof o === 'number')\n                o = ScriptNum().encode(BigInt(o));\n            if (!isBytes(o))\n                throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n            // Bytes\n            const len = o.length;\n            if (len < OP.PUSHDATA1)\n                w.byte(len);\n            else if (len <= 0xff) {\n                w.byte(OP.PUSHDATA1);\n                w.byte(len);\n            }\n            else if (len <= 0xffff) {\n                w.byte(OP.PUSHDATA2);\n                w.bytes(P.U16LE.encode(len));\n            }\n            else {\n                w.byte(OP.PUSHDATA4);\n                w.bytes(P.U32LE.encode(len));\n            }\n            w.bytes(o);\n        }\n    },\n    decodeStream: (r) => {\n        const out = [];\n        while (!r.isEnd()) {\n            const cur = r.byte();\n            // if 0 < cur < 78\n            if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n                let len;\n                if (cur < OP.PUSHDATA1)\n                    len = cur;\n                else if (cur === OP.PUSHDATA1)\n                    len = P.U8.decodeStream(r);\n                else if (cur === OP.PUSHDATA2)\n                    len = P.U16LE.decodeStream(r);\n                else if (cur === OP.PUSHDATA4)\n                    len = P.U32LE.decodeStream(r);\n                else\n                    throw new Error('Should be not possible');\n                out.push(r.bytes(len));\n            }\n            else if (cur === 0x00) {\n                out.push(0);\n            }\n            else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n                out.push(cur - (OP.OP_1 - 1));\n            }\n            else {\n                const op = OP[cur];\n                if (op === undefined)\n                    throw new Error(`Unknown opcode=${cur.toString(16)}`);\n                out.push(op);\n            }\n        }\n        return out;\n    },\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false) {\n    return P.wrap({\n        encodeStream: (w, value) => {\n            if (value === 0n)\n                return;\n            const neg = value < 0;\n            const val = BigInt(value);\n            const nums = [];\n            for (let abs = neg ? -val : val; abs; abs >>= 8n)\n                nums.push(Number(abs & 0xffn));\n            if (nums[nums.length - 1] >= 0x80)\n                nums.push(neg ? 0x80 : 0);\n            else if (neg)\n                nums[nums.length - 1] |= 0x80;\n            w.bytes(new Uint8Array(nums));\n        },\n        decodeStream: (r) => {\n            const len = r.leftBytes;\n            if (len > bytesLimit)\n                throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n            if (len === 0)\n                return 0n;\n            if (forceMinimal) {\n                // MSB is zero (without sign bit) -> not minimally encoded\n                if ((r.data[len - 1] & 0x7f) === 0) {\n                    // exception\n                    if (len <= 1 || (r.data[len - 2] & 0x80) === 0)\n                        throw new Error('Non-minimally encoded ScriptNum');\n                }\n            }\n            let last = 0;\n            let res = 0n;\n            for (let i = 0; i < len; ++i) {\n                last = r.byte();\n                res |= BigInt(last) << (8n * BigInt(i));\n            }\n            if (last >= 0x80) {\n                res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n                res = -res;\n            }\n            return res;\n        },\n    });\n}\nexport function OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n    if (typeof op === 'number')\n        return op;\n    if (isBytes(op)) {\n        try {\n            const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n            if (val > Number.MAX_SAFE_INTEGER)\n                return;\n            return Number(val);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n    0xfd: [0xfd, 2, 253n, 65535n],\n    0xfe: [0xfe, 4, 65536n, 4294967295n],\n    0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize = P.wrap({\n    encodeStream: (w, value) => {\n        if (typeof value === 'number')\n            value = BigInt(value);\n        if (0n <= value && value <= 252n)\n            return w.byte(Number(value));\n        for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n            if (start > value || value > stop)\n                continue;\n            w.byte(flag);\n            for (let i = 0; i < bytes; i++)\n                w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n            return;\n        }\n        throw w.err(`VarInt too big: ${value}`);\n    },\n    decodeStream: (r) => {\n        const b0 = r.byte();\n        if (b0 <= 0xfc)\n            return BigInt(b0);\n        const [_, bytes, start] = CSLimits[b0];\n        let num = 0n;\n        for (let i = 0; i < bytes; i++)\n            num |= BigInt(r.byte()) << (8n * BigInt(i));\n        if (num < start)\n            throw r.err(`Wrong CompactSize(${8 * bytes})`);\n        return num;\n    },\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport const BTCArray = (t) => P.array(CompactSize, t);\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\nexport const RawInput = P.struct({\n    txid: P.bytes(32, true), // hash(prev_tx),\n    index: P.U32LE, // output number of previous tx\n    finalScriptSig: VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n    sequence: P.U32LE, // ?\n});\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\nconst EMPTY_OUTPUT = {\n    amount: 0xffffffffffffffffn,\n    script: P.EMPTY,\n};\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n    version: P.I32LE,\n    segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n    inputs: BTCArray(RawInput),\n    outputs: BTCArray(RawOutput),\n    witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n    // < 500000000\tBlock number at which this transaction is unlocked\n    // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n    // Handled as part of PSBTv2\n    lockTime: P.U32LE,\n});\nfunction validateRawTx(tx) {\n    if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n        throw new Error('Segwit flag with empty witnesses array');\n    return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n    const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n    return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\nconst BIP32Der = P.struct({\n    fingerprint: P.U32BE,\n    path: P.array(null, P.U32LE),\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n    version: P.U8, // With parity :(\n    internalKey: P.bytes(32),\n    merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n    if (cb.merklePath.length > 128)\n        throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n    return cb;\n});\nconst TaprootBIP32Der = P.struct({\n    hashes: P.array(CompactSizeLen, P.bytes(32)),\n    der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n    unsignedTx: [0x00, false, RawTx, [0], [0], false],\n    xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n    txVersion: [0x02, false, P.U32LE, [2], [2], false],\n    fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n    inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n    outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n    txModifiable: [0x06, false, P.U8, [], [2], false], // TODO: bitfield\n    version: [0xfb, false, P.U32LE, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// prettier-ignore\nconst PSBTInput = {\n    nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n    witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n    partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n    sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n    redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n    finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n    porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n    ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n    sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n    hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n    hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n    txid: [0x0e, false, Bytes32, [2], [2], true],\n    index: [0x0f, false, P.U32LE, [2], [2], true],\n    sequence: [0x10, false, P.U32LE, [], [2], true],\n    requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n    requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n    tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n    tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n    tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n    tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n    tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n    tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys = [\n    'txid',\n    'sequence',\n    'index',\n    'witnessUtxo',\n    'nonWitnessUtxo',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'unknown',\n];\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys = [\n    'partialSig',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'tapKeySig',\n    'tapScriptSig',\n];\n// prettier-ignore\nconst PSBTOutput = {\n    redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    amount: [0x03, false, P.I64LE, [2], [2], true],\n    script: [0x04, false, BytesInf, [2], [2], true],\n    tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n    tapTree: [0x06, false, tapTree, [], [0, 2], false],\n    tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n}));\nconst PSBTUnknownKey = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n    // -> Record<type, [keyName, ...coders]>\n    const byType = {};\n    for (const k in psbtEnum) {\n        const [num, kc, vc] = psbtEnum[k];\n        byType[num] = [k, kc, vc];\n    }\n    return P.wrap({\n        encodeStream: (w, value) => {\n            let out = [];\n            // Because we use order of psbtEnum, keymap is sorted here\n            for (const name in psbtEnum) {\n                const val = value[name];\n                if (val === undefined)\n                    continue;\n                const [type, kc, vc] = psbtEnum[name];\n                if (!kc) {\n                    out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n                }\n                else {\n                    // Low level interface, returns keys as is (with duplicates). Useful for debug\n                    const kv = val.map(([k, v]) => [\n                        kc.encode(k),\n                        vc.encode(v),\n                    ]);\n                    // sort by keys\n                    kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n                    for (const [key, value] of kv)\n                        out.push({ key: { key, type }, value });\n                }\n            }\n            if (value.unknown) {\n                value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n                for (const [k, v] of value.unknown)\n                    out.push({ key: k, value: v });\n            }\n            PSBTKeyPair.encodeStream(w, out);\n        },\n        decodeStream: (r) => {\n            const raw = PSBTKeyPair.decodeStream(r);\n            const out = {};\n            const noKey = {};\n            for (const elm of raw) {\n                let name = 'unknown';\n                let key = elm.key.key;\n                let value = elm.value;\n                if (byType[elm.key.type]) {\n                    const [_name, kc, vc] = byType[elm.key.type];\n                    name = _name;\n                    if (!kc && key.length) {\n                        throw new Error(`PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`);\n                    }\n                    key = kc ? kc.decode(key) : undefined;\n                    value = vc.decode(value);\n                    if (!kc) {\n                        if (out[name])\n                            throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n                        out[name] = value;\n                        noKey[name] = true;\n                        continue;\n                    }\n                }\n                else {\n                    // For unknown: add key type inside key\n                    key = { type: elm.key.type, key: elm.key.key };\n                }\n                // Only keyed elements at this point\n                if (noKey[name])\n                    throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n                if (!out[name])\n                    out[name] = [];\n                out[name].push([key, value]);\n            }\n            return out;\n        },\n    });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n    if (!P.equalBytes(s.hash, sha256(witnessScript)))\n        throw new Error('checkScript: wsh wrong witnessScript hash');\n    const w = OutScript.decode(witnessScript);\n    if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n    if (w.type === 'wpkh' || w.type === 'sh')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n    if (script) {\n        const s = OutScript.decode(script);\n        // ms||pk maybe work, but there will be no address, hard to spend\n        if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n            throw new Error(`checkScript: non-wrapped ${s.type}`);\n        if (s.type === 'sh' && redeemScript) {\n            if (!P.equalBytes(s.hash, hash160(redeemScript)))\n                throw new Error('checkScript: sh wrong redeemScript hash');\n            const r = OutScript.decode(redeemScript);\n            if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n                throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n            // Not sure if this unspendable, but we cannot represent this via PSBT\n            if (r.type === 'sh')\n                throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n        }\n        if (s.type === 'wsh' && witnessScript)\n            checkWSH(s, witnessScript);\n    }\n    if (redeemScript) {\n        const r = OutScript.decode(redeemScript);\n        if (r.type === 'wsh' && witnessScript)\n            checkWSH(r, witnessScript);\n    }\n}\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n    if (i.finalScriptWitness && !i.finalScriptWitness.length)\n        throw new Error('validateInput: wmpty finalScriptWitness');\n    //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n    if (i.partialSig && !i.partialSig.length)\n        throw new Error('Empty partialSig');\n    if (i.partialSig)\n        for (const [k] of i.partialSig)\n            validatePubkey(k, PubT.ecdsa);\n    if (i.bip32Derivation)\n        for (const [k] of i.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n    if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n        throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n    // unsigned little endian integer greater than 0 and less than 500000000\n    if (i.requiredHeightLocktime !== undefined &&\n        (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000))\n        throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n    if (i.nonWitnessUtxo && i.index !== undefined) {\n        const last = i.nonWitnessUtxo.outputs.length - 1;\n        if (i.index > last)\n            throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n        const prevOut = i.nonWitnessUtxo.outputs[i.index];\n        if (i.witnessUtxo &&\n            (!P.equalBytes(i.witnessUtxo.script, prevOut.script) ||\n                i.witnessUtxo.amount !== prevOut.amount))\n            throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n    }\n    if (i.tapLeafScript) {\n        // tap leaf version appears here twice: in control block and at the end of script\n        for (const [k, v] of i.tapLeafScript) {\n            if ((k.version & 254) !== v[v.length - 1])\n                throw new Error('validateInput: tapLeafScript version mimatch');\n            if (v[v.length - 1] & 1)\n                throw new Error('validateInput: tapLeafScript version has parity bit!');\n        }\n    }\n    // Validate txid for nonWitnessUtxo is correct\n    if (i.nonWitnessUtxo && i.index !== undefined && i.txid) {\n        const outputs = i.nonWitnessUtxo.outputs;\n        if (outputs.length - 1 < i.index)\n            throw new Error('nonWitnessUtxo: incorect output index');\n        // At this point, we are using previous tx output to create new input.\n        // Script safety checks are unnecessary:\n        // - User has no control over previous tx. If somebody send money in same tx\n        //   as unspendable output, we still want user able to spend money\n        // - We still want some checks to notify user about possible errors early\n        //   in case user wants to use wrong input by mistake\n        // - Worst case: tx will be rejected by nodes. Still better than disallowing user\n        //   to spend real input, no matter how broken it looks\n        const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo), {\n            allowUnknownOutputs: true,\n            disableScriptCheck: true,\n            allowUnknownInputs: true,\n        });\n        const txid = hex.encode(i.txid);\n        // PSBTv2 vectors have non-final tx in inputs\n        if (tx.isFinal && tx.id !== txid)\n            throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n    }\n    return i;\n});\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n    if (o.bip32Derivation)\n        for (const [k] of o.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n    const version = g.version || 0;\n    if (version === 0) {\n        if (!g.unsignedTx)\n            throw new Error('PSBTv0: missing unsignedTx');\n        if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses)\n            throw new Error('PSBTv0: witness in unsingedTx');\n        for (const inp of g.unsignedTx.inputs)\n            if (inp.finalScriptSig && inp.finalScriptSig.length)\n                throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n    }\n    return g;\n});\nexport const _RawPSBTV0 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n    outputs: P.array(null, PSBTOutputCoder),\n});\nexport const _RawPSBTV2 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/inputCount', PSBTInputCoder),\n    outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\nexport const _DebugPSBT = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict())),\n});\nfunction validatePSBTFields(version, info, lst) {\n    for (const k in lst) {\n        if (k === 'unknown')\n            continue;\n        if (!info[k])\n            continue;\n        const { allowInc } = PSBTKeyInfo(info[k]);\n        if (!allowInc.includes(version))\n            throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n    }\n    for (const k in info) {\n        const { reqInc } = PSBTKeyInfo(info[k]);\n        if (reqInc.includes(version) && lst[k] === undefined)\n            throw new Error(`PSBTv${version}: missing required field ${k}`);\n    }\n}\nfunction cleanPSBTFields(version, info, lst) {\n    const out = {};\n    for (const _k in lst) {\n        const k = _k;\n        if (k !== 'unknown') {\n            if (!info[k])\n                continue;\n            const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n            if (!allowInc.includes(version)) {\n                if (silentIgnore)\n                    continue;\n                throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n            }\n        }\n        out[k] = lst[k];\n    }\n    return out;\n}\nfunction validatePSBT(tx) {\n    const version = (tx && tx.global && tx.global.version) || 0;\n    validatePSBTFields(version, PSBTGlobal, tx.global);\n    for (const i of tx.inputs)\n        validatePSBTFields(version, PSBTInput, i);\n    for (const o of tx.outputs)\n        validatePSBTFields(version, PSBTOutput, o);\n    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n    const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n    if (tx.inputs.length < inputCount)\n        throw new Error('Not enough inputs');\n    const inputsLeft = tx.inputs.slice(inputCount);\n    if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n        throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n    // Same for inputs\n    const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n    if (tx.outputs.length < outputCount)\n        throw new Error('Not outputs inputs');\n    const outputsLeft = tx.outputs.slice(outputCount);\n    if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n        throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n    return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n    const res = { ...cur, ...val };\n    // All arguments can be provided as hex\n    for (const k in psbtEnum) {\n        const key = k;\n        const [_, kC, vC] = psbtEnum[key];\n        const cannotChange = allowedFields && !allowedFields.includes(k);\n        if (val[k] === undefined && k in val) {\n            if (cannotChange)\n                throw new Error(`Cannot remove signed field=${k}`);\n            delete res[k];\n        }\n        else if (kC) {\n            const oldKV = (cur && cur[k] ? cur[k] : []);\n            let newKV = val[key];\n            if (newKV) {\n                if (!Array.isArray(newKV))\n                    throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                // Decode hex in k-v\n                newKV = newKV.map((val) => {\n                    if (val.length !== 2)\n                        throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                    return [\n                        typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n                        typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n                    ];\n                });\n                const map = {};\n                const add = (kStr, k, v) => {\n                    if (map[kStr] === undefined) {\n                        map[kStr] = [k, v];\n                        return;\n                    }\n                    const oldVal = hex.encode(vC.encode(map[kStr][1]));\n                    const newVal = hex.encode(vC.encode(v));\n                    if (oldVal !== newVal)\n                        throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n                };\n                for (const [k, v] of oldKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    add(kStr, k, v);\n                }\n                for (const [k, v] of newKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    // undefined removes previous value\n                    if (v === undefined) {\n                        if (cannotChange)\n                            throw new Error(`Cannot remove signed field=${key}/${k}`);\n                        delete map[kStr];\n                    }\n                    else\n                        add(kStr, k, v);\n                }\n                res[key] = Object.values(map);\n            }\n        }\n        else if (typeof res[k] === 'string') {\n            res[k] = vC.decode(hex.decode(res[k]));\n        }\n        else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n            if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n                throw new Error(`Cannot change signed field=${k}`);\n        }\n    }\n    // Remove unknown keys\n    for (const k in res)\n        if (!psbtEnum[k])\n            delete res[k];\n    return res;\n}\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\nconst OutPK = {\n    encode(from) {\n        if (from.length !== 2 ||\n            !isBytes(from[0]) ||\n            !isValidPubkey(from[0], PubT.ecdsa) ||\n            from[1] !== 'CHECKSIG')\n            return;\n        return { type: 'pk', pubkey: from[0] };\n    },\n    decode: (to) => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n// @ts-ignore\nexport const p2pk = (pubkey, network = NETWORK) => {\n    // network is unused\n    if (!isValidPubkey(pubkey, PubT.ecdsa))\n        throw new Error('P2PK: invalid publicKey');\n    return {\n        type: 'pk',\n        script: OutScript.encode({ type: 'pk', pubkey }),\n    };\n};\nconst OutPKH = {\n    encode(from) {\n        if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2]))\n            return;\n        if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG')\n            return;\n        return { type: 'pkh', hash: from[2] };\n    },\n    decode: (to) => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\nexport const p2pkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2PKH: invalid publicKey');\n    const hash = hash160(publicKey);\n    return {\n        type: 'pkh',\n        script: OutScript.encode({ type: 'pkh', hash }),\n        address: Address(network).encode({ type: 'pkh', hash }),\n    };\n};\nconst OutSH = {\n    encode(from) {\n        if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL')\n            return;\n        return { type: 'sh', hash: from[1] };\n    },\n    decode: (to) => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\nexport const p2sh = (child, network = NETWORK) => {\n    // It is already tested inside noble-hashes and checkScript\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n    const hash = hash160(cs);\n    const script = OutScript.encode({ type: 'sh', hash });\n    checkScript(script, cs, child.witnessScript);\n    const res = {\n        type: 'sh',\n        redeemScript: cs,\n        script: OutScript.encode({ type: 'sh', hash }),\n        address: Address(network).encode({ type: 'sh', hash }),\n    };\n    if (child.witnessScript)\n        res.witnessScript = child.witnessScript;\n    return res;\n};\nconst OutWSH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 32)\n            return;\n        return { type: 'wsh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\nexport const p2wsh = (child, network = NETWORK) => {\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n    const hash = sha256(cs);\n    const script = OutScript.encode({ type: 'wsh', hash });\n    checkScript(script, undefined, cs);\n    return {\n        type: 'wsh',\n        witnessScript: cs,\n        script: OutScript.encode({ type: 'wsh', hash }),\n        address: Address(network).encode({ type: 'wsh', hash }),\n    };\n};\nconst OutWPKH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 20)\n            return;\n        return { type: 'wpkh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\nexport const p2wpkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2WPKH: invalid publicKey');\n    if (publicKey.length === 65)\n        throw new Error('P2WPKH: uncompressed public key');\n    const hash = hash160(publicKey);\n    return {\n        type: 'wpkh',\n        script: OutScript.encode({ type: 'wpkh', hash }),\n        address: Address(network).encode({ type: 'wpkh', hash }),\n    };\n};\nconst OutMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKMULTISIG')\n            return;\n        const m = from[0];\n        const n = from[last - 1];\n        if (typeof m !== 'number' || typeof n !== 'number')\n            return;\n        const pubkeys = from.slice(1, -2);\n        if (n !== pubkeys.length)\n            return;\n        for (const pub of pubkeys)\n            if (!isBytes(pub))\n                return;\n        return { type: 'ms', m, pubkeys: pubkeys }; // we don't need n, since it is the same as pubkeys\n    },\n    // checkmultisig(n, ..pubkeys, m)\n    decode: (to) => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\nexport const p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return { type: 'ms', script: OutScript.encode({ type: 'ms', pubkeys, m }) };\n};\nconst OutTR = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1]))\n            return;\n        return { type: 'tr', pubkey: from[1] };\n    },\n    decode: (to) => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n    // Clone input in order to not corrupt it\n    const lst = Array.from(taprootList);\n    // We have at least 2 elements => can create branch\n    while (lst.length >= 2) {\n        // Sort: elements with smallest weight are in the end of queue\n        lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n        const b = lst.pop();\n        const a = lst.pop();\n        const weight = (a?.weight || 1) + (b?.weight || 1);\n        lst.push({\n            weight,\n            // Unwrap children array\n            // TODO: Very hard to remove any here\n            childs: [a?.childs || a, b?.childs || b],\n        });\n    }\n    // At this point there is always 1 element in lst\n    const last = lst[0];\n    return (last?.childs || last);\n}\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false) {\n    const out = OutScript.decode(script);\n    if (out.type === 'unknown' && allowUnknownOutputs)\n        return;\n    if (!['tr_ns', 'tr_ms'].includes(out.type))\n        throw new Error(`P2TR: invalid leaf script=${out.type}`);\n    const outms = out;\n    if (!allowUnknownOutputs && outms.pubkeys) {\n        for (const p of outms.pubkeys) {\n            if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY))\n                throw new Error('Unspendable taproot key in leaf script');\n            // It's likely a mistake at this point:\n            // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n            // but will take more space and fees.\n            // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n            // User creates 2 of 3 multisig of keys [A, B, C],\n            // but key A always can spend whole output without signatures from other keys.\n            // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n            if (P.equalBytes(p, internalPubKey)) {\n                throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n            }\n        }\n    }\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false) {\n    if (!tree)\n        throw new Error('taprootHashTree: empty tree');\n    if (Array.isArray(tree) && tree.length === 1)\n        tree = tree[0];\n    // Terminal node (leaf)\n    if (!Array.isArray(tree)) {\n        const { leafVersion: version, script: leafScript } = tree;\n        // Earliest tree walk where we can validate tapScripts\n        if (tree.tapLeafScript || (tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n            throw new Error('P2TR: tapRoot leafScript cannot have tree');\n        const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n        if (!isBytes(script))\n            throw new Error(`checkScript: wrong script type=${script}`);\n        checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n        return {\n            type: 'leaf',\n            version,\n            script,\n            hash: tapLeafHash(script, version),\n        };\n    }\n    // If tree / branch is not binary tree, convert it\n    if (tree.length !== 2)\n        tree = taprootListToTree(tree);\n    if (tree.length !== 2)\n        throw new Error('hashTree: non binary tree!');\n    // branch\n    // Both nodes should exist\n    const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n    const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n    // We cannot swap left/right here, since it will change structure of tree\n    let [lH, rH] = [left.hash, right.hash];\n    if (_cmpBytes(rH, lH) === -1)\n        [lH, rH] = [rH, lH];\n    return { type: 'branch', left, right, hash: schnorr.utils.taggedHash('TapBranch', lH, rH) };\n}\nfunction taprootAddPath(tree, path = []) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return { ...tree, path };\n    if (tree.type !== 'branch')\n        throw new Error(`taprootAddPath: wrong type=${tree}`);\n    return {\n        ...tree,\n        path,\n        // Left element has right hash in path and otherwise\n        left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n        right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n    };\n}\nfunction taprootWalkTree(tree) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return [tree];\n    if (tree.type !== 'branch')\n        throw new Error(`taprootWalkTree: wrong type=${tree}`);\n    return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree, network = NETWORK, allowUnknownOutputs = false) {\n    // Unspendable\n    if (!internalPubKey && !tree)\n        throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n    const pubKey = typeof internalPubKey === 'string'\n        ? hex.decode(internalPubKey)\n        : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n    if (!isValidPubkey(pubKey, PubT.schnorr))\n        throw new Error('p2tr: non-schnorr pubkey');\n    let hashedTree = tree\n        ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs))\n        : undefined;\n    const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n    const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n    let leaves;\n    if (hashedTree) {\n        leaves = taprootWalkTree(hashedTree).map((l) => ({\n            ...l,\n            controlBlock: TaprootControlBlock.encode({\n                version: (l.version || TAP_LEAF_VERSION) + parity,\n                internalKey: pubKey,\n                merklePath: l.path,\n            }),\n        }));\n    }\n    let tapLeafScript;\n    if (leaves) {\n        tapLeafScript = leaves.map((l) => [\n            TaprootControlBlock.decode(l.controlBlock),\n            concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n        ]);\n    }\n    const res = {\n        type: 'tr',\n        script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n        address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n        // For tests\n        tweakedPubkey,\n        // PSBT stuff\n        tapInternalKey: pubKey,\n    };\n    // Just in case someone would want to select a specific script\n    if (leaves)\n        res.leaves = leaves;\n    if (tapLeafScript)\n        res.tapLeafScript = tapLeafScript;\n    if (tapMerkleRoot)\n        res.tapMerkleRoot = tapMerkleRoot;\n    return res;\n}\nconst OutTRNS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        // On error return, since it can be different script\n        for (let i = 0; i < last; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== 'CHECKSIGVERIFY' || i === last - 1)\n                    return;\n                continue;\n            }\n            if (!isBytes(elm))\n                return;\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ns', pubkeys };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ns')\n            return;\n        const out = [];\n        for (let i = 0; i < to.pubkeys.length - 1; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n        out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n        return out;\n    },\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n    const res = [];\n    if (!Array.isArray(list))\n        throw new Error('combinations: lst arg should be array');\n    const n = list.length;\n    if (m > n)\n        throw new Error('combinations: m > lst.length, no combinations possible');\n    /*\n    Basically works as M nested loops like:\n    for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n    but since we cannot create nested loops dynamically, we unroll it to a single loop\n    */\n    const idx = Array.from({ length: m }, (_, i) => i);\n    const last = idx.length - 1;\n    main: for (;;) {\n        res.push(idx.map((i) => list[i]));\n        idx[last] += 1;\n        let i = last;\n        // Propagate increment\n        // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n        for (; i >= 0 && idx[i] > n - m + i; i--) {\n            idx[i] = 0;\n            // Overflow in idx[0], break\n            if (i === 0)\n                break main;\n            idx[i - 1] += 1;\n        }\n        // Propagate: idx[i+1] = idx[idx]+1\n        for (i += 1; i < idx.length; i++)\n            idx[i] = idx[i - 1] + 1;\n    }\n    return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return combinations(m, pubkeys).map((i) => ({\n        type: 'tr_ns',\n        script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n    }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = (pubkey) => p2tr_ns(1, [pubkey], undefined)[0];\nconst OutTRMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        const m = OpToNum(from[last - 1]);\n        if (typeof m !== 'number')\n            return;\n        for (let i = 0; i < last - 1; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n                    throw new Error('OutScript.encode/tr_ms: wrong element');\n                continue;\n            }\n            if (!isBytes(elm))\n                throw new Error('OutScript.encode/tr_ms: wrong key element');\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ms', pubkeys, m };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ms')\n            return;\n        const out = [to.pubkeys[0], 'CHECKSIG'];\n        for (let i = 1; i < to.pubkeys.length; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGADD');\n        out.push(to.m, 'NUMEQUAL');\n        return out;\n    },\n};\nexport function p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return {\n        type: 'tr_ms',\n        script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n    };\n}\nconst OutUnknown = {\n    encode(from) {\n        return { type: 'unknown', script: Script.encode(from) };\n    },\n    decode: (to) => to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\nconst OutScripts = [\n    OutPK,\n    OutPKH,\n    OutSH,\n    OutWSH,\n    OutWPKH,\n    OutMS,\n    OutTR,\n    OutTRNS,\n    OutTRMS,\n    OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, (i) => {\n    if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa))\n        throw new Error('OutScript/pk: wrong key');\n    if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n        (!isBytes(i.hash) || i.hash.length !== 20))\n        throw new Error(`OutScript/${i.type}: wrong hash`);\n    if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32))\n        throw new Error(`OutScript/wsh: wrong hash`);\n    if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr)))\n        throw new Error('OutScript/tr: wrong taproot public key');\n    if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n        if (!Array.isArray(i.pubkeys))\n            throw new Error('OutScript/multisig: wrong pubkeys array');\n    if (i.type === 'ms') {\n        const n = i.pubkeys.length;\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.ecdsa))\n                throw new Error('OutScript/multisig: wrong pubkey');\n        if (i.m <= 0 || n > 16 || i.m > n)\n            throw new Error('OutScript/multisig: invalid params');\n    }\n    if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.schnorr))\n                throw new Error(`OutScript/${i.type}: wrong pubkey`);\n    }\n    if (i.type === 'tr_ms') {\n        const n = i.pubkeys.length;\n        if (i.m <= 0 || n > 999 || i.m > n)\n            throw new Error('OutScript/tr_ms: invalid params');\n    }\n    return i;\n});\n// Address\nfunction validateWitness(version, data) {\n    if (data.length < 2 || data.length > 40)\n        throw new Error('Witness: invalid length');\n    if (version > 16)\n        throw new Error('Witness: invalid version');\n    if (version === 0 && !(data.length === 20 || data.length === 32))\n        throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data, network = NETWORK) {\n    validateWitness(version, data);\n    const coder = version === 0 ? bech32 : bech32m;\n    return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n    return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF(network = NETWORK) {\n    return {\n        encode(privKey) {\n            const compressed = concat(privKey, new Uint8Array([0x01]));\n            return formatKey(compressed.subarray(0, 33), [network.wif]);\n        },\n        decode(wif) {\n            let parsed = base58check.decode(wif);\n            if (parsed[0] !== network.wif)\n                throw new Error('Wrong WIF prefix');\n            parsed = parsed.subarray(1);\n            // Check what it is. Compressed flag?\n            if (parsed.length !== 33)\n                throw new Error('Wrong WIF length');\n            if (parsed[32] !== 0x01)\n                throw new Error('Wrong WIF postfix');\n            return parsed.subarray(0, -1);\n        },\n    };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n    return {\n        encode(from) {\n            const { type } = from;\n            if (type === 'wpkh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'wsh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'tr')\n                return programToWitness(1, from.pubkey, network);\n            else if (type === 'pkh')\n                return formatKey(from.hash, [network.pubKeyHash]);\n            else if (type === 'sh')\n                return formatKey(from.hash, [network.scriptHash]);\n            throw new Error(`Unknown address type=${type}`);\n        },\n        decode(address) {\n            if (address.length < 14 || address.length > 74)\n                throw new Error('Invalid address length');\n            // Bech32\n            if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n                let res;\n                try {\n                    res = bech32.decode(address);\n                    if (res.words[0] !== 0)\n                        throw new Error(`bech32: wrong version=${res.words[0]}`);\n                }\n                catch (_) {\n                    // Starting from version 1 it is decoded as bech32m\n                    res = bech32m.decode(address);\n                    if (res.words[0] === 0)\n                        throw new Error(`bech32m: wrong version=${res.words[0]}`);\n                }\n                if (res.prefix !== network.bech32)\n                    throw new Error(`wrong bech32 prefix=${res.prefix}`);\n                const [version, ...program] = res.words;\n                const data = bech32.fromWords(program);\n                validateWitness(version, data);\n                if (version === 0 && data.length === 32)\n                    return { type: 'wsh', hash: data };\n                else if (version === 0 && data.length === 20)\n                    return { type: 'wpkh', hash: data };\n                else if (version === 1 && data.length === 32)\n                    return { type: 'tr', pubkey: data };\n                else\n                    throw new Error('Unknown witness program');\n            }\n            const data = base58check.decode(address);\n            if (data.length !== 21)\n                throw new Error('Invalid base58 address');\n            // Pay To Public Key Hash\n            if (data[0] === network.pubKeyHash) {\n                return { type: 'pkh', hash: data.slice(1) };\n            }\n            else if (data[0] === network.scriptHash) {\n                return {\n                    type: 'sh',\n                    hash: data.slice(1),\n                };\n            }\n            throw new Error(`Invalid address prefix=${data[0]}`);\n        },\n    };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n    SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n    SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n    SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n    SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n    SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n    SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n    SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n    SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n    SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n    if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n        throw new Error(`Invalid SigHash=${s}`);\n    return s;\n}\nfunction unpackSighash(hashType) {\n    const masked = hashType & 0b0011111;\n    return {\n        isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n        isNone: masked === SignatureHash.NONE,\n        isSingle: masked === SignatureHash.SINGLE,\n    };\n}\nexport const _sortPubkeys = (pubkeys) => Array.from(pubkeys).sort(_cmpBytes);\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n    if (i.txid === undefined || i.index === undefined)\n        throw new Error('Transaction/input: txid and index required');\n    return {\n        txid: i.txid,\n        index: i.index,\n        sequence: def(i.sequence, DEFAULT_SEQUENCE),\n        finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n    };\n}\nfunction cleanFinalInput(i) {\n    for (const _k in i) {\n        const k = _k;\n        if (!PSBTInputFinalKeys.includes(k))\n            delete i[k];\n    }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n    if (i.script === undefined || i.amount === undefined)\n        throw new Error('Transaction/output: script and amount required');\n    return { script: i.script, amount: i.amount };\n}\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script, version = TAP_LEAF_VERSION) => schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n    if (P.equalBytes(internalKey, pubKey)) {\n        privKey = taprootTweakPrivKey(privKey, merkleRoot);\n        pubKey = schnorr.getPublicKey(privKey);\n    }\n    return { privKey, pubKey };\n}\nconst toStr = {}.toString;\nfunction validateOpts(opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error(`Wrong object type for transaction options: ${opts}`);\n    const _opts = {\n        ...opts,\n        // Defaults\n        version: def(opts.version, DEFAULT_VERSION),\n        lockTime: def(opts.lockTime, 0),\n        PSBTVersion: def(opts.PSBTVersion, 0),\n    };\n    if (typeof _opts.allowUnknowInput !== 'undefined')\n        opts.allowUnknownInputs = _opts.allowUnknowInput;\n    if (typeof _opts.allowUnknowOutput !== 'undefined')\n        opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n    // 0 and -1 happens in tests\n    if (![-1, 0, 1, 2].includes(_opts.version))\n        throw new Error(`Unknown version: ${_opts.version}`);\n    if (typeof _opts.lockTime !== 'number')\n        throw new Error('Transaction lock time should be number');\n    P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n    // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n    // can lead to constructing broken transactions\n    if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n        throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n    // Flags\n    for (const k of [\n        'allowUnknownOutputs',\n        'allowUnknownInputs',\n        'disableScriptCheck',\n        'bip174jsCompat',\n        'allowLegacyWitnessUtxo',\n        'lowR',\n    ]) {\n        const v = _opts[k];\n        if (v === undefined)\n            continue; // optional\n        if (typeof v !== 'boolean')\n            throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n    }\n    return Object.freeze(_opts);\n}\n// Normalizes input\nfunction getPrevOut(input) {\n    if (input.nonWitnessUtxo) {\n        if (input.index === undefined)\n            throw new Error('Unknown input index');\n        return input.nonWitnessUtxo.outputs[input.index];\n    }\n    else if (input.witnessUtxo)\n        return input.witnessUtxo;\n    else\n        throw new Error('Cannot find previous output info');\n}\nfunction normalizeInput(i, cur, allowedFields, disableScriptCheck = false) {\n    let { nonWitnessUtxo, txid } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors\n    // like hex looking string accidentally passed, however, in case of nonWitnessUtxo\n    // it is better to expect string, since constructing this complex object will be\n    // difficult for user\n    if (typeof nonWitnessUtxo === 'string')\n        nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n    if (isBytes(nonWitnessUtxo))\n        nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n    if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined)\n        nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string')\n        txid = hex.decode(txid);\n    // TODO: if we have nonWitnessUtxo, we can extract txId from here\n    if (txid === undefined)\n        txid = cur?.txid;\n    let res = { ...cur, ...i, nonWitnessUtxo, txid };\n    if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined)\n        delete res.nonWitnessUtxo;\n    if (res.sequence === undefined)\n        res.sequence = DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null)\n        delete res.tapMerkleRoot;\n    res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n    PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined)\n        prevOut = res.nonWitnessUtxo.outputs[res.index];\n    else if (res.witnessUtxo)\n        prevOut = res.witnessUtxo;\n    if (prevOut && !disableScriptCheck)\n        checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n    return res;\n}\nfunction getInputType(input, allowLegacyWitnessUtxo = false) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = getPrevOut(input);\n    const first = OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n        defaultSighash = SignatureHash.DEFAULT;\n        return {\n            txType: 'taproot',\n            type: 'tr',\n            last: first,\n            lastScript: prevOut.script,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n    }\n    else {\n        if (first.type === 'wpkh' || first.type === 'wsh')\n            txType = 'segwit';\n        if (first.type === 'sh') {\n            if (!input.redeemScript)\n                throw new Error('inputType: sh without redeemScript');\n            let child = OutScript.decode(input.redeemScript);\n            if (child.type === 'wpkh' || child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        // wsh can be inside sh\n        if (cur.type === 'wsh') {\n            if (!input.witnessScript)\n                throw new Error('inputType: wsh without witnessScript');\n            let child = OutScript.decode(input.witnessScript);\n            if (child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        const last = stack[stack.length - 1];\n        if (last.type === 'sh' || last.type === 'wsh')\n            throw new Error('inputType: sh/wsh cannot be terminal type');\n        const lastScript = OutScript.encode(last);\n        const res = {\n            type,\n            txType,\n            last,\n            lastScript,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n        if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n            throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n        }\n        return res;\n    }\n}\nconst toVsize = (weight) => Math.ceil(weight / 4);\nexport class Transaction {\n    constructor(opts = {}) {\n        this.global = {};\n        this.inputs = []; // use getInput()\n        this.outputs = []; // use getOutput()\n        const _opts = (this.opts = validateOpts(opts));\n        // Merge with global structure of PSBTv2\n        if (_opts.lockTime !== DEFAULT_LOCKTIME)\n            this.global.fallbackLocktime = _opts.lockTime;\n        this.global.txVersion = _opts.version;\n    }\n    // Import\n    static fromRaw(raw, opts = {}) {\n        const parsed = RawTx.decode(raw);\n        const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n        for (const o of parsed.outputs)\n            tx.addOutput(o);\n        tx.outputs = parsed.outputs;\n        tx.inputs = parsed.inputs;\n        if (parsed.witnesses) {\n            for (let i = 0; i < parsed.witnesses.length; i++)\n                tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n        }\n        return tx;\n    }\n    // PSBT\n    static fromPSBT(psbt, opts = {}) {\n        let parsed;\n        try {\n            parsed = RawPSBTV0.decode(psbt);\n        }\n        catch (e0) {\n            try {\n                parsed = RawPSBTV2.decode(psbt);\n            }\n            catch (e2) {\n                // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n                throw e0;\n            }\n        }\n        const PSBTVersion = parsed.global.version || 0;\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const unsigned = parsed.global.unsignedTx;\n        const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n        const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n        const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n        // We need slice here, because otherwise\n        const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n        tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n            finalScriptSig: P.EMPTY,\n            ...parsed.global.unsignedTx?.inputs[j],\n            ...i,\n        }));\n        const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n        tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n            ...i,\n            ...parsed.global.unsignedTx?.outputs[j],\n        }));\n        tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n        if (lockTime !== DEFAULT_LOCKTIME)\n            tx.global.fallbackLocktime = lockTime;\n        return tx;\n    }\n    toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const inputs = this.inputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n        for (const inp of inputs) {\n            // Don't serialize empty fields\n            if (inp.partialSig && !inp.partialSig.length)\n                delete inp.partialSig;\n            if (inp.finalScriptSig && !inp.finalScriptSig.length)\n                delete inp.finalScriptSig;\n            if (inp.finalScriptWitness && !inp.finalScriptWitness.length)\n                delete inp.finalScriptWitness;\n        }\n        const outputs = this.outputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n        const global = { ...this.global };\n        if (PSBTVersion === 0) {\n            global.unsignedTx = RawTx.decode(this.unsignedTx);\n            delete global.fallbackLocktime;\n            delete global.txVersion;\n        }\n        else {\n            global.version = PSBTVersion;\n            global.txVersion = this.version;\n            global.inputCount = this.inputs.length;\n            global.outputCount = this.outputs.length;\n            if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n                delete global.fallbackLocktime;\n        }\n        if (this.opts.bip174jsCompat) {\n            if (!inputs.length)\n                inputs.push({});\n            if (!outputs.length)\n                outputs.push({});\n        }\n        return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n            global,\n            inputs,\n            outputs,\n        });\n    }\n    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n    get lockTime() {\n        let height = DEFAULT_LOCKTIME;\n        let heightCnt = 0;\n        let time = DEFAULT_LOCKTIME;\n        let timeCnt = 0;\n        for (const i of this.inputs) {\n            if (i.requiredHeightLocktime) {\n                height = Math.max(height, i.requiredHeightLocktime);\n                heightCnt++;\n            }\n            if (i.requiredTimeLocktime) {\n                time = Math.max(time, i.requiredTimeLocktime);\n                timeCnt++;\n            }\n        }\n        if (heightCnt && heightCnt >= timeCnt)\n            return height;\n        if (time !== DEFAULT_LOCKTIME)\n            return time;\n        return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n    }\n    get version() {\n        // Should be not possible\n        if (this.global.txVersion === undefined)\n            throw new Error('No global.txVersion');\n        return this.global.txVersion;\n    }\n    inputStatus(idx) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        // Finalized\n        if (input.finalScriptSig && input.finalScriptSig.length)\n            return 'finalized';\n        if (input.finalScriptWitness && input.finalScriptWitness.length)\n            return 'finalized';\n        // Signed taproot\n        if (input.tapKeySig)\n            return 'signed';\n        if (input.tapScriptSig && input.tapScriptSig.length)\n            return 'signed';\n        // Signed\n        if (input.partialSig && input.partialSig.length)\n            return 'signed';\n        return 'unsigned';\n    }\n    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n    // We will lose some vectors -> smaller test coverage of preimages (very important!)\n    inputSighash(idx) {\n        this.checkInputIdx(idx);\n        const sighash = getInputType(this.inputs[idx], this.opts.allowLegacyWitnessUtxo).sighash;\n        // ALL or DEFAULT -- everything signed\n        // NONE           -- all inputs + no outputs\n        // SINGLE         -- all inputs + output with same index\n        // ALL + ANYONE   -- specific input + all outputs\n        // NONE + ANYONE  -- specific input + no outputs\n        // SINGLE         -- specific inputs + output with same index\n        const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n        const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n        return { sigInputs, sigOutputs };\n    }\n    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n    // Some cache will be nice, but there chance to have bugs with cache invalidation\n    signStatus() {\n        // if addInput or addOutput is not possible, then all inputs or outputs are signed\n        let addInput = true, addOutput = true;\n        let inputs = [], outputs = [];\n        for (let idx = 0; idx < this.inputs.length; idx++) {\n            const status = this.inputStatus(idx);\n            // Unsigned input doesn't affect anything\n            if (status === 'unsigned')\n                continue;\n            const { sigInputs, sigOutputs } = this.inputSighash(idx);\n            // Input type\n            if (sigInputs === SignatureHash.ANYONECANPAY)\n                inputs.push(idx);\n            else\n                addInput = false;\n            // Output type\n            if (sigOutputs === SignatureHash.ALL)\n                addOutput = false;\n            else if (sigOutputs === SignatureHash.SINGLE)\n                outputs.push(idx);\n            else if (sigOutputs === SignatureHash.NONE) {\n                // Doesn't affect any outputs at all\n            }\n            else\n                throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n        }\n        return { addInput, addOutput, inputs, outputs };\n    }\n    get isFinal() {\n        for (let idx = 0; idx < this.inputs.length; idx++)\n            if (this.inputStatus(idx) !== 'finalized')\n                return false;\n        return true;\n    }\n    // Info utils\n    get hasWitnesses() {\n        let out = false;\n        for (const i of this.inputs)\n            if (i.finalScriptWitness && i.finalScriptWitness.length)\n                out = true;\n        return out;\n    }\n    // https://en.bitcoin.it/wiki/Weight_units\n    get weight() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        let out = 32;\n        // Outputs\n        const outputs = this.outputs.map(outputBeforeSign);\n        out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n        for (const o of outputs)\n            out += 32 + 4 * VarBytes.encode(o.script).length;\n        // Inputs\n        if (this.hasWitnesses)\n            out += 2;\n        out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n        for (const i of this.inputs) {\n            out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n            if (this.hasWitnesses && i.finalScriptWitness)\n                out += RawWitness.encode(i.finalScriptWitness).length;\n        }\n        return out;\n    }\n    get vsize() {\n        return toVsize(this.weight);\n    }\n    toBytes(withScriptSig = false, withWitness = false) {\n        return RawTx.encode({\n            version: this.version,\n            lockTime: this.lockTime,\n            inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n                ...i,\n                finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n            })),\n            outputs: this.outputs.map(outputBeforeSign),\n            witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n            segwitFlag: withWitness && this.hasWitnesses,\n        });\n    }\n    get unsignedTx() {\n        return this.toBytes(false, false);\n    }\n    get hex() {\n        return hex.encode(this.toBytes(true, this.hasWitnesses));\n    }\n    get hash() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)));\n    }\n    get id() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)).reverse());\n    }\n    // Input stuff\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n    }\n    getInput(idx) {\n        this.checkInputIdx(idx);\n        return cloneDeep(this.inputs[idx]);\n    }\n    get inputsLength() {\n        return this.inputs.length;\n    }\n    // Modification\n    addInput(input, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addInput)\n            throw new Error('Tx has signed inputs, cannot add new one');\n        this.inputs.push(normalizeInput(input, undefined, undefined, this.opts.disableScriptCheck));\n        return this.inputs.length - 1;\n    }\n    updateInput(idx, input, _ignoreSignStatus = false) {\n        this.checkInputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addInput || status.inputs.includes(idx))\n                allowedFields = PSBTInputUnsignedKeys;\n        }\n        this.inputs[idx] = normalizeInput(input, this.inputs[idx], allowedFields, this.opts.disableScriptCheck);\n    }\n    // Output stuff\n    checkOutputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n            throw new Error(`Wrong output index=${idx}`);\n    }\n    getOutput(idx) {\n        this.checkOutputIdx(idx);\n        return cloneDeep(this.outputs[idx]);\n    }\n    get outputsLength() {\n        return this.outputs.length;\n    }\n    normalizeOutput(o, cur, allowedFields) {\n        let { amount, script } = o;\n        if (amount === undefined)\n            amount = cur?.amount;\n        if (typeof amount !== 'bigint')\n            throw new Error('amount must be bigint sats');\n        if (typeof script === 'string')\n            script = hex.decode(script);\n        if (script === undefined)\n            script = cur?.script;\n        let res = { ...cur, ...o, amount, script };\n        if (res.amount === undefined)\n            delete res.amount;\n        res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n        PSBTOutputCoder.encode(res);\n        if (res.script &&\n            !this.opts.allowUnknownOutputs &&\n            OutScript.decode(res.script).type === 'unknown') {\n            throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n        }\n        if (!this.opts.disableScriptCheck)\n            checkScript(res.script, res.redeemScript, res.witnessScript);\n        return res;\n    }\n    addOutput(o, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addOutput)\n            throw new Error('Tx has signed outputs, cannot add new one');\n        this.outputs.push(this.normalizeOutput(o));\n        return this.outputs.length - 1;\n    }\n    updateOutput(idx, output, _ignoreSignStatus = false) {\n        this.checkOutputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addOutput || status.outputs.includes(idx))\n                allowedFields = PSBTOutputUnsignedKeys;\n        }\n        this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n    }\n    addOutputAddress(address, amount, network = NETWORK) {\n        return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n    }\n    // Utils\n    get fee() {\n        let res = 0n;\n        for (const i of this.inputs) {\n            const prevOut = getPrevOut(i);\n            if (!prevOut)\n                throw new Error('Empty input amount');\n            res += prevOut.amount;\n        }\n        const outputs = this.outputs.map(outputBeforeSign);\n        for (const o of outputs)\n            res -= o.amount;\n        return res;\n    }\n    // Signing\n    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n    // but we are trying to be less complicated for audit purpose for now.\n    preimageLegacy(idx, prevOutScript, hashType) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        if (idx < 0 || !Number.isSafeInteger(idx))\n            throw new Error(`Invalid input idx=${idx}`);\n        if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n            return P.U256BE.encode(1n);\n        prevOutScript = Script.encode(Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR'));\n        let inputs = this.inputs\n            .map(inputBeforeSign)\n            .map((input, inputIdx) => ({\n            ...input,\n            finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n        }));\n        if (isAny)\n            inputs = [inputs[idx]];\n        else if (isNone || isSingle) {\n            inputs = inputs.map((input, inputIdx) => ({\n                ...input,\n                sequence: inputIdx === idx ? input.sequence : 0,\n            }));\n        }\n        let outputs = this.outputs.map(outputBeforeSign);\n        if (isNone)\n            outputs = [];\n        else if (isSingle) {\n            outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n        }\n        const tmpTx = RawTx.encode({\n            lockTime: this.lockTime,\n            version: this.version,\n            segwitFlag: false,\n            inputs,\n            outputs,\n        });\n        return sha256x2(tmpTx, P.I32LE.encode(hashType));\n    }\n    preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        let inputHash = EMPTY32;\n        let sequenceHash = EMPTY32;\n        let outputHash = EMPTY32;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (!isAny)\n            inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n        if (!isAny && !isSingle && !isNone)\n            sequenceHash = sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n        if (!isSingle && !isNone) {\n            outputHash = sha256x2(...outputs.map(RawOutput.encode));\n        }\n        else if (isSingle && idx < outputs.length)\n            outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n        const input = inputs[idx];\n        return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n    }\n    preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n        if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n            throw new Error(`Invalid amounts array=${amount}`);\n        if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n            throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n        const out = [\n            P.U8.encode(0),\n            P.U8.encode(hashType), // U8 sigHash\n            P.I32LE.encode(this.version),\n            P.U32LE.encode(this.lockTime),\n        ];\n        const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n        const inType = hashType & SignatureHash.ANYONECANPAY;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (inType !== SignatureHash.ANYONECANPAY) {\n            out.push(...[\n                inputs.map(TxHashIdx.encode),\n                amount.map(P.U64LE.encode),\n                prevOutScript.map(VarBytes.encode),\n                inputs.map((i) => P.U32LE.encode(i.sequence)),\n            ].map((i) => sha256(concat(...i))));\n        }\n        if (outType === SignatureHash.ALL) {\n            out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n        }\n        const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n        out.push(new Uint8Array([spendType]));\n        if (inType === SignatureHash.ANYONECANPAY) {\n            const inp = inputs[idx];\n            out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n        }\n        else\n            out.push(P.U32LE.encode(idx));\n        if (spendType & 1)\n            out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n        if (outType === SignatureHash.SINGLE)\n            out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n        if (leafScript)\n            out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n        return schnorr.utils.taggedHash('TapSighash', ...out);\n    }\n    // Signer can be privateKey OR instance of bip32 HD stuff\n    signIdx(privateKey, idx, allowedSighash, _auxRand) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Handle BIP32 HDKey\n        if (!isBytes(privateKey)) {\n            if (!input.bip32Derivation || !input.bip32Derivation.length)\n                throw new Error('bip32Derivation: empty');\n            const signers = input.bip32Derivation\n                .filter((i) => i[1].fingerprint == privateKey.fingerprint)\n                .map(([pubKey, { path }]) => {\n                let s = privateKey;\n                for (const i of path)\n                    s = s.deriveChild(i);\n                if (!P.equalBytes(s.publicKey, pubKey))\n                    throw new Error('bip32Derivation: wrong pubKey');\n                if (!s.privateKey)\n                    throw new Error('bip32Derivation: no privateKey');\n                return s;\n            });\n            if (!signers.length)\n                throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n            let signed = false;\n            for (const s of signers)\n                if (this.signIdx(s.privateKey, idx))\n                    signed = true;\n            return signed;\n        }\n        // Sighash checks\n        // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n        if (!allowedSighash)\n            allowedSighash = [inputType.defaultSighash];\n        else\n            allowedSighash.forEach(validateSigHash);\n        const sighash = inputType.sighash;\n        if (!allowedSighash.includes(sighash)) {\n            throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n        }\n        // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n        // however this was because of bug in bitcoin-core, which remains here because of consensus.\n        // If this is absolutely neccessary for your case, please open issue.\n        // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n        const { sigOutputs } = this.inputSighash(idx);\n        if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n            throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n        }\n        // Actual signing\n        // Taproot\n        const prevOut = getPrevOut(input);\n        if (inputType.txType === 'taproot') {\n            if (input.tapBip32Derivation)\n                throw new Error('tapBip32Derivation unsupported');\n            const prevOuts = this.inputs.map(getPrevOut);\n            const prevOutScript = prevOuts.map((i) => i.script);\n            const amount = prevOuts.map((i) => i.amount);\n            let signed = false;\n            let schnorrPub = schnorr.getPublicKey(privateKey);\n            let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n            if (input.tapInternalKey) {\n                // internal + tweak = tweaked key\n                // if internal key == current public key, we need to tweak private key,\n                // otherwise sign as is. bitcoinjs implementation always wants tweaked\n                // priv key to be provided\n                const { pubKey, privKey } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n                const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n                if (P.equalBytes(taprootPubKey, pubKey)) {\n                    const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n                    const sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapKeySig: sig }, true);\n                    signed = true;\n                }\n            }\n            if (input.tapLeafScript) {\n                input.tapScriptSig = input.tapScriptSig || [];\n                for (const [_, _script] of input.tapLeafScript) {\n                    const script = _script.subarray(0, -1);\n                    const scriptDecoded = Script.decode(script);\n                    const ver = _script[_script.length - 1];\n                    const hash = tapLeafHash(script, ver);\n                    // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n                    const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, schnorrPub));\n                    // Skip if there is no public key in tapLeafScript\n                    if (pos === -1)\n                        continue;\n                    const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n                    const sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] }, true);\n                    signed = true;\n                }\n            }\n            if (!signed)\n                throw new Error('No taproot scripts signed');\n            return true;\n        }\n        else {\n            // only compressed keys are supported for now\n            const pubKey = _pubECDSA(privateKey);\n            // TODO: replace with explicit checks\n            // Check if script has public key or its has inside\n            let hasPubkey = false;\n            const pubKeyHash = hash160(pubKey);\n            for (const i of Script.decode(inputType.lastScript)) {\n                if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash)))\n                    hasPubkey = true;\n            }\n            if (!hasPubkey)\n                throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n            let hash;\n            if (inputType.txType === 'legacy') {\n                hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n            }\n            else if (inputType.txType === 'segwit') {\n                let script = inputType.lastScript;\n                // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n                if (inputType.last.type === 'wpkh')\n                    script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n                hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n            }\n            else\n                throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n            const sig = signECDSA(hash, privateKey, this.opts.lowR);\n            this.updateInput(idx, {\n                partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]],\n            }, true);\n        }\n        return true;\n    }\n    // This is bad API. Will work if user creates and signs tx, but if\n    // there is some complex workflow with exchanging PSBT and signing them,\n    // then it is better to validate which output user signs. How could a better API look like?\n    // Example: user adds input, sends to another party, then signs received input (mixer etc),\n    // another user can add different input for same key and user will sign it.\n    // Even worse: another user can add bip32 derivation, and spend money from different address.\n    // Better api: signIdx\n    sign(privateKey, allowedSighash, _auxRand) {\n        let num = 0;\n        for (let i = 0; i < this.inputs.length; i++) {\n            try {\n                if (this.signIdx(privateKey, i, allowedSighash, _auxRand))\n                    num++;\n            }\n            catch (e) { }\n        }\n        if (!num)\n            throw new Error('No inputs signed');\n        return num;\n    }\n    finalizeIdx(idx) {\n        this.checkInputIdx(idx);\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Taproot finalize\n        if (inputType.txType === 'taproot') {\n            if (input.tapKeySig)\n                input.finalScriptWitness = [input.tapKeySig];\n            else if (input.tapLeafScript && input.tapScriptSig) {\n                // Sort leafs by control block length.\n                const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n                for (const [cb, _script] of leafs) {\n                    // Last byte is version\n                    const script = _script.slice(0, -1);\n                    const ver = _script[_script.length - 1];\n                    const outScript = OutScript.decode(script);\n                    const hash = tapLeafHash(script, ver);\n                    const scriptSig = input.tapScriptSig.filter((i) => P.equalBytes(i[0].leafHash, hash));\n                    let signatures = [];\n                    if (outScript.type === 'tr_ms') {\n                        const m = outScript.m;\n                        const pubkeys = outScript.pubkeys;\n                        let added = 0;\n                        for (const pub of pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            // Should have exact amount of signatures (more -- will fail)\n                            if (added === m || sigIdx === -1) {\n                                signatures.push(P.EMPTY);\n                                continue;\n                            }\n                            signatures.push(scriptSig[sigIdx][1]);\n                            added++;\n                        }\n                        // Should be exact same as m\n                        if (added !== m)\n                            continue;\n                    }\n                    else if (outScript.type === 'tr_ns') {\n                        for (const pub of outScript.pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            if (sigIdx === -1)\n                                continue;\n                            signatures.push(scriptSig[sigIdx][1]);\n                        }\n                        if (signatures.length !== outScript.pubkeys.length)\n                            continue;\n                    }\n                    else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n                        // Trying our best to sign what we can\n                        const scriptDecoded = Script.decode(script);\n                        signatures = scriptSig\n                            .map(([{ pubKey }, signature]) => {\n                            const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, pubKey));\n                            if (pos === -1)\n                                throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                            return { signature, pos };\n                        })\n                            // Reverse order (because witness is stack and we take last element first from it)\n                            .sort((a, b) => a.pos - b.pos)\n                            .map((i) => i.signature);\n                        if (!signatures.length)\n                            continue;\n                    }\n                    else\n                        throw new Error('Finalize: Unknown tapLeafScript');\n                    // Witness is stack, so last element will be used first\n                    input.finalScriptWitness = signatures\n                        .reverse()\n                        .concat([script, TaprootControlBlock.encode(cb)]);\n                    break;\n                }\n                if (!input.finalScriptWitness)\n                    throw new Error('finalize/taproot: empty witness');\n            }\n            else\n                throw new Error('finalize/taproot: unknown input');\n            input.finalScriptSig = P.EMPTY;\n            cleanFinalInput(input);\n            return;\n        }\n        if (!input.partialSig || !input.partialSig.length)\n            throw new Error('Not enough partial sign');\n        let inputScript = P.EMPTY;\n        let witness = [];\n        // TODO: move input scripts closer to payments/output scripts\n        // Multisig\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const pubkeys = inputType.last.pubkeys;\n            let signatures = [];\n            // partial: [pubkey, sign]\n            for (const pub of pubkeys) {\n                const sign = input.partialSig.find((s) => P.equalBytes(pub, s[0]));\n                if (!sign)\n                    continue;\n                signatures.push(sign[1]);\n            }\n            signatures = signatures.slice(0, m);\n            if (signatures.length !== m) {\n                throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n            }\n            inputScript = Script.encode([0, ...signatures]);\n        }\n        else if (inputType.last.type === 'pk') {\n            inputScript = Script.encode([input.partialSig[0][1]]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            witness = [input.partialSig[0][1], input.partialSig[0][0]];\n        }\n        else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        // Create final scripts (generic part)\n        let finalScriptSig, finalScriptWitness;\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                witness = Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if (isBytes(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            witness = witness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            finalScriptWitness = witness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            finalScriptSig = inputScript;\n        if (!finalScriptSig && !finalScriptWitness)\n            throw new Error('Unknown error finalizing input');\n        if (finalScriptSig)\n            input.finalScriptSig = finalScriptSig;\n        if (finalScriptWitness)\n            input.finalScriptWitness = finalScriptWitness;\n        cleanFinalInput(input);\n    }\n    finalize() {\n        for (let i = 0; i < this.inputs.length; i++)\n            this.finalizeIdx(i);\n    }\n    extract() {\n        if (!this.isFinal)\n            throw new Error('Transaction has unfinalized inputs');\n        if (!this.outputs.length)\n            throw new Error('Transaction has no outputs');\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        return this.toBytes(true, true);\n    }\n    combine(other) {\n        for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n            if (this.opts[k] !== other.opts[k]) {\n                throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n            }\n        }\n        for (const k of ['inputs', 'outputs']) {\n            if (this[k].length !== other[k].length) {\n                throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n            }\n        }\n        const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n        const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n        if (!P.equalBytes(thisUnsigned, otherUnsigned))\n            throw new Error(`Transaction/combine: different unsigned tx`);\n        this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n        for (let i = 0; i < this.inputs.length; i++)\n            this.updateInput(i, other.inputs[i], true);\n        for (let i = 0; i < this.outputs.length; i++)\n            this.updateOutput(i, other.outputs[i], true);\n        return this;\n    }\n    clone() {\n        // deepClone probably faster, but this enforces that encoding is valid\n        return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);\n    }\n}\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey, network = NETWORK) {\n    if (type === 'tr') {\n        return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n    }\n    const pubKey = _pubECDSA(privKey);\n    if (type === 'pkh')\n        return p2pkh(pubKey, network).address;\n    if (type === 'wpkh')\n        return p2wpkh(pubKey, network).address;\n    throw new Error(`getAddress: unknown type=${type}`);\n}\nexport function multisig(m, pubkeys, sorted = false, witness = false) {\n    const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n    return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys, witness = false) {\n    return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n    const out = [];\n    if (!/^[mM]'?/.test(path))\n        throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(path))\n        return out;\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    for (const c of parts) {\n        const m = /^(\\d+)('?)$/.exec(c);\n        if (!m || m.length !== 3)\n            throw new Error(`Invalid child index: ${c}`);\n        let idx = +m[1];\n        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET)\n            throw new Error('Invalid index');\n        // hardened key\n        if (m[2] === \"'\")\n            idx += HARDENED_OFFSET;\n        out.push(idx);\n    }\n    return out;\n}\nexport function PSBTCombine(psbts) {\n    if (!psbts || !Array.isArray(psbts) || !psbts.length)\n        throw new Error('PSBTCombine: wrong PSBT list');\n    const tx = Transaction.fromPSBT(psbts[0]);\n    for (let i = 1; i < psbts.length; i++)\n        tx.combine(Transaction.fromPSBT(psbts[i]));\n    return tx.toPSBT();\n}\nfunction estimateInput(inputType, input, opts) {\n    let script = P.EMPTY, witness;\n    // schnorr sig is always 64 bytes. except for cases when sighash is not default!\n    if (inputType.txType === 'taproot') {\n        const SCHNORR_SIG_SIZE = inputType.sighash !== SignatureHash.DEFAULT ? 65 : 64;\n        if (input.tapInternalKey && !P.equalBytes(input.tapInternalKey, TAPROOT_UNSPENDABLE_KEY)) {\n            witness = [new Uint8Array(SCHNORR_SIG_SIZE)];\n        }\n        else if (input.tapLeafScript) {\n            // If user want to select specific leaf (which can signed, it is possible to remove all other leafs manually);\n            // Sort leafs by control block length.\n            const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n            for (const [cb, _script] of leafs) {\n                // Last byte is version\n                const script = _script.slice(0, -1);\n                const outScript = OutScript.decode(script);\n                let signatures = [];\n                if (outScript.type === 'tr_ms') {\n                    const m = outScript.m;\n                    for (let i = 0; i < m; i++)\n                        signatures.push(new Uint8Array(SCHNORR_SIG_SIZE));\n                    const n = outScript.pubkeys.length - m;\n                    for (let i = 0; i < n; i++)\n                        signatures.push(P.EMPTY);\n                }\n                else if (outScript.type === 'tr_ns') {\n                    for (const _pub of outScript.pubkeys)\n                        signatures.push(new Uint8Array(SCHNORR_SIG_SIZE));\n                }\n                else\n                    throw new Error('Finalize: Unknown tapLeafScript');\n                // Witness is stack, so last element will be used first\n                witness = signatures.reverse().concat([script, TaprootControlBlock.encode(cb)]);\n                break;\n            }\n        }\n        else\n            throw new Error('estimateInput/taproot: unknown input');\n    }\n    else {\n        // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),\n        // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).\n        const SIG_SIZE = 72; // Maximum size of signatures\n        const PUB_KEY_SIZE = 33;\n        let inputScript = P.EMPTY;\n        let inputWitness = [];\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const sig = [0];\n            for (let i = 0; i < m; i++)\n                sig.push(new Uint8Array(SIG_SIZE));\n            inputScript = Script.encode(sig);\n        }\n        else if (inputType.last.type === 'pk') {\n            // 71 sig + 1 sighash\n            inputScript = Script.encode([new Uint8Array(SIG_SIZE)]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = Script.encode([new Uint8Array(SIG_SIZE), new Uint8Array(PUB_KEY_SIZE)]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            inputWitness = [new Uint8Array(SIG_SIZE), new Uint8Array(PUB_KEY_SIZE)];\n        }\n        else if (inputType.last.type === 'unknown' && !opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                inputWitness = Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if (isBytes(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            inputWitness = inputWitness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            witness = inputWitness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            script = Script.encode([Script.encode([0, new Uint8Array(sha256.outputLen)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            script = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            script = inputScript;\n    }\n    let weight = 160 + 4 * VarBytes.encode(script).length;\n    let hasWitnesses = false;\n    if (witness) {\n        weight += RawWitness.encode(witness).length;\n        hasWitnesses = true;\n    }\n    return { weight, hasWitnesses };\n}\n// Exported for tests, internal method\nexport const _cmpBig = (a, b) => {\n    const n = a - b;\n    if (n < 0n)\n        return -1;\n    else if (n > 0n)\n        return 1;\n    return 0;\n};\nfunction getScript(o, opts = {}, network = NETWORK) {\n    let script;\n    if ('script' in o && o.script instanceof Uint8Array) {\n        script = o.script;\n    }\n    if ('address' in o) {\n        if (typeof o.address !== 'string')\n            throw new Error(`Estimator: wrong output address=${o.address}`);\n        script = OutScript.encode(Address(network).decode(o.address));\n    }\n    if (!script)\n        throw new Error('Estimator: wrong output script');\n    if (typeof o.amount !== 'bigint')\n        throw new Error(`Estimator: wrong output amount=${o.amount}`);\n    if (script && !opts.allowUnknownOutputs && OutScript.decode(script).type === 'unknown') {\n        throw new Error('Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n    }\n    if (!opts.disableScriptCheck)\n        checkScript(script);\n    return script;\n}\n// class, because we need to re-use normalized inputs, instead of parsing each time\n// internal stuff, exported for tests only\nexport class _Estimator {\n    constructor(inputs, outputs, opts) {\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.opts = opts;\n        // https://github.com/bitcoin/bitcoin/blob/f90603ac6d24f5263649675d51233f1fce8b2ecd/src/policy/policy.cpp#L44\n        // 32 + 4 + 1 + 107 + 4\n        // Dust used in accumExact + change address algo\n        // - change address: can be smaller for segwit\n        // - accumExact: ???\n        this.dust = 148n; // compat with coinselect\n        if (typeof opts.feePerByte !== 'bigint')\n            throw new Error(`Estimator: wrong feePerByte=${opts.feePerByte}`);\n        if (opts.dust) {\n            if (typeof opts.dust !== 'bigint')\n                throw new Error(`Estimator: wrong dust=${opts.dust}`);\n            this.dust = opts.dust;\n        }\n        const network = opts.network || NETWORK;\n        let amount = 0n;\n        // Base weight: tx with outputs, no inputs\n        let baseWeight = 32;\n        for (const o of outputs) {\n            const script = getScript(o, opts, opts.network);\n            baseWeight += 32 + 4 * VarBytes.encode(script).length;\n            amount += o.amount;\n        }\n        if (typeof opts.changeAddress !== 'string')\n            throw new Error(`Estimator: wrong change address=${opts.changeAddress}`);\n        let changeWeight = baseWeight +\n            32 +\n            4 * VarBytes.encode(OutScript.encode(Address(network).decode(opts.changeAddress))).length;\n        baseWeight += 4 * CompactSizeLen.encode(outputs.length).length;\n        // If there a lot of outputs change can change fee\n        changeWeight += 4 * CompactSizeLen.encode(outputs.length + 1).length;\n        this.baseWeight = baseWeight;\n        this.changeWeight = changeWeight;\n        this.amount = amount;\n        this.normalizedInputs = this.inputs.map((i) => {\n            const normalized = normalizeInput(i, undefined, undefined, opts.disableScriptCheck);\n            inputBeforeSign(normalized); // check fields\n            const inputType = getInputType(normalized, opts.allowLegacyWitnessUtxo);\n            const prev = getPrevOut(normalized);\n            const estimate = estimateInput(inputType, normalized, this.opts);\n            const value = prev.amount - opts.feePerByte * BigInt(toVsize(estimate.weight)); // value = amount-fee\n            return { inputType, normalized, amount: prev.amount, value, estimate };\n        });\n    }\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n        return idx;\n    }\n    sortIndices(indices) {\n        return indices.slice().sort((a, b) => {\n            const ai = this.normalizedInputs[this.checkInputIdx(a)];\n            const bi = this.normalizedInputs[this.checkInputIdx(b)];\n            const out = _cmpBytes(ai.normalized.txid, bi.normalized.txid);\n            if (out !== 0)\n                return out;\n            return ai.normalized.index - bi.normalized.index;\n        });\n    }\n    sortOutputs(outputs) {\n        const scripts = outputs.map((o) => getScript(o, this.opts, this.opts.network));\n        const indices = outputs.map((_, j) => j);\n        return indices.sort((a, b) => {\n            const aa = outputs[a].amount;\n            const ba = outputs[b].amount;\n            const out = _cmpBig(aa, ba);\n            if (out !== 0)\n                return out;\n            return _cmpBytes(scripts[a], scripts[b]);\n        });\n    }\n    getSatoshi(weigth) {\n        return this.opts.feePerByte * BigInt(toVsize(weigth));\n    }\n    // Sort by value instead of amount\n    get biggest() {\n        return this.inputs\n            .map((_i, j) => j)\n            .sort((a, b) => _cmpBig(this.normalizedInputs[b].value, this.normalizedInputs[a].value));\n    }\n    get smallest() {\n        return this.biggest.reverse();\n    }\n    // These assume that UTXO array has historical order.\n    // Otherwise, we have no way to know which tx is oldest\n    // Explorers usually give UTXO in this order.\n    get oldest() {\n        return this.inputs.map((_i, j) => j);\n    }\n    get newest() {\n        return this.oldest.reverse();\n    }\n    // exact - like blackjack from coinselect.\n    // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.\n    // If not, it will accumulate largest utxo until value is close to targetValue+dust.\n    accumulate(indices, exact = false, skipNegative = true, all = false) {\n        const { feePerByte } = this.opts;\n        // TODO: how to handle change addresses?\n        // - cost of input\n        // - cost of change output (if input requires change)\n        // - cost of output spending\n        // Dust threshold should be significantly bigger, no point in\n        // creating an output, which cannot be spent.\n        // coinselect doesn't consider cost of output address for dust.\n        // Changing that can actually reduce privacy\n        let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;\n        let hasWitnesses = false;\n        let num = 0;\n        let inputsAmount = 0n;\n        const targetAmount = this.amount;\n        const res = [];\n        let fee;\n        for (const idx of indices) {\n            this.checkInputIdx(idx);\n            const { estimate, amount, value } = this.normalizedInputs[idx];\n            let newWeight = weight + estimate.weight;\n            if (!hasWitnesses && estimate.hasWitnesses)\n                newWeight += 2; // enable witness if needed\n            const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n            fee = this.getSatoshi(totalWeight);\n            // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold\n            if (exact) {\n                const dust = this.dust * feePerByte;\n                // skip if added value is bigger than dust\n                if (amount + inputsAmount > targetAmount + fee + dust)\n                    continue;\n            }\n            // Negative: cost of using input is more than value provided (negative)\n            // By default 'blackjack' mode in coinselect doesn't use that, which means\n            // it will use negative output if sorted by 'smallest'\n            if (skipNegative && value <= 0n)\n                continue;\n            weight = newWeight;\n            if (estimate.hasWitnesses)\n                hasWitnesses = true;\n            num++;\n            inputsAmount += amount;\n            res.push(idx);\n            // inputsAmount is enough to cover cost of tx\n            if (!all && targetAmount + fee < inputsAmount)\n                return { indices: res, fee, weight: totalWeight, total: inputsAmount };\n        }\n        if (all) {\n            const newWeight = weight + 4 * CompactSizeLen.encode(num).length;\n            return { indices: res, fee, weight: newWeight, total: inputsAmount };\n        }\n        return undefined;\n    }\n    // Works like coinselect default method\n    default() {\n        const { biggest } = this;\n        const exact = this.accumulate(biggest, true, false);\n        if (exact)\n            return exact;\n        return this.accumulate(biggest);\n    }\n    select(strategy) {\n        if (strategy === 'all') {\n            return this.accumulate(this.inputs.map((_, j) => j), false, true, true);\n        }\n        if (strategy === 'default')\n            return this.default();\n        const data = {\n            Oldest: () => this.oldest,\n            Newest: () => this.newest,\n            Smallest: () => this.smallest,\n            Biggest: () => this.biggest,\n        };\n        if (strategy.startsWith('exact')) {\n            const [exactData, left] = strategy.slice(5).split('/');\n            if (!data[exactData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            strategy = left;\n            const exact = this.accumulate(data[exactData](), true, true);\n            if (exact)\n                return exact;\n        }\n        if (strategy.startsWith('accum')) {\n            const accumData = strategy.slice(5);\n            if (!data[accumData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            return this.accumulate(data[accumData]());\n        }\n        throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n    }\n    result(strategy) {\n        const s = this.select(strategy);\n        if (!s)\n            return;\n        const { indices, weight, total } = s;\n        let needChange = this.opts.alwaysChange;\n        const changeWeight = this.opts.alwaysChange\n            ? weight\n            : weight + (this.changeWeight - this.baseWeight);\n        const changeFee = this.getSatoshi(changeWeight);\n        let fee = s.fee;\n        const change = total - this.amount - changeFee;\n        if (change > this.dust)\n            needChange = true;\n        let inputs = indices;\n        let outputs = Array.from(this.outputs);\n        if (needChange) {\n            fee = changeFee;\n            // this shouldn't happen!\n            if (change < 0n)\n                throw new Error(`Estimator.result: negative change=${change}`);\n            outputs.push({ address: this.opts.changeAddress, amount: change });\n        }\n        if (this.opts.bip69) {\n            inputs = this.sortIndices(inputs);\n            outputs = this.sortOutputs(outputs).map((i) => outputs[i]);\n        }\n        const res = {\n            inputs: inputs.map((i) => this.inputs[i]),\n            outputs,\n            fee,\n            weight: this.opts.alwaysChange ? s.weight : changeWeight,\n            change: !!needChange,\n        };\n        let tx;\n        if (this.opts.createTx) {\n            const { inputs, outputs } = res;\n            tx = new Transaction(this.opts);\n            for (const i of inputs)\n                tx.addInput(i);\n            for (const o of outputs)\n                tx.addOutput({ ...o, script: getScript(o, this.opts, this.opts.network) });\n        }\n        return { ...res, tx };\n    }\n}\nexport function selectUTXO(inputs, outputs, strategy, opts) {\n    // Defaults: do we want bip69 by default?\n    const _opts = { createTx: true, bip69: true, ...opts };\n    const est = new _Estimator(inputs, outputs, _opts);\n    return est.result(strategy);\n}\n","import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\nexport default {\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport cookies from './../helpers/cookies.js';\nimport buildURL from './../helpers/buildURL.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport isURLSameOrigin from './../helpers/isURLSameOrigin.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport speedometer from '../helpers/speedometer.js';\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n\n    listener(data);\n  };\n}\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = AxiosHeaders.from(config.headers).normalize();\n    let {responseType, withXSRFToken} = config;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let contentType;\n\n    if (utils.isFormData(requestData)) {\n      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n        requestHeaders.setContentType(false); // Let the browser set it\n      } else if ((contentType = requestHeaders.getContentType()) !== false) {\n        // fix semicolon duplication issue for ReactNative FormData implementation\n        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n    }\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if(platform.hasStandardBrowserEnv) {\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n\n      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {\n        // Add xsrf header\n        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n\n        if (xsrfValue) {\n          requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n        }\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n","'use strict';\n\nimport utils from './utils.js';\nimport bind from './helpers/bind.js';\nimport Axios from './core/Axios.js';\nimport mergeConfig from './core/mergeConfig.js';\nimport defaults from './defaults/index.js';\nimport formDataToJSON from './helpers/formDataToJSON.js';\nimport CanceledError from './cancel/CanceledError.js';\nimport CancelToken from './cancel/CancelToken.js';\nimport isCancel from './cancel/isCancel.js';\nimport {VERSION} from './env/data.js';\nimport toFormData from './helpers/toFormData.js';\nimport AxiosError from './core/AxiosError.js';\nimport spread from './helpers/spread.js';\nimport isAxiosError from './helpers/isAxiosError.js';\nimport AxiosHeaders from \"./core/AxiosHeaders.js\";\nimport adapters from './adapters/adapters.js';\nimport HttpStatusCode from './helpers/HttpStatusCode.js';\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders;\n\naxios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n","'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport utils from '../utils.js';\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nexport default CanceledError;\n","'use strict';\n\nexport default function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport buildURL from '../helpers/buildURL.js';\nimport InterceptorManager from './InterceptorManager.js';\nimport dispatchRequest from './dispatchRequest.js';\nimport mergeConfig from './mergeConfig.js';\nimport buildFullPath from './buildFullPath.js';\nimport validator from '../helpers/validator.js';\nimport AxiosHeaders from './AxiosHeaders.js';\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      const dummy = {}\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(dummy)\n      } else {\n        dummy.stack = new Error().stack;\n      }\n      // slice off the Error: ... line\n      dummy.stack = dummy.stack.replace(/^.+\\n/, '');\n      // match without the 2 top stack lines\n      if (!err.stack.endsWith(dummy.stack.replace(/^.+\\n.+\\n/, ''))) {\n        err.stack += '\\n' + dummy.stack\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nexport default Axios;\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nexport default AxiosError;\n","'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n","'use strict';\n\nimport utils from './../utils.js';\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n","'use strict';\n\nimport isAbsoluteURL from '../helpers/isAbsoluteURL.js';\nimport combineURLs from '../helpers/combineURLs.js';\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nexport default function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n","'use strict';\n\nimport transformData from './transformData.js';\nimport isCancel from '../cancel/isCancel.js';\nimport defaults from '../defaults/index.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport adapters from \"../adapters/adapters.js\";\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nexport default function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? thing.toJSON() : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n","'use strict';\n\nimport AxiosError from './AxiosError.js';\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nexport default function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport defaults from '../defaults/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nexport default function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport transitionalDefaults from './transitional.js';\nimport toFormData from '../helpers/toFormData.js';\nimport toURLEncodedForm from '../helpers/toURLEncodedForm.js';\nimport platform from '../platform/index.js';\nimport formDataToJSON from '../helpers/formDataToJSON.js';\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nexport default defaults;\n","'use strict';\n\nexport default {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","export const VERSION = \"1.6.6\";","'use strict';\n\nimport toFormData from './toFormData.js';\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nexport default AxiosURLSearchParams;\n","const HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nexport default HttpStatusCode;\n","'use strict';\n\nexport default function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosURLSearchParams from '../helpers/AxiosURLSearchParams.js';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nexport default function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nexport default function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n","import utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push('path=' + path);\n\n      utils.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nexport default formDataToJSON;\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nexport default function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nexport default function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    const msie = /(msie|trident)/i.test(navigator.userAgent);\n    const urlParsingNode = document.createElement('a');\n    let originURL;\n\n    /**\n    * Parse a URL to discover its components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      let href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n          urlParsingNode.pathname :\n          '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n          parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })();\n","// eslint-disable-next-line strict\nexport default null;\n","'use strict';\n\nimport utils from './../utils.js';\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexport default rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nexport default function parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n","'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nexport default function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\nimport PlatformFormData from '../platform/node/classes/FormData.js';\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (PlatformFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nexport default toFormData;\n","'use strict';\n\nimport utils from '../utils.js';\nimport toFormData from './toFormData.js';\nimport platform from '../platform/index.js';\n\nexport default function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n","'use strict';\n\nimport {VERSION} from '../env/data.js';\nimport AxiosError from '../core/AxiosError.js';\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nexport default {\n  assertOptions,\n  validators\n};\n","'use strict'\n\nexport default typeof Blob !== 'undefined' ? Blob : null\n","'use strict';\n\nexport default typeof FormData !== 'undefined' ? FormData : null;\n","'use strict';\n\nimport AxiosURLSearchParams from '../../../helpers/AxiosURLSearchParams.js';\nexport default typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n","import URLSearchParams from './classes/URLSearchParams.js'\nimport FormData from './classes/FormData.js'\nimport Blob from './classes/Blob.js'\n\nexport default {\n  isBrowser: true,\n  classes: {\n    URLSearchParams,\n    FormData,\n    Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n","const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = (\n  (product) => {\n    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0\n  })(typeof navigator !== 'undefined' && navigator.product);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nexport {\n  hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv\n}\n","import platform from './node/index.js';\nimport * as utils from './common/utils.js';\n\nexport default {\n  ...utils,\n  ...platform\n}\n","'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n}\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0]\n  }\n\n  return str;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n};\n","import { base64, bytes as baseBytes, hex as baseHex, str as baseStr, utf8 } from '@scure/base';\n/**\n * TODO:\n * - Holes, simplify pointers. Hole is some sized element which is skipped at encoding,\n *   but later other elements can write to it by path\n * - Composite / tuple keys for dict\n * - Web UI for easier debugging. We can wrap every coder to something that would write\n *   start & end positions to; and we can colorize specific bytes used by specific coder\n */\n// Useful default values\nexport const EMPTY = /* @__PURE__ */ new Uint8Array(); // Empty bytes array\nexport const NULL = /* @__PURE__ */ new Uint8Array([0]); // NULL\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\nexport function concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport const isBytes = (b) => b instanceof Uint8Array;\n// Utils\n// Small bitset structure to store position of ranges that have been read.\n// Possible can be even more efficient by using some interval trees, but would be more complex\n// Needs O(N/8) memory for parsing.\n// Purpose: if there are pointers in parsed structure,\n// they can cause read of two distinct ranges:\n// [0-32, 64-128], which means 'pos' is not enough to handle them\nconst _bitset = /* @__PURE__ */ {\n    BITS: 32,\n    FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n    len: (len) => Math.ceil(len / 32),\n    create: (len) => new Uint32Array(_bitset.len(len)),\n    clean: (bs) => bs.fill(0),\n    debug: (bs) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n    checkLen: (bs, len) => {\n        if (_bitset.len(len) === bs.length)\n            return;\n        throw new Error(`bitSet: wrong length=${bs.length}. Expected: ${_bitset.len(len)}`);\n    },\n    chunkLen: (bsLen, pos, len) => {\n        if (pos < 0)\n            throw new Error(`bitset: wrong pos=${pos}`);\n        if (pos + len > bsLen)\n            throw new Error(`bitSet: wrong range=${pos}/${len} of ${bsLen}`);\n    },\n    set: (bs, chunk, value, allowRewrite = true) => {\n        if (!allowRewrite && (bs[chunk] & value) !== 0)\n            return false;\n        bs[chunk] |= value;\n        return true;\n    },\n    pos: (pos, i) => ({\n        chunk: Math.floor((pos + i) / 32),\n        mask: 1 << (32 - ((pos + i) % 32) - 1),\n    }),\n    indices: (bs, len, invert = false) => {\n        _bitset.checkLen(bs, len);\n        const { FULL_MASK, BITS } = _bitset;\n        const left = BITS - (len % BITS);\n        const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n        const res = [];\n        for (let i = 0; i < bs.length; i++) {\n            let c = bs[i];\n            if (invert)\n                c = ~c; // allows to gen unset elements\n            // apply mask to last element, so we won't iterate non-existent items\n            if (i === bs.length - 1)\n                c &= lastMask;\n            if (c === 0)\n                continue; // fast-path\n            for (let j = 0; j < BITS; j++) {\n                const m = 1 << (BITS - j - 1);\n                if (c & m)\n                    res.push(i * BITS + j);\n            }\n        }\n        return res;\n    },\n    range: (arr) => {\n        const res = [];\n        let cur;\n        for (const i of arr) {\n            if (cur === undefined || i !== cur.pos + cur.length)\n                res.push((cur = { pos: i, length: 1 }));\n            else\n                cur.length += 1;\n        }\n        return res;\n    },\n    rangeDebug: (bs, len, invert = false) => `[${_bitset\n        .range(_bitset.indices(bs, len, invert))\n        .map((i) => `(${i.pos}/${i.length})`)\n        .join(', ')}]`,\n    setRange: (bs, bsLen, pos, len, allowRewrite = true) => {\n        _bitset.chunkLen(bsLen, pos, len);\n        const { FULL_MASK, BITS } = _bitset;\n        // Try to set range with maximum efficiency:\n        // - first chunk is always    '0000[1111]' (only right ones)\n        // - middle chunks are set to '[1111 1111]' (all ones)\n        // - last chunk is always     '[1111]0000' (only left ones)\n        // - max operations:          (N/32) + 2 (first and last)\n        const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n        const lastPos = pos + len;\n        const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n        // special case, whole range inside single chunk\n        if (first !== undefined && first === last)\n            return _bitset.set(bs, first, (FULL_MASK >>> (BITS - len)) << (BITS - len - pos), allowRewrite);\n        if (first !== undefined) {\n            if (!_bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite))\n                return false; // first chunk\n        }\n        // middle chunks\n        const start = first !== undefined ? first + 1 : pos / BITS;\n        const end = last !== undefined ? last : lastPos / BITS;\n        for (let i = start; i < end; i++)\n            if (!_bitset.set(bs, i, FULL_MASK, allowRewrite))\n                return false;\n        if (last !== undefined && first !== last)\n            if (!_bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite))\n                return false; // last chunk\n        return true;\n    },\n};\nexport class Reader {\n    constructor(data, opts = {}, path = [], fieldPath = [], parent = undefined, parentOffset = 0) {\n        this.data = data;\n        this.opts = opts;\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.parent = parent;\n        this.parentOffset = parentOffset;\n        this.pos = 0;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    enablePtr() {\n        if (this.parent)\n            return this.parent.enablePtr();\n        if (this.bs)\n            return;\n        this.bs = _bitset.create(this.data.length);\n        _bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n    }\n    markBytesBS(pos, len) {\n        if (this.parent)\n            return this.parent.markBytesBS(this.parentOffset + pos, len);\n        if (!len)\n            return true;\n        if (!this.bs)\n            return true;\n        return _bitset.setRange(this.bs, this.data.length, pos, len, false);\n    }\n    markBytes(len) {\n        const pos = this.pos;\n        this.pos += len;\n        const res = this.markBytesBS(pos, len);\n        if (!this.opts.allowMultipleReads && !res)\n            throw this.err(`multiple read pos=${this.pos} len=${len}`);\n        return res;\n    }\n    err(msg) {\n        return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    // read bytes by absolute offset\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('absBytes: Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    // return reader using offset\n    offsetReader(n) {\n        return new Reader(this.absBytes(n), this.opts, this.path, this.fieldPath, this, n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.markBytes(n);\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        const data = this.data[this.pos];\n        if (!peek)\n            this.markBytes(1);\n        return data;\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    length(len) {\n        let byteLen;\n        if (isCoder(len))\n            byteLen = Number(len.decodeStream(this));\n        else if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (typeof byteLen !== 'number')\n            throw this.err(`Wrong length: ${byteLen}`);\n        return byteLen;\n    }\n    // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.byte();\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        // Fix signed integers\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        // indexOf should be faster than full equalBytes check\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n        return;\n    }\n    finish() {\n        if (this.opts.allowUnreadBytes)\n            return;\n        if (this.bitPos) {\n            throw this.err(`${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n        if (this.bs && !this.parent) {\n            const notRead = _bitset.indices(this.bs, this.data.length, true);\n            if (notRead.length) {\n                const formatted = _bitset\n                    .range(notRead)\n                    .map(({ pos, length }) => `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`)\n                    .join(', ');\n                throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n            }\n            else\n                return; // all bytes read, everything is ok\n        }\n        // Default: no pointers enabled\n        if (!this.isEnd()) {\n            throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nexport class Writer {\n    constructor(path = [], fieldPath = []) {\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.buffers = [];\n        this.pos = 0;\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    bytes(b) {\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    get buffer() {\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        let buf = concatBytes(...this.buffers);\n        for (let ptr of this.ptrs) {\n            const pos = buf.length;\n            buf = concatBytes(buf, ptr.buffer);\n            const val = ptr.ptr.encode(pos);\n            for (let i = 0; i < val.length; i++)\n                buf[ptr.pos + i] = val[i];\n        }\n        return buf;\n    }\n    length(len, value) {\n        if (len === null)\n            return;\n        if (isCoder(len))\n            return len.encodeStream(this, value);\n        let byteLen;\n        if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (byteLen === undefined || byteLen !== value)\n            throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\n// Immutable LE<->BE\nconst swap = (b) => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n    if (signed) {\n        // [-(2**(32-1)), 2**(32-1)-1]\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw p.err('sInt: value out of bounds');\n    }\n    else {\n        // [0, 2**32-1]\n        if (0n > value || value >= 2n ** bits)\n            throw p.err('uInt: value out of bounds');\n    }\n}\n// Wrap stream encoder into generic encoder\nexport function wrap(inner) {\n    return {\n        ...inner,\n        encode: (value) => {\n            const w = new Writer();\n            inner.encodeStream(w, value);\n            return w.buffer;\n        },\n        decode: (data, opts = {}) => {\n            const r = new Reader(data, opts);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\nfunction getPath(objPath, path) {\n    objPath = Array.from(objPath);\n    let i = 0;\n    for (; i < path.length; i++) {\n        if (path[i] === '..')\n            objPath.pop();\n        else\n            break;\n    }\n    let cur = objPath.pop();\n    for (; i < path.length; i++) {\n        if (!cur || cur[path[i]] === undefined)\n            return undefined;\n        cur = cur[path[i]];\n    }\n    return cur;\n}\nexport function isCoder(elm) {\n    return (typeof elm.encode === 'function' &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decode === 'function' &&\n        typeof elm.decodeStream === 'function');\n}\n// Coders (like in @scure/base) for common operations\n// TODO:\n// - move to base? very generic converters, not releated to base and packed\n// - encode/decode -> from/to? coder->convert?\nfunction dict() {\n    return {\n        encode: (from) => {\n            const to = {};\n            for (const [name, value] of from) {\n                if (to[name] !== undefined)\n                    throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => Object.entries(to),\n    };\n}\n// Safely converts bigint to number\n// Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n// but we still can use them since real value will be smaller than u32\nconst number = {\n    encode: (from) => {\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => BigInt(to),\n};\nfunction tsEnum(e) {\n    return {\n        encode: (from) => e[from],\n        decode: (to) => e[to],\n    };\n}\nfunction decimal(precision) {\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n            const int = BigInt(intS) * decimalMask;\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\n/**\n * Allows to split big conditional coders into a small one; also sort of parser combinator:\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * 1. It is easier to reason: encode/decode of specific part are closer to each other\n * 2. Allows composable coders and ability to add conditions on runtime\n * @param lst\n * @returns\n */\nfunction match(lst) {\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\nexport const coders = { dict, number, tsEnum, decimal, match };\n// PackedCoders\nexport const bits = (len) => wrap({\n    encodeStream: (w, value) => w.bits(value, len),\n    decodeStream: (r) => r.bits(len),\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n    size,\n    encodeStream: (w, value) => {\n        if (typeof value !== 'number' && typeof value !== 'bigint')\n            throw w.err(`bigint: invalid value: ${value}`);\n        let _value = BigInt(value);\n        const bLen = BigInt(size);\n        checkBounds(w, _value, 8n * bLen, !!signed);\n        const signBit = 2n ** (8n * bLen - 1n);\n        if (signed && _value < 0)\n            _value = _value | signBit;\n        let b = [];\n        for (let i = 0; i < size; i++) {\n            b.push(Number(_value & 255n));\n            _value >>= 8n;\n        }\n        let res = new Uint8Array(b).reverse();\n        w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r) => {\n        const bLen = BigInt(size);\n        let value = r.bytes(size);\n        if (le)\n            value = swap(value);\n        const b = swap(value);\n        const signBit = 2n ** (8n * bLen - 1n);\n        let res = 0n;\n        for (let i = 0; i < b.length; i++)\n            res |= BigInt(b[i]) << (8n * BigInt(i));\n        if (signed && res & signBit)\n            res = (res ^ signBit) - signBit;\n        checkBounds(r, res, 8n * bLen, !!signed);\n        return res;\n    },\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n    return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n});\n// Can be done w array, but specific implementation should be\n// faster: no need to create js array of numbers.\nexport const bytes = (len, le = false) => wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n        if (!isBytes(value))\n            throw w.err(`bytes: invalid value ${value}`);\n        if (!isBytes(len))\n            w.length(len, value.length);\n        w.bytes(le ? swap(value) : value);\n        if (isBytes(len))\n            w.bytes(len);\n    },\n    decodeStream: (r) => {\n        let bytes;\n        if (isBytes(len)) {\n            const tPos = r.find(len);\n            if (!tPos)\n                throw r.err(`bytes: cannot find terminator`);\n            bytes = r.bytes(tPos - r.pos);\n            r.bytes(len.length);\n        }\n        else\n            bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n        return le ? swap(bytes) : bytes;\n    },\n});\nexport const string = (len, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, utf8.decode(value)),\n        decodeStream: (r) => utf8.encode(inner.decodeStream(r)),\n    });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (withZero && !value.startsWith('0x'))\n                throw new Error('hex(withZero=true).encode input should start with 0x');\n            const bytes = baseHex.decode(withZero ? value.slice(2) : value);\n            return inner.encodeStream(w, bytes);\n        },\n        decodeStream: (r) => (withZero ? '0x' : '') + baseHex.encode(inner.decodeStream(r)),\n    });\n};\n// Interoperability with base\nexport function apply(inner, b) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = b.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return b.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\n// Additional check of values both on encode and decode steps.\n// E.g. to force uint32 to be 1..10\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n        decodeStream: (r) => fn(inner.decodeStream(r)),\n    });\n}\nexport function lazy(fn) {\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, baseBytes(fmt, value)),\n        decodeStream: (r) => baseStr(fmt, inner.decodeStream(r)),\n    });\n};\n// Returns true if some marker exists, otherwise false. Xor argument flips behaviour\nexport const flag = (flagValue, xor = false) => wrap({\n    size: flagValue.length,\n    encodeStream: (w, value) => {\n        if (!!value !== xor)\n            w.bytes(flagValue);\n    },\n    decodeStream: (r) => {\n        let hasFlag = r.leftBytes >= flagValue.length;\n        if (hasFlag) {\n            hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n            // Found flag, advance cursor position\n            if (hasFlag)\n                r.bytes(flagValue.length);\n        }\n        // hasFlag ^ xor\n        return hasFlag !== xor;\n    },\n});\n// Decode/encode only if flag found\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (getPath(w.path, path.split('/')))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = getPath(r.path, path.split('/'));\n            else\n                hasFlag = path.decodeStream(r);\n            // If there is a flag -- decode and return value\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, _value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n    });\n}\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n    return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n    return wrap({\n        encodeStream: (_w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (_r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (let f of fields) {\n        if (f.size === undefined)\n            return;\n        if (!Number.isSafeInteger(f.size))\n            throw new Error(`sizeof: wrong element size=${size}`);\n        size += f.size;\n    }\n    return size;\n}\nexport function struct(fields) {\n    if (Array.isArray(fields))\n        throw new Error('Packed.Struct: got array instead of object');\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`struct: invalid value ${value}`);\n            w.path.push(value);\n            for (let name in fields) {\n                w.fieldPathPush(name);\n                let field = fields[name];\n                field.encodeStream(w, value[name]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = {};\n            r.path.push(res);\n            for (let name in fields) {\n                r.fieldPathPush(name);\n                res[name] = fields[name].decodeStream(r);\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.path.push(value);\n            for (let i = 0; i < fields.length; i++) {\n                w.fieldPathPush('' + i);\n                fields[i].encodeStream(w, value[i]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = [];\n            r.path.push(res);\n            for (let i = 0; i < fields.length; i++) {\n                r.fieldPathPush('' + i);\n                res.push(fields[i].decodeStream(r));\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    if (isBytes(len))\n        throw new Error(`prefix: len cannot be Uint8Array`);\n    const b = bytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            const wChild = new Writer(w.path, w.fieldPath);\n            inner.encodeStream(wChild, value);\n            b.encodeStream(w, wChild.buffer);\n        },\n        decodeStream: (r) => {\n            const data = b.decodeStream(r);\n            const ir = new Reader(data, r.opts, r.path, r.fieldPath);\n            const res = inner.decodeStream(ir);\n            ir.finish();\n            return res;\n        },\n    });\n}\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`array: invalid value ${value}`);\n            if (!isBytes(len))\n                w.length(len, value.length);\n            w.path.push(value);\n            for (let i = 0; i < value.length; i++) {\n                w.fieldPathPush('' + i);\n                const elm = value[i];\n                const startPos = w.pos;\n                inner.encodeStream(w, elm);\n                if (isBytes(len)) {\n                    // Terminator is bigger than elm size, so skip\n                    if (len.length > w.pos - startPos)\n                        continue;\n                    const data = w.buffer.subarray(startPos, w.pos);\n                    // There is still possible case when multiple elements create terminator,\n                    // but it is hard to catch here, will be very slow\n                    if (equalBytes(data.subarray(0, len.length), len))\n                        throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                }\n                w.fieldPathPop();\n            }\n            w.path.pop();\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let res = [];\n            if (len === null) {\n                let i = 0;\n                r.path.push(res);\n                while (!r.isEnd()) {\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                    if (inner.size && r.leftBytes < inner.size)\n                        break;\n                }\n                r.path.pop();\n            }\n            else if (isBytes(len)) {\n                let i = 0;\n                r.path.push(res);\n                while (true) {\n                    if (equalBytes(r.bytes(len.length, true), len)) {\n                        // Advance cursor position if terminator found\n                        r.bytes(len.length);\n                        break;\n                    }\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            else {\n                r.fieldPathPush('arrayLen');\n                const length = r.length(len);\n                r.fieldPathPop();\n                r.path.push(res);\n                for (let i = 0; i < length; i++) {\n                    r.fieldPathPush('' + i);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            return res;\n        },\n    });\n}\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (typeof value !== 'string')\n                throw w.err(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw w.err(`Map: unknown variant: ${value}`);\n            inner.encodeStream(w, variants[value]);\n        },\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n    });\n}\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n    });\n}\n// Takes {name: [value, coder]}\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        mapValue[key] = variants[key][0];\n        tagValue[key] = variants[key][1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`bitset: invalid value ${value}`);\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            let out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n    });\n}\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft with dynamic size argument is impossible');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const pos = w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\n// Pointers are scoped, next pointer in dereference chain is offseted by previous one.\n// Not too generic, but, works fine for now.\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (!ptr.size)\n        throw new Error('Pointer: unsized ptr');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            // TODO: by some reason it encodes array of pointers as [(ptr,val), (ptr, val)]\n            // instead of [ptr, ptr][val, val]\n            const start = w.pos;\n            ptr.encodeStream(w, 0);\n            w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            r.enablePtr();\n            return inner.decodeStream(r.offsetReader(ptrVal));\n        },\n    });\n}\n// lineLen: gpg=64, ssh=70\nexport function base64armor(name, lineLen, inner, checksum) {\n    const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n    const markEnd = `-----END ${name.toUpperCase()}-----`;\n    return {\n        encode(value) {\n            const data = inner.encode(value);\n            const encoded = base64.encode(data);\n            let lines = [];\n            for (let i = 0; i < encoded.length; i += lineLen) {\n                const s = encoded.slice(i, i + lineLen);\n                if (s.length)\n                    lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n            }\n            let body = lines.join('');\n            if (checksum)\n                body += `=${base64.encode(checksum(data))}\\n`;\n            return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n        },\n        decode(s) {\n            let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n            lines = lines.map((l) => l.replace('\\r', '').trim());\n            if (checksum && lines[lines.length - 1].startsWith('=')) {\n                const body = base64.decode(lines.slice(0, -1).join(''));\n                const cs = lines[lines.length - 1].slice(1);\n                const realCS = base64.encode(checksum(body));\n                if (realCS !== cs)\n                    throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n                return inner.decode(body);\n            }\n            return inner.decode(base64.decode(lines.join('')));\n        },\n    };\n}\n// Does nothing at all\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n    if (!isCoder(inner))\n        throw new Error(`debug: invalid inner value ${inner}`);\n    const log = (name, rw, value) => {\n        // @ts-ignore\n        console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, { type: typeof value, value });\n        return value;\n    };\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n        decodeStream: (r) => log('decode', r, inner.decodeStream(r)),\n    });\n}\n// Internal methods for test purposes only\nexport const _TEST = /* @__PURE__ */ { _bitset };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// main.js\r\n\r\n// import necessary libraries\r\nimport { HelperFunctions } from \"./helperfns\";\r\n\r\nconst helper = new HelperFunctions();\r\nconst password = \"password\";\r\n\r\nfunction processInputs() {\r\n    \r\n    const fileInput = document.getElementById('fileInput');\r\n    const textInput = document.getElementById('textInput');\r\n    const resultDiv = document.getElementById('result');\r\n\r\n    // handle file input\r\n    if(fileInput.files.length > 0) {\r\n        const file = fileInput.files[0];\r\n        console.log(\"getting ready...\");\r\n        helper.readFileAsByteArray(file, (error, byteArray) => {\r\n            if(error) {\r\n                resultDiv.innerHTML = `<span style=\"color: red;\">Error reading file: ${error.message}</span>`;\r\n            } else {                \r\n                resultDiv.innerHTML = `<p style=\"color: black;\"> File Content (as byte array): ${byteArray.join(',')}</p>`;\r\n                helper.uploadToBitcoin(byteArray, password);\r\n            }\r\n        });\r\n    }\r\n\r\n    // handle text input\r\n    const plainText = textInput.value.trim();\r\n    if(plainText !== '') {\r\n        const textByteArray = helper.textToUTF8Array(plainText);        \r\n        resultDiv.innerHTML += `<p style=\"color: black;\"> Text Content (as utf-8 array): ${textByteArray.join(',')}</p>`;\r\n    }\r\n}\r\n\r\n// expose the processInputs function globally for the onclick attribute\r\nwindow.processInputs = processInputs;"],"names":["_regeneratorRuntime","e","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","value","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","type","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","_catch","delegateYield","asyncGeneratorStep","gen","reject","_next","_throw","key","info","error","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","_toPropertyKey","_createClass","protoProps","staticProps","_toPrimitive","String","toPrimitive","Number","bip39","wordlist","HDKey","btc","axios","Buffer","HelperFunctions","mnemonic","generateMnemonic","console","log","feeEstiamtor","_readFileAsByteArray","_callee","file","callback","reader","_callee$","_context","FileReader","onload","event","arrayBuffer","result","byteArray","Uint8Array","onerror","readAsArrayBuffer","readFileAsByteArray","_x","_x2","textToUTF8Array","plainText","textEncoder","TextEncoder","encode","validateMnemonic","_getEstimatedFee","_callee2","feeRate","_callee2$","_context2","getFeeRate","t0","handleError","getEstimatedFee","_getInputs","_callee3","amount","privateKey","nodeUrl","response","inputs","totalAmount","selectedInputs","_iterator","_step","input","_callee3$","_context3","process","env","BITCOIN_API","get","concat","getAddress","data","_createForOfIteratorHelper","t1","getInputs","_x3","_x4","derivePrivateKey","seed","masterKey","fromMasterSeed","path","derive","_createTransaction","_callee4","txBuilder","dataHex","script","adjustedDataHex","dataLength","pushSize","outputScript","estimatedFee","_iterator2","_step2","_callee4$","_context4","Transaction","unsignedTx","from","toString","OutScript","buffer","Math","ceil","log2","addOutput","BigInt","fee","addInput","txid","index","witnessUtxo","sign","build","createTransaction","_x5","_x6","_broadcastTx","_callee5","signedTx","requestBody","_callee5$","_context5","id","hex","toHex","post","displayResults","broadcastTx","_x7","uploadToBitcoin","password","mnemonicToSeedSync","transaction","message","resultDiv","document","getElementById","innerHTML","helper","processInputs","fileInput","textInput","files","join","trim","textByteArray","window"],"sourceRoot":""}