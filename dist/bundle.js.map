{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./node_modules/@noble/hashes/esm/_assert.js","webpack:///./node_modules/@noble/hashes/esm/crypto.js","webpack:///./node_modules/@noble/hashes/esm/utils.js","webpack:///./node_modules/@noble/hashes/esm/hmac.js","webpack:///./node_modules/@noble/hashes/esm/_sha2.js","webpack:///./node_modules/@noble/hashes/esm/sha256.js","webpack:///./node_modules/@noble/hashes/esm/_u64.js","webpack:///./node_modules/@noble/hashes/esm/sha512.js","webpack:///./node_modules/@scure/base/lib/esm/index.js","webpack:///./node_modules/@scure/bip39/esm/index.js","webpack:///./node_modules/@noble/hashes/esm/pbkdf2.js","webpack:///./node_modules/@scure/bip39/esm/wordlists/english.js","webpack:///./node_modules/@noble/hashes/esm/ripemd160.js","webpack:///./node_modules/@noble/curves/esm/abstract/utils.js","webpack:///./node_modules/@noble/curves/esm/abstract/modular.js","webpack:///./node_modules/@noble/curves/esm/abstract/curve.js","webpack:///./node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack:///./node_modules/@noble/curves/esm/_shortw_utils.js","webpack:///./node_modules/@noble/curves/esm/secp256k1.js","webpack:///./node_modules/@scure/bip32/lib/esm/index.js","webpack:///./node_modules/micro-packed/lib/esm/index.js","webpack:///./node_modules/@scure/btc-signer/lib/esm/index.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/axios/lib/core/AxiosError.js","webpack:///./node_modules/axios/lib/helpers/toFormData.js","webpack:///./node_modules/axios/lib/helpers/AxiosURLSearchParams.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/defaults/transitional.js","webpack:///./node_modules/axios/lib/platform/browser/index.js","webpack:///./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js","webpack:///./node_modules/axios/lib/platform/browser/classes/FormData.js","webpack:///./node_modules/axios/lib/platform/browser/classes/Blob.js","webpack:///./node_modules/axios/lib/platform/common/utils.js","webpack:///./node_modules/axios/lib/platform/index.js","webpack:///./node_modules/axios/lib/helpers/formDataToJSON.js","webpack:///./node_modules/axios/lib/defaults/index.js","webpack:///./node_modules/axios/lib/helpers/toURLEncodedForm.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/core/AxiosHeaders.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/cancel/CanceledError.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/core/buildFullPath.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/helpers/speedometer.js","webpack:///./node_modules/axios/lib/adapters/adapters.js","webpack:///./node_modules/axios/lib/helpers/null.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/helpers/parseProtocol.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/mergeConfig.js","webpack:///./node_modules/axios/lib/env/data.js","webpack:///./node_modules/axios/lib/helpers/validator.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/helpers/HttpStatusCode.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./node_modules/axios/lib/helpers/isAxiosError.js","webpack:///./modules/helperfns/index.js","webpack:///./modules/main.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n","/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { bytes as assertBytes, number as assertNumber } from '@noble/hashes/_assert';\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    assertBytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    assertNumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n","import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    assertHash(hash);\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    assertNumber(c);\n    assertNumber(dkLen);\n    assertNumber(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = toBytes(_password);\n    const salt = toBytes(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexport async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await asyncLoop(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!ut.isBytes(data))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { bytes as assertBytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { createBase58check } from '@scure/base';\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${bytesToHex(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return hexToBytes(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        assertBytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string') {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this.pubKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = mod(this.privKey + childTweak, secp.CURVE.n);\n                if (!secp.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        assertBytes(hash, 32);\n        return secp.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        assertBytes(hash, 32);\n        assertBytes(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        assertBytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map","import { base64, bytes as baseBytes, hex as baseHex, str as baseStr, utf8 } from '@scure/base';\n/**\n * TODO:\n * - Holes, simplify pointers. Hole is some sized element which is skipped at encoding,\n *   but later other elements can write to it by path\n * - Composite / tuple keys for dict\n * - Web UI for easier debugging. We can wrap every coder to something that would write\n *   start & end positions to; and we can colorize specific bytes used by specific coder\n */\n// Useful default values\nexport const EMPTY = /* @__PURE__ */ new Uint8Array(); // Empty bytes array\nexport const NULL = /* @__PURE__ */ new Uint8Array([0]); // NULL\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\nexport function concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport const isBytes = (b) => b instanceof Uint8Array;\n// Utils\n// Small bitset structure to store position of ranges that have been read.\n// Possible can be even more efficient by using some interval trees, but would be more complex\n// Needs O(N/8) memory for parsing.\n// Purpose: if there are pointers in parsed structure,\n// they can cause read of two distinct ranges:\n// [0-32, 64-128], which means 'pos' is not enough to handle them\nconst _bitset = /* @__PURE__ */ {\n    BITS: 32,\n    FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n    len: (len) => Math.ceil(len / 32),\n    create: (len) => new Uint32Array(_bitset.len(len)),\n    clean: (bs) => bs.fill(0),\n    debug: (bs) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n    checkLen: (bs, len) => {\n        if (_bitset.len(len) === bs.length)\n            return;\n        throw new Error(`bitSet: wrong length=${bs.length}. Expected: ${_bitset.len(len)}`);\n    },\n    chunkLen: (bsLen, pos, len) => {\n        if (pos < 0)\n            throw new Error(`bitset: wrong pos=${pos}`);\n        if (pos + len > bsLen)\n            throw new Error(`bitSet: wrong range=${pos}/${len} of ${bsLen}`);\n    },\n    set: (bs, chunk, value, allowRewrite = true) => {\n        if (!allowRewrite && (bs[chunk] & value) !== 0)\n            return false;\n        bs[chunk] |= value;\n        return true;\n    },\n    pos: (pos, i) => ({\n        chunk: Math.floor((pos + i) / 32),\n        mask: 1 << (32 - ((pos + i) % 32) - 1),\n    }),\n    indices: (bs, len, invert = false) => {\n        _bitset.checkLen(bs, len);\n        const { FULL_MASK, BITS } = _bitset;\n        const left = BITS - (len % BITS);\n        const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n        const res = [];\n        for (let i = 0; i < bs.length; i++) {\n            let c = bs[i];\n            if (invert)\n                c = ~c; // allows to gen unset elements\n            // apply mask to last element, so we won't iterate non-existent items\n            if (i === bs.length - 1)\n                c &= lastMask;\n            if (c === 0)\n                continue; // fast-path\n            for (let j = 0; j < BITS; j++) {\n                const m = 1 << (BITS - j - 1);\n                if (c & m)\n                    res.push(i * BITS + j);\n            }\n        }\n        return res;\n    },\n    range: (arr) => {\n        const res = [];\n        let cur;\n        for (const i of arr) {\n            if (cur === undefined || i !== cur.pos + cur.length)\n                res.push((cur = { pos: i, length: 1 }));\n            else\n                cur.length += 1;\n        }\n        return res;\n    },\n    rangeDebug: (bs, len, invert = false) => `[${_bitset\n        .range(_bitset.indices(bs, len, invert))\n        .map((i) => `(${i.pos}/${i.length})`)\n        .join(', ')}]`,\n    setRange: (bs, bsLen, pos, len, allowRewrite = true) => {\n        _bitset.chunkLen(bsLen, pos, len);\n        const { FULL_MASK, BITS } = _bitset;\n        // Try to set range with maximum efficiency:\n        // - first chunk is always    '0000[1111]' (only right ones)\n        // - middle chunks are set to '[1111 1111]' (all ones)\n        // - last chunk is always     '[1111]0000' (only left ones)\n        // - max operations:          (N/32) + 2 (first and last)\n        const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n        const lastPos = pos + len;\n        const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n        // special case, whole range inside single chunk\n        if (first !== undefined && first === last)\n            return _bitset.set(bs, first, (FULL_MASK >>> (BITS - len)) << (BITS - len - pos), allowRewrite);\n        if (first !== undefined) {\n            if (!_bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite))\n                return false; // first chunk\n        }\n        // middle chunks\n        const start = first !== undefined ? first + 1 : pos / BITS;\n        const end = last !== undefined ? last : lastPos / BITS;\n        for (let i = start; i < end; i++)\n            if (!_bitset.set(bs, i, FULL_MASK, allowRewrite))\n                return false;\n        if (last !== undefined && first !== last)\n            if (!_bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite))\n                return false; // last chunk\n        return true;\n    },\n};\nexport class Reader {\n    constructor(data, opts = {}, path = [], fieldPath = [], parent = undefined, parentOffset = 0) {\n        this.data = data;\n        this.opts = opts;\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.parent = parent;\n        this.parentOffset = parentOffset;\n        this.pos = 0;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    enablePtr() {\n        if (this.parent)\n            return this.parent.enablePtr();\n        if (this.bs)\n            return;\n        this.bs = _bitset.create(this.data.length);\n        _bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n    }\n    markBytesBS(pos, len) {\n        if (this.parent)\n            return this.parent.markBytesBS(this.parentOffset + pos, len);\n        if (!len)\n            return true;\n        if (!this.bs)\n            return true;\n        return _bitset.setRange(this.bs, this.data.length, pos, len, false);\n    }\n    markBytes(len) {\n        const pos = this.pos;\n        this.pos += len;\n        const res = this.markBytesBS(pos, len);\n        if (!this.opts.allowMultipleReads && !res)\n            throw this.err(`multiple read pos=${this.pos} len=${len}`);\n        return res;\n    }\n    err(msg) {\n        return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    // read bytes by absolute offset\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('absBytes: Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    // return reader using offset\n    offsetReader(n) {\n        return new Reader(this.absBytes(n), this.opts, this.path, this.fieldPath, this, n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.markBytes(n);\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        const data = this.data[this.pos];\n        if (!peek)\n            this.markBytes(1);\n        return data;\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    length(len) {\n        let byteLen;\n        if (isCoder(len))\n            byteLen = Number(len.decodeStream(this));\n        else if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (typeof byteLen !== 'number')\n            throw this.err(`Wrong length: ${byteLen}`);\n        return byteLen;\n    }\n    // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.byte();\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        // Fix signed integers\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        // indexOf should be faster than full equalBytes check\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n        return;\n    }\n    finish() {\n        if (this.opts.allowUnreadBytes)\n            return;\n        if (this.bitPos) {\n            throw this.err(`${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n        if (this.bs && !this.parent) {\n            const notRead = _bitset.indices(this.bs, this.data.length, true);\n            if (notRead.length) {\n                const formatted = _bitset\n                    .range(notRead)\n                    .map(({ pos, length }) => `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`)\n                    .join(', ');\n                throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n            }\n            else\n                return; // all bytes read, everything is ok\n        }\n        // Default: no pointers enabled\n        if (!this.isEnd()) {\n            throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`);\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nexport class Writer {\n    constructor(path = [], fieldPath = []) {\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.buffers = [];\n        this.pos = 0;\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    bytes(b) {\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    get buffer() {\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        let buf = concatBytes(...this.buffers);\n        for (let ptr of this.ptrs) {\n            const pos = buf.length;\n            buf = concatBytes(buf, ptr.buffer);\n            const val = ptr.ptr.encode(pos);\n            for (let i = 0; i < val.length; i++)\n                buf[ptr.pos + i] = val[i];\n        }\n        return buf;\n    }\n    length(len, value) {\n        if (len === null)\n            return;\n        if (isCoder(len))\n            return len.encodeStream(this, value);\n        let byteLen;\n        if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (byteLen === undefined || byteLen !== value)\n            throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\n// Immutable LE<->BE\nconst swap = (b) => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n    if (signed) {\n        // [-(2**(32-1)), 2**(32-1)-1]\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw p.err('sInt: value out of bounds');\n    }\n    else {\n        // [0, 2**32-1]\n        if (0n > value || value >= 2n ** bits)\n            throw p.err('uInt: value out of bounds');\n    }\n}\n// Wrap stream encoder into generic encoder\nexport function wrap(inner) {\n    return {\n        ...inner,\n        encode: (value) => {\n            const w = new Writer();\n            inner.encodeStream(w, value);\n            return w.buffer;\n        },\n        decode: (data, opts = {}) => {\n            const r = new Reader(data, opts);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\nfunction getPath(objPath, path) {\n    objPath = Array.from(objPath);\n    let i = 0;\n    for (; i < path.length; i++) {\n        if (path[i] === '..')\n            objPath.pop();\n        else\n            break;\n    }\n    let cur = objPath.pop();\n    for (; i < path.length; i++) {\n        if (!cur || cur[path[i]] === undefined)\n            return undefined;\n        cur = cur[path[i]];\n    }\n    return cur;\n}\nexport function isCoder(elm) {\n    return (typeof elm.encode === 'function' &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decode === 'function' &&\n        typeof elm.decodeStream === 'function');\n}\n// Coders (like in @scure/base) for common operations\n// TODO:\n// - move to base? very generic converters, not releated to base and packed\n// - encode/decode -> from/to? coder->convert?\nfunction dict() {\n    return {\n        encode: (from) => {\n            const to = {};\n            for (const [name, value] of from) {\n                if (to[name] !== undefined)\n                    throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => Object.entries(to),\n    };\n}\n// Safely converts bigint to number\n// Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n// but we still can use them since real value will be smaller than u32\nconst number = {\n    encode: (from) => {\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => BigInt(to),\n};\nfunction tsEnum(e) {\n    return {\n        encode: (from) => e[from],\n        decode: (to) => e[to],\n    };\n}\nfunction decimal(precision) {\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n            const int = BigInt(intS) * decimalMask;\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\n/**\n * Allows to split big conditional coders into a small one; also sort of parser combinator:\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * 1. It is easier to reason: encode/decode of specific part are closer to each other\n * 2. Allows composable coders and ability to add conditions on runtime\n * @param lst\n * @returns\n */\nfunction match(lst) {\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\nexport const coders = { dict, number, tsEnum, decimal, match };\n// PackedCoders\nexport const bits = (len) => wrap({\n    encodeStream: (w, value) => w.bits(value, len),\n    decodeStream: (r) => r.bits(len),\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n    size,\n    encodeStream: (w, value) => {\n        if (typeof value !== 'number' && typeof value !== 'bigint')\n            throw w.err(`bigint: invalid value: ${value}`);\n        let _value = BigInt(value);\n        const bLen = BigInt(size);\n        checkBounds(w, _value, 8n * bLen, !!signed);\n        const signBit = 2n ** (8n * bLen - 1n);\n        if (signed && _value < 0)\n            _value = _value | signBit;\n        let b = [];\n        for (let i = 0; i < size; i++) {\n            b.push(Number(_value & 255n));\n            _value >>= 8n;\n        }\n        let res = new Uint8Array(b).reverse();\n        w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r) => {\n        const bLen = BigInt(size);\n        let value = r.bytes(size);\n        if (le)\n            value = swap(value);\n        const b = swap(value);\n        const signBit = 2n ** (8n * bLen - 1n);\n        let res = 0n;\n        for (let i = 0; i < b.length; i++)\n            res |= BigInt(b[i]) << (8n * BigInt(i));\n        if (signed && res & signBit)\n            res = (res ^ signBit) - signBit;\n        checkBounds(r, res, 8n * bLen, !!signed);\n        return res;\n    },\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n    return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n});\n// Can be done w array, but specific implementation should be\n// faster: no need to create js array of numbers.\nexport const bytes = (len, le = false) => wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n        if (!isBytes(value))\n            throw w.err(`bytes: invalid value ${value}`);\n        if (!isBytes(len))\n            w.length(len, value.length);\n        w.bytes(le ? swap(value) : value);\n        if (isBytes(len))\n            w.bytes(len);\n    },\n    decodeStream: (r) => {\n        let bytes;\n        if (isBytes(len)) {\n            const tPos = r.find(len);\n            if (!tPos)\n                throw r.err(`bytes: cannot find terminator`);\n            bytes = r.bytes(tPos - r.pos);\n            r.bytes(len.length);\n        }\n        else\n            bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n        return le ? swap(bytes) : bytes;\n    },\n});\nexport const string = (len, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, utf8.decode(value)),\n        decodeStream: (r) => utf8.encode(inner.decodeStream(r)),\n    });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (withZero && !value.startsWith('0x'))\n                throw new Error('hex(withZero=true).encode input should start with 0x');\n            const bytes = baseHex.decode(withZero ? value.slice(2) : value);\n            return inner.encodeStream(w, bytes);\n        },\n        decodeStream: (r) => (withZero ? '0x' : '') + baseHex.encode(inner.decodeStream(r)),\n    });\n};\n// Interoperability with base\nexport function apply(inner, b) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = b.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return b.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\n// Additional check of values both on encode and decode steps.\n// E.g. to force uint32 to be 1..10\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n        decodeStream: (r) => fn(inner.decodeStream(r)),\n    });\n}\nexport function lazy(fn) {\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, baseBytes(fmt, value)),\n        decodeStream: (r) => baseStr(fmt, inner.decodeStream(r)),\n    });\n};\n// Returns true if some marker exists, otherwise false. Xor argument flips behaviour\nexport const flag = (flagValue, xor = false) => wrap({\n    size: flagValue.length,\n    encodeStream: (w, value) => {\n        if (!!value !== xor)\n            w.bytes(flagValue);\n    },\n    decodeStream: (r) => {\n        let hasFlag = r.leftBytes >= flagValue.length;\n        if (hasFlag) {\n            hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n            // Found flag, advance cursor position\n            if (hasFlag)\n                r.bytes(flagValue.length);\n        }\n        // hasFlag ^ xor\n        return hasFlag !== xor;\n    },\n});\n// Decode/encode only if flag found\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (getPath(w.path, path.split('/')))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = getPath(r.path, path.split('/'));\n            else\n                hasFlag = path.decodeStream(r);\n            // If there is a flag -- decode and return value\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, _value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n    });\n}\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n    return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n    return wrap({\n        encodeStream: (_w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (_r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (let f of fields) {\n        if (f.size === undefined)\n            return;\n        if (!Number.isSafeInteger(f.size))\n            throw new Error(`sizeof: wrong element size=${size}`);\n        size += f.size;\n    }\n    return size;\n}\nexport function struct(fields) {\n    if (Array.isArray(fields))\n        throw new Error('Packed.Struct: got array instead of object');\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`struct: invalid value ${value}`);\n            w.path.push(value);\n            for (let name in fields) {\n                w.fieldPathPush(name);\n                let field = fields[name];\n                field.encodeStream(w, value[name]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = {};\n            r.path.push(res);\n            for (let name in fields) {\n                r.fieldPathPush(name);\n                res[name] = fields[name].decodeStream(r);\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.path.push(value);\n            for (let i = 0; i < fields.length; i++) {\n                w.fieldPathPush('' + i);\n                fields[i].encodeStream(w, value[i]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = [];\n            r.path.push(res);\n            for (let i = 0; i < fields.length; i++) {\n                r.fieldPathPush('' + i);\n                res.push(fields[i].decodeStream(r));\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    if (isBytes(len))\n        throw new Error(`prefix: len cannot be Uint8Array`);\n    const b = bytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            const wChild = new Writer(w.path, w.fieldPath);\n            inner.encodeStream(wChild, value);\n            b.encodeStream(w, wChild.buffer);\n        },\n        decodeStream: (r) => {\n            const data = b.decodeStream(r);\n            const ir = new Reader(data, r.opts, r.path, r.fieldPath);\n            const res = inner.decodeStream(ir);\n            ir.finish();\n            return res;\n        },\n    });\n}\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`array: invalid value ${value}`);\n            if (!isBytes(len))\n                w.length(len, value.length);\n            w.path.push(value);\n            for (let i = 0; i < value.length; i++) {\n                w.fieldPathPush('' + i);\n                const elm = value[i];\n                const startPos = w.pos;\n                inner.encodeStream(w, elm);\n                if (isBytes(len)) {\n                    // Terminator is bigger than elm size, so skip\n                    if (len.length > w.pos - startPos)\n                        continue;\n                    const data = w.buffer.subarray(startPos, w.pos);\n                    // There is still possible case when multiple elements create terminator,\n                    // but it is hard to catch here, will be very slow\n                    if (equalBytes(data.subarray(0, len.length), len))\n                        throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                }\n                w.fieldPathPop();\n            }\n            w.path.pop();\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let res = [];\n            if (len === null) {\n                let i = 0;\n                r.path.push(res);\n                while (!r.isEnd()) {\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                    if (inner.size && r.leftBytes < inner.size)\n                        break;\n                }\n                r.path.pop();\n            }\n            else if (isBytes(len)) {\n                let i = 0;\n                r.path.push(res);\n                while (true) {\n                    if (equalBytes(r.bytes(len.length, true), len)) {\n                        // Advance cursor position if terminator found\n                        r.bytes(len.length);\n                        break;\n                    }\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            else {\n                r.fieldPathPush('arrayLen');\n                const length = r.length(len);\n                r.fieldPathPop();\n                r.path.push(res);\n                for (let i = 0; i < length; i++) {\n                    r.fieldPathPush('' + i);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            return res;\n        },\n    });\n}\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (typeof value !== 'string')\n                throw w.err(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw w.err(`Map: unknown variant: ${value}`);\n            inner.encodeStream(w, variants[value]);\n        },\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n    });\n}\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n    });\n}\n// Takes {name: [value, coder]}\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        mapValue[key] = variants[key][0];\n        tagValue[key] = variants[key][1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`bitset: invalid value ${value}`);\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            let out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n    });\n}\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft with dynamic size argument is impossible');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const pos = w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\n// Pointers are scoped, next pointer in dereference chain is offseted by previous one.\n// Not too generic, but, works fine for now.\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (!ptr.size)\n        throw new Error('Pointer: unsized ptr');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            // TODO: by some reason it encodes array of pointers as [(ptr,val), (ptr, val)]\n            // instead of [ptr, ptr][val, val]\n            const start = w.pos;\n            ptr.encodeStream(w, 0);\n            w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            r.enablePtr();\n            return inner.decodeStream(r.offsetReader(ptrVal));\n        },\n    });\n}\n// lineLen: gpg=64, ssh=70\nexport function base64armor(name, lineLen, inner, checksum) {\n    const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n    const markEnd = `-----END ${name.toUpperCase()}-----`;\n    return {\n        encode(value) {\n            const data = inner.encode(value);\n            const encoded = base64.encode(data);\n            let lines = [];\n            for (let i = 0; i < encoded.length; i += lineLen) {\n                const s = encoded.slice(i, i + lineLen);\n                if (s.length)\n                    lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n            }\n            let body = lines.join('');\n            if (checksum)\n                body += `=${base64.encode(checksum(data))}\\n`;\n            return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n        },\n        decode(s) {\n            let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n            lines = lines.map((l) => l.replace('\\r', '').trim());\n            if (checksum && lines[lines.length - 1].startsWith('=')) {\n                const body = base64.decode(lines.slice(0, -1).join(''));\n                const cs = lines[lines.length - 1].slice(1);\n                const realCS = base64.encode(checksum(body));\n                if (realCS !== cs)\n                    throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n                return inner.decode(body);\n            }\n            return inner.decode(base64.decode(lines.join('')));\n        },\n    };\n}\n// Does nothing at all\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n    if (!isCoder(inner))\n        throw new Error(`debug: invalid inner value ${inner}`);\n    const log = (name, rw, value) => {\n        // @ts-ignore\n        console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, { type: typeof value, value });\n        return value;\n    };\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n        decodeStream: (r) => log('decode', r, inner.decodeStream(r)),\n    });\n}\n// Internal methods for test purposes only\nexport const _TEST = /* @__PURE__ */ { _bitset };\n","/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, createBase58check, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nconst { ProjectivePoint: ProjPoint, sign: _signECDSA, getPublicKey: _pubECDSA } = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => (value === undefined ? def : value);\nconst isBytes = P.isBytes;\nconst hash160 = (msg) => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = createBase58check(sha256);\nexport function cloneDeep(obj) {\n    if (Array.isArray(obj))\n        return obj.map((i) => cloneDeep(i));\n    // slice of nodejs Buffer doesn't copy\n    else if (obj instanceof Uint8Array)\n        return Uint8Array.from(obj);\n    // immutable\n    else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj))\n        return obj;\n    // null is object\n    else if (obj === null)\n        return obj;\n    // should be last, so it won't catch other types\n    else if (typeof obj === 'object') {\n        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n    }\n    throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\nvar PubT;\n(function (PubT) {\n    PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n    PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n    const len = pub.length;\n    if (type === PubT.ecdsa) {\n        if (len === 32)\n            throw new Error('Expected non-Schnorr key');\n        ProjPoint.fromHex(pub); // does assertValidity\n        return pub;\n    }\n    else if (type === PubT.schnorr) {\n        if (len !== 32)\n            throw new Error('Expected 32-byte Schnorr key');\n        schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n        return pub;\n    }\n    else {\n        throw new Error('Unknown key type');\n    }\n}\nfunction isValidPubkey(pub, type) {\n    try {\n        validatePubkey(pub, type);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig) => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n    let sig = _signECDSA(hash, privateKey);\n    if (lowR && !hasLowR(sig)) {\n        const extraEntropy = new Uint8Array(32);\n        for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n            extraEntropy.set(P.U32LE.encode(cnt));\n            sig = _signECDSA(hash, privateKey, { extraEntropy });\n            if (hasLowR(sig))\n                break;\n        }\n    }\n    return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n    const u = schnorr.utils;\n    const t = u.taggedHash('TapTweak', a, b);\n    const tn = u.bytesToNumberBE(t);\n    if (tn >= CURVE_ORDER)\n        throw new Error('tweak higher than curve order');\n    return tn;\n}\nexport function taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n    const u = schnorr.utils;\n    const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n    const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n    // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n    const xP = u.pointToBytes(P);\n    // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n    const t = tapTweak(xP, merkleRoot);\n    // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n    const u = schnorr.utils;\n    const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n    const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n    const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n    const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n    return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), (pub) => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), (pub) => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), (sig) => {\n    if (sig.length !== 64 && sig.length !== 65)\n        throw new Error('Schnorr signature should be 64 or 65 bytes long');\n    return sig;\n});\nfunction uniqPubkey(pubkeys) {\n    const map = {};\n    for (const pub of pubkeys) {\n        const key = hex.encode(pub);\n        if (map[key])\n            throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n        map[key] = true;\n    }\n}\nexport const NETWORK = {\n    bech32: 'bc',\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nexport const TEST_NETWORK = {\n    bech32: 'tb',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n    if (!isBytes(a) || !isBytes(b))\n        throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n    // -1 -> a<b, 0 -> a==b, 1 -> a>b\n    const len = Math.min(a.length, b.length);\n    for (let i = 0; i < len; i++)\n        if (a[i] != b[i])\n            return Math.sign(a[i] - b[i]);\n    return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n    OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n    OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n    OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n    OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n    OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n    OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n    OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n    OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n    OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n    OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n    OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n    OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n    OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n    OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n    OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n    OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n    OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n    OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n    OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n    OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n    OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n    OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n    // Control\n    OP[OP[\"NOP\"] = 97] = \"NOP\";\n    OP[OP[\"VER\"] = 98] = \"VER\";\n    OP[OP[\"IF\"] = 99] = \"IF\";\n    OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n    OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n    OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n    OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n    OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n    OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n    OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n    // Stack\n    OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n    OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n    OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n    OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n    OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n    OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n    OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n    OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n    OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n    OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n    OP[OP[\"DROP\"] = 117] = \"DROP\";\n    OP[OP[\"DUP\"] = 118] = \"DUP\";\n    OP[OP[\"NIP\"] = 119] = \"NIP\";\n    OP[OP[\"OVER\"] = 120] = \"OVER\";\n    OP[OP[\"PICK\"] = 121] = \"PICK\";\n    OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n    OP[OP[\"ROT\"] = 123] = \"ROT\";\n    OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n    OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n    // Splice\n    OP[OP[\"CAT\"] = 126] = \"CAT\";\n    OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n    OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n    OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n    OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n    // Boolean logic\n    OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n    OP[OP[\"AND\"] = 132] = \"AND\";\n    OP[OP[\"OR\"] = 133] = \"OR\";\n    OP[OP[\"XOR\"] = 134] = \"XOR\";\n    OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n    OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n    OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n    OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n    // Numbers\n    OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n    OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n    OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n    OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n    OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n    OP[OP[\"ABS\"] = 144] = \"ABS\";\n    OP[OP[\"NOT\"] = 145] = \"NOT\";\n    OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n    OP[OP[\"ADD\"] = 147] = \"ADD\";\n    OP[OP[\"SUB\"] = 148] = \"SUB\";\n    OP[OP[\"MUL\"] = 149] = \"MUL\";\n    OP[OP[\"DIV\"] = 150] = \"DIV\";\n    OP[OP[\"MOD\"] = 151] = \"MOD\";\n    OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n    OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n    OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n    OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n    OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n    OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n    OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n    OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n    OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n    OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n    OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n    OP[OP[\"MIN\"] = 163] = \"MIN\";\n    OP[OP[\"MAX\"] = 164] = \"MAX\";\n    OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n    // Crypto\n    OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n    OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n    OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n    OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n    OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n    OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n    OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n    OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n    OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n    OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n    // Expansion\n    OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n    OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n    OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n    OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n    OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n    OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n    OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n    OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n    OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n    OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n    // BIP 342\n    OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n    // Invalid\n    OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script = P.wrap({\n    encodeStream: (w, value) => {\n        for (let o of value) {\n            if (typeof o === 'string') {\n                if (OP[o] === undefined)\n                    throw new Error(`Unknown opcode=${o}`);\n                w.byte(OP[o]);\n                continue;\n            }\n            else if (typeof o === 'number') {\n                if (o === 0x00) {\n                    w.byte(0x00);\n                    continue;\n                }\n                else if (1 <= o && o <= 16) {\n                    w.byte(OP.OP_1 - 1 + o);\n                    continue;\n                }\n            }\n            // Encode big numbers\n            if (typeof o === 'number')\n                o = ScriptNum().encode(BigInt(o));\n            if (!isBytes(o))\n                throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n            // Bytes\n            const len = o.length;\n            if (len < OP.PUSHDATA1)\n                w.byte(len);\n            else if (len <= 0xff) {\n                w.byte(OP.PUSHDATA1);\n                w.byte(len);\n            }\n            else if (len <= 0xffff) {\n                w.byte(OP.PUSHDATA2);\n                w.bytes(P.U16LE.encode(len));\n            }\n            else {\n                w.byte(OP.PUSHDATA4);\n                w.bytes(P.U32LE.encode(len));\n            }\n            w.bytes(o);\n        }\n    },\n    decodeStream: (r) => {\n        const out = [];\n        while (!r.isEnd()) {\n            const cur = r.byte();\n            // if 0 < cur < 78\n            if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n                let len;\n                if (cur < OP.PUSHDATA1)\n                    len = cur;\n                else if (cur === OP.PUSHDATA1)\n                    len = P.U8.decodeStream(r);\n                else if (cur === OP.PUSHDATA2)\n                    len = P.U16LE.decodeStream(r);\n                else if (cur === OP.PUSHDATA4)\n                    len = P.U32LE.decodeStream(r);\n                else\n                    throw new Error('Should be not possible');\n                out.push(r.bytes(len));\n            }\n            else if (cur === 0x00) {\n                out.push(0);\n            }\n            else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n                out.push(cur - (OP.OP_1 - 1));\n            }\n            else {\n                const op = OP[cur];\n                if (op === undefined)\n                    throw new Error(`Unknown opcode=${cur.toString(16)}`);\n                out.push(op);\n            }\n        }\n        return out;\n    },\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false) {\n    return P.wrap({\n        encodeStream: (w, value) => {\n            if (value === 0n)\n                return;\n            const neg = value < 0;\n            const val = BigInt(value);\n            const nums = [];\n            for (let abs = neg ? -val : val; abs; abs >>= 8n)\n                nums.push(Number(abs & 0xffn));\n            if (nums[nums.length - 1] >= 0x80)\n                nums.push(neg ? 0x80 : 0);\n            else if (neg)\n                nums[nums.length - 1] |= 0x80;\n            w.bytes(new Uint8Array(nums));\n        },\n        decodeStream: (r) => {\n            const len = r.leftBytes;\n            if (len > bytesLimit)\n                throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n            if (len === 0)\n                return 0n;\n            if (forceMinimal) {\n                // MSB is zero (without sign bit) -> not minimally encoded\n                if ((r.data[len - 1] & 0x7f) === 0) {\n                    // exception\n                    if (len <= 1 || (r.data[len - 2] & 0x80) === 0)\n                        throw new Error('Non-minimally encoded ScriptNum');\n                }\n            }\n            let last = 0;\n            let res = 0n;\n            for (let i = 0; i < len; ++i) {\n                last = r.byte();\n                res |= BigInt(last) << (8n * BigInt(i));\n            }\n            if (last >= 0x80) {\n                res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n                res = -res;\n            }\n            return res;\n        },\n    });\n}\nexport function OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n    if (typeof op === 'number')\n        return op;\n    if (isBytes(op)) {\n        try {\n            const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n            if (val > Number.MAX_SAFE_INTEGER)\n                return;\n            return Number(val);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n    0xfd: [0xfd, 2, 253n, 65535n],\n    0xfe: [0xfe, 4, 65536n, 4294967295n],\n    0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize = P.wrap({\n    encodeStream: (w, value) => {\n        if (typeof value === 'number')\n            value = BigInt(value);\n        if (0n <= value && value <= 252n)\n            return w.byte(Number(value));\n        for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n            if (start > value || value > stop)\n                continue;\n            w.byte(flag);\n            for (let i = 0; i < bytes; i++)\n                w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n            return;\n        }\n        throw w.err(`VarInt too big: ${value}`);\n    },\n    decodeStream: (r) => {\n        const b0 = r.byte();\n        if (b0 <= 0xfc)\n            return BigInt(b0);\n        const [_, bytes, start] = CSLimits[b0];\n        let num = 0n;\n        for (let i = 0; i < bytes; i++)\n            num |= BigInt(r.byte()) << (8n * BigInt(i));\n        if (num < start)\n            throw r.err(`Wrong CompactSize(${8 * bytes})`);\n        return num;\n    },\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport const BTCArray = (t) => P.array(CompactSize, t);\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\nexport const RawInput = P.struct({\n    txid: P.bytes(32, true), // hash(prev_tx),\n    index: P.U32LE, // output number of previous tx\n    finalScriptSig: VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n    sequence: P.U32LE, // ?\n});\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\nconst EMPTY_OUTPUT = {\n    amount: 0xffffffffffffffffn,\n    script: P.EMPTY,\n};\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n    version: P.I32LE,\n    segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n    inputs: BTCArray(RawInput),\n    outputs: BTCArray(RawOutput),\n    witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n    // < 500000000\tBlock number at which this transaction is unlocked\n    // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n    // Handled as part of PSBTv2\n    lockTime: P.U32LE,\n});\nfunction validateRawTx(tx) {\n    if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n        throw new Error('Segwit flag with empty witnesses array');\n    return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n    const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n    return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\nconst BIP32Der = P.struct({\n    fingerprint: P.U32BE,\n    path: P.array(null, P.U32LE),\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n    version: P.U8, // With parity :(\n    internalKey: P.bytes(32),\n    merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n    if (cb.merklePath.length > 128)\n        throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n    return cb;\n});\nconst TaprootBIP32Der = P.struct({\n    hashes: P.array(CompactSizeLen, P.bytes(32)),\n    der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n    unsignedTx: [0x00, false, RawTx, [0], [0], false],\n    xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n    txVersion: [0x02, false, P.U32LE, [2], [2], false],\n    fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n    inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n    outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n    txModifiable: [0x06, false, P.U8, [], [2], false], // TODO: bitfield\n    version: [0xfb, false, P.U32LE, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// prettier-ignore\nconst PSBTInput = {\n    nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n    witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n    partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n    sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n    redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n    finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n    porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n    ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n    sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n    hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n    hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n    txid: [0x0e, false, Bytes32, [2], [2], true],\n    index: [0x0f, false, P.U32LE, [2], [2], true],\n    sequence: [0x10, false, P.U32LE, [], [2], true],\n    requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n    requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n    tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n    tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n    tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n    tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n    tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n    tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys = [\n    'txid',\n    'sequence',\n    'index',\n    'witnessUtxo',\n    'nonWitnessUtxo',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'unknown',\n];\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys = [\n    'partialSig',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'tapKeySig',\n    'tapScriptSig',\n];\n// prettier-ignore\nconst PSBTOutput = {\n    redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    amount: [0x03, false, P.I64LE, [2], [2], true],\n    script: [0x04, false, BytesInf, [2], [2], true],\n    tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n    tapTree: [0x06, false, tapTree, [], [0, 2], false],\n    tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n}));\nconst PSBTUnknownKey = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n    // -> Record<type, [keyName, ...coders]>\n    const byType = {};\n    for (const k in psbtEnum) {\n        const [num, kc, vc] = psbtEnum[k];\n        byType[num] = [k, kc, vc];\n    }\n    return P.wrap({\n        encodeStream: (w, value) => {\n            let out = [];\n            // Because we use order of psbtEnum, keymap is sorted here\n            for (const name in psbtEnum) {\n                const val = value[name];\n                if (val === undefined)\n                    continue;\n                const [type, kc, vc] = psbtEnum[name];\n                if (!kc) {\n                    out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n                }\n                else {\n                    // Low level interface, returns keys as is (with duplicates). Useful for debug\n                    const kv = val.map(([k, v]) => [\n                        kc.encode(k),\n                        vc.encode(v),\n                    ]);\n                    // sort by keys\n                    kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n                    for (const [key, value] of kv)\n                        out.push({ key: { key, type }, value });\n                }\n            }\n            if (value.unknown) {\n                value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n                for (const [k, v] of value.unknown)\n                    out.push({ key: k, value: v });\n            }\n            PSBTKeyPair.encodeStream(w, out);\n        },\n        decodeStream: (r) => {\n            const raw = PSBTKeyPair.decodeStream(r);\n            const out = {};\n            const noKey = {};\n            for (const elm of raw) {\n                let name = 'unknown';\n                let key = elm.key.key;\n                let value = elm.value;\n                if (byType[elm.key.type]) {\n                    const [_name, kc, vc] = byType[elm.key.type];\n                    name = _name;\n                    if (!kc && key.length) {\n                        throw new Error(`PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`);\n                    }\n                    key = kc ? kc.decode(key) : undefined;\n                    value = vc.decode(value);\n                    if (!kc) {\n                        if (out[name])\n                            throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n                        out[name] = value;\n                        noKey[name] = true;\n                        continue;\n                    }\n                }\n                else {\n                    // For unknown: add key type inside key\n                    key = { type: elm.key.type, key: elm.key.key };\n                }\n                // Only keyed elements at this point\n                if (noKey[name])\n                    throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n                if (!out[name])\n                    out[name] = [];\n                out[name].push([key, value]);\n            }\n            return out;\n        },\n    });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n    if (!P.equalBytes(s.hash, sha256(witnessScript)))\n        throw new Error('checkScript: wsh wrong witnessScript hash');\n    const w = OutScript.decode(witnessScript);\n    if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n    if (w.type === 'wpkh' || w.type === 'sh')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n    if (script) {\n        const s = OutScript.decode(script);\n        // ms||pk maybe work, but there will be no address, hard to spend\n        if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n            throw new Error(`checkScript: non-wrapped ${s.type}`);\n        if (s.type === 'sh' && redeemScript) {\n            if (!P.equalBytes(s.hash, hash160(redeemScript)))\n                throw new Error('checkScript: sh wrong redeemScript hash');\n            const r = OutScript.decode(redeemScript);\n            if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n                throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n            // Not sure if this unspendable, but we cannot represent this via PSBT\n            if (r.type === 'sh')\n                throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n        }\n        if (s.type === 'wsh' && witnessScript)\n            checkWSH(s, witnessScript);\n    }\n    if (redeemScript) {\n        const r = OutScript.decode(redeemScript);\n        if (r.type === 'wsh' && witnessScript)\n            checkWSH(r, witnessScript);\n    }\n}\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n    if (i.finalScriptWitness && !i.finalScriptWitness.length)\n        throw new Error('validateInput: wmpty finalScriptWitness');\n    //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n    if (i.partialSig && !i.partialSig.length)\n        throw new Error('Empty partialSig');\n    if (i.partialSig)\n        for (const [k] of i.partialSig)\n            validatePubkey(k, PubT.ecdsa);\n    if (i.bip32Derivation)\n        for (const [k] of i.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n    if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n        throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n    // unsigned little endian integer greater than 0 and less than 500000000\n    if (i.requiredHeightLocktime !== undefined &&\n        (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000))\n        throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n    if (i.nonWitnessUtxo && i.index !== undefined) {\n        const last = i.nonWitnessUtxo.outputs.length - 1;\n        if (i.index > last)\n            throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n        const prevOut = i.nonWitnessUtxo.outputs[i.index];\n        if (i.witnessUtxo &&\n            (!P.equalBytes(i.witnessUtxo.script, prevOut.script) ||\n                i.witnessUtxo.amount !== prevOut.amount))\n            throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n    }\n    if (i.tapLeafScript) {\n        // tap leaf version appears here twice: in control block and at the end of script\n        for (const [k, v] of i.tapLeafScript) {\n            if ((k.version & 254) !== v[v.length - 1])\n                throw new Error('validateInput: tapLeafScript version mimatch');\n            if (v[v.length - 1] & 1)\n                throw new Error('validateInput: tapLeafScript version has parity bit!');\n        }\n    }\n    // Validate txid for nonWitnessUtxo is correct\n    if (i.nonWitnessUtxo && i.index !== undefined && i.txid) {\n        const outputs = i.nonWitnessUtxo.outputs;\n        if (outputs.length - 1 < i.index)\n            throw new Error('nonWitnessUtxo: incorect output index');\n        // At this point, we are using previous tx output to create new input.\n        // Script safety checks are unnecessary:\n        // - User has no control over previous tx. If somebody send money in same tx\n        //   as unspendable output, we still want user able to spend money\n        // - We still want some checks to notify user about possible errors early\n        //   in case user wants to use wrong input by mistake\n        // - Worst case: tx will be rejected by nodes. Still better than disallowing user\n        //   to spend real input, no matter how broken it looks\n        const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo), {\n            allowUnknownOutputs: true,\n            disableScriptCheck: true,\n            allowUnknownInputs: true,\n        });\n        const txid = hex.encode(i.txid);\n        // PSBTv2 vectors have non-final tx in inputs\n        if (tx.isFinal && tx.id !== txid)\n            throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n    }\n    return i;\n});\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n    if (o.bip32Derivation)\n        for (const [k] of o.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n    const version = g.version || 0;\n    if (version === 0) {\n        if (!g.unsignedTx)\n            throw new Error('PSBTv0: missing unsignedTx');\n        if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses)\n            throw new Error('PSBTv0: witness in unsingedTx');\n        for (const inp of g.unsignedTx.inputs)\n            if (inp.finalScriptSig && inp.finalScriptSig.length)\n                throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n    }\n    return g;\n});\nexport const _RawPSBTV0 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n    outputs: P.array(null, PSBTOutputCoder),\n});\nexport const _RawPSBTV2 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/inputCount', PSBTInputCoder),\n    outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\nexport const _DebugPSBT = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict())),\n});\nfunction validatePSBTFields(version, info, lst) {\n    for (const k in lst) {\n        if (k === 'unknown')\n            continue;\n        if (!info[k])\n            continue;\n        const { allowInc } = PSBTKeyInfo(info[k]);\n        if (!allowInc.includes(version))\n            throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n    }\n    for (const k in info) {\n        const { reqInc } = PSBTKeyInfo(info[k]);\n        if (reqInc.includes(version) && lst[k] === undefined)\n            throw new Error(`PSBTv${version}: missing required field ${k}`);\n    }\n}\nfunction cleanPSBTFields(version, info, lst) {\n    const out = {};\n    for (const _k in lst) {\n        const k = _k;\n        if (k !== 'unknown') {\n            if (!info[k])\n                continue;\n            const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n            if (!allowInc.includes(version)) {\n                if (silentIgnore)\n                    continue;\n                throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n            }\n        }\n        out[k] = lst[k];\n    }\n    return out;\n}\nfunction validatePSBT(tx) {\n    const version = (tx && tx.global && tx.global.version) || 0;\n    validatePSBTFields(version, PSBTGlobal, tx.global);\n    for (const i of tx.inputs)\n        validatePSBTFields(version, PSBTInput, i);\n    for (const o of tx.outputs)\n        validatePSBTFields(version, PSBTOutput, o);\n    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n    const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n    if (tx.inputs.length < inputCount)\n        throw new Error('Not enough inputs');\n    const inputsLeft = tx.inputs.slice(inputCount);\n    if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n        throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n    // Same for inputs\n    const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n    if (tx.outputs.length < outputCount)\n        throw new Error('Not outputs inputs');\n    const outputsLeft = tx.outputs.slice(outputCount);\n    if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n        throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n    return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n    const res = { ...cur, ...val };\n    // All arguments can be provided as hex\n    for (const k in psbtEnum) {\n        const key = k;\n        const [_, kC, vC] = psbtEnum[key];\n        const cannotChange = allowedFields && !allowedFields.includes(k);\n        if (val[k] === undefined && k in val) {\n            if (cannotChange)\n                throw new Error(`Cannot remove signed field=${k}`);\n            delete res[k];\n        }\n        else if (kC) {\n            const oldKV = (cur && cur[k] ? cur[k] : []);\n            let newKV = val[key];\n            if (newKV) {\n                if (!Array.isArray(newKV))\n                    throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                // Decode hex in k-v\n                newKV = newKV.map((val) => {\n                    if (val.length !== 2)\n                        throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                    return [\n                        typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n                        typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n                    ];\n                });\n                const map = {};\n                const add = (kStr, k, v) => {\n                    if (map[kStr] === undefined) {\n                        map[kStr] = [k, v];\n                        return;\n                    }\n                    const oldVal = hex.encode(vC.encode(map[kStr][1]));\n                    const newVal = hex.encode(vC.encode(v));\n                    if (oldVal !== newVal)\n                        throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n                };\n                for (const [k, v] of oldKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    add(kStr, k, v);\n                }\n                for (const [k, v] of newKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    // undefined removes previous value\n                    if (v === undefined) {\n                        if (cannotChange)\n                            throw new Error(`Cannot remove signed field=${key}/${k}`);\n                        delete map[kStr];\n                    }\n                    else\n                        add(kStr, k, v);\n                }\n                res[key] = Object.values(map);\n            }\n        }\n        else if (typeof res[k] === 'string') {\n            res[k] = vC.decode(hex.decode(res[k]));\n        }\n        else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n            if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n                throw new Error(`Cannot change signed field=${k}`);\n        }\n    }\n    // Remove unknown keys\n    for (const k in res)\n        if (!psbtEnum[k])\n            delete res[k];\n    return res;\n}\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\nconst OutPK = {\n    encode(from) {\n        if (from.length !== 2 ||\n            !isBytes(from[0]) ||\n            !isValidPubkey(from[0], PubT.ecdsa) ||\n            from[1] !== 'CHECKSIG')\n            return;\n        return { type: 'pk', pubkey: from[0] };\n    },\n    decode: (to) => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n// @ts-ignore\nexport const p2pk = (pubkey, network = NETWORK) => {\n    // network is unused\n    if (!isValidPubkey(pubkey, PubT.ecdsa))\n        throw new Error('P2PK: invalid publicKey');\n    return {\n        type: 'pk',\n        script: OutScript.encode({ type: 'pk', pubkey }),\n    };\n};\nconst OutPKH = {\n    encode(from) {\n        if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2]))\n            return;\n        if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG')\n            return;\n        return { type: 'pkh', hash: from[2] };\n    },\n    decode: (to) => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\nexport const p2pkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2PKH: invalid publicKey');\n    const hash = hash160(publicKey);\n    return {\n        type: 'pkh',\n        script: OutScript.encode({ type: 'pkh', hash }),\n        address: Address(network).encode({ type: 'pkh', hash }),\n    };\n};\nconst OutSH = {\n    encode(from) {\n        if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL')\n            return;\n        return { type: 'sh', hash: from[1] };\n    },\n    decode: (to) => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\nexport const p2sh = (child, network = NETWORK) => {\n    // It is already tested inside noble-hashes and checkScript\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n    const hash = hash160(cs);\n    const script = OutScript.encode({ type: 'sh', hash });\n    checkScript(script, cs, child.witnessScript);\n    const res = {\n        type: 'sh',\n        redeemScript: cs,\n        script: OutScript.encode({ type: 'sh', hash }),\n        address: Address(network).encode({ type: 'sh', hash }),\n    };\n    if (child.witnessScript)\n        res.witnessScript = child.witnessScript;\n    return res;\n};\nconst OutWSH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 32)\n            return;\n        return { type: 'wsh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\nexport const p2wsh = (child, network = NETWORK) => {\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n    const hash = sha256(cs);\n    const script = OutScript.encode({ type: 'wsh', hash });\n    checkScript(script, undefined, cs);\n    return {\n        type: 'wsh',\n        witnessScript: cs,\n        script: OutScript.encode({ type: 'wsh', hash }),\n        address: Address(network).encode({ type: 'wsh', hash }),\n    };\n};\nconst OutWPKH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 20)\n            return;\n        return { type: 'wpkh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\nexport const p2wpkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2WPKH: invalid publicKey');\n    if (publicKey.length === 65)\n        throw new Error('P2WPKH: uncompressed public key');\n    const hash = hash160(publicKey);\n    return {\n        type: 'wpkh',\n        script: OutScript.encode({ type: 'wpkh', hash }),\n        address: Address(network).encode({ type: 'wpkh', hash }),\n    };\n};\nconst OutMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKMULTISIG')\n            return;\n        const m = from[0];\n        const n = from[last - 1];\n        if (typeof m !== 'number' || typeof n !== 'number')\n            return;\n        const pubkeys = from.slice(1, -2);\n        if (n !== pubkeys.length)\n            return;\n        for (const pub of pubkeys)\n            if (!isBytes(pub))\n                return;\n        return { type: 'ms', m, pubkeys: pubkeys }; // we don't need n, since it is the same as pubkeys\n    },\n    // checkmultisig(n, ..pubkeys, m)\n    decode: (to) => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\nexport const p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return { type: 'ms', script: OutScript.encode({ type: 'ms', pubkeys, m }) };\n};\nconst OutTR = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1]))\n            return;\n        return { type: 'tr', pubkey: from[1] };\n    },\n    decode: (to) => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n    // Clone input in order to not corrupt it\n    const lst = Array.from(taprootList);\n    // We have at least 2 elements => can create branch\n    while (lst.length >= 2) {\n        // Sort: elements with smallest weight are in the end of queue\n        lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n        const b = lst.pop();\n        const a = lst.pop();\n        const weight = (a?.weight || 1) + (b?.weight || 1);\n        lst.push({\n            weight,\n            // Unwrap children array\n            // TODO: Very hard to remove any here\n            childs: [a?.childs || a, b?.childs || b],\n        });\n    }\n    // At this point there is always 1 element in lst\n    const last = lst[0];\n    return (last?.childs || last);\n}\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false) {\n    const out = OutScript.decode(script);\n    if (out.type === 'unknown' && allowUnknownOutputs)\n        return;\n    if (!['tr_ns', 'tr_ms'].includes(out.type))\n        throw new Error(`P2TR: invalid leaf script=${out.type}`);\n    const outms = out;\n    if (!allowUnknownOutputs && outms.pubkeys) {\n        for (const p of outms.pubkeys) {\n            if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY))\n                throw new Error('Unspendable taproot key in leaf script');\n            // It's likely a mistake at this point:\n            // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n            // but will take more space and fees.\n            // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n            // User creates 2 of 3 multisig of keys [A, B, C],\n            // but key A always can spend whole output without signatures from other keys.\n            // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n            if (P.equalBytes(p, internalPubKey)) {\n                throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n            }\n        }\n    }\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false) {\n    if (!tree)\n        throw new Error('taprootHashTree: empty tree');\n    if (Array.isArray(tree) && tree.length === 1)\n        tree = tree[0];\n    // Terminal node (leaf)\n    if (!Array.isArray(tree)) {\n        const { leafVersion: version, script: leafScript } = tree;\n        // Earliest tree walk where we can validate tapScripts\n        if (tree.tapLeafScript || (tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n            throw new Error('P2TR: tapRoot leafScript cannot have tree');\n        const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n        if (!isBytes(script))\n            throw new Error(`checkScript: wrong script type=${script}`);\n        checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n        return {\n            type: 'leaf',\n            version,\n            script,\n            hash: tapLeafHash(script, version),\n        };\n    }\n    // If tree / branch is not binary tree, convert it\n    if (tree.length !== 2)\n        tree = taprootListToTree(tree);\n    if (tree.length !== 2)\n        throw new Error('hashTree: non binary tree!');\n    // branch\n    // Both nodes should exist\n    const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n    const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n    // We cannot swap left/right here, since it will change structure of tree\n    let [lH, rH] = [left.hash, right.hash];\n    if (_cmpBytes(rH, lH) === -1)\n        [lH, rH] = [rH, lH];\n    return { type: 'branch', left, right, hash: schnorr.utils.taggedHash('TapBranch', lH, rH) };\n}\nfunction taprootAddPath(tree, path = []) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return { ...tree, path };\n    if (tree.type !== 'branch')\n        throw new Error(`taprootAddPath: wrong type=${tree}`);\n    return {\n        ...tree,\n        path,\n        // Left element has right hash in path and otherwise\n        left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n        right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n    };\n}\nfunction taprootWalkTree(tree) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return [tree];\n    if (tree.type !== 'branch')\n        throw new Error(`taprootWalkTree: wrong type=${tree}`);\n    return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree, network = NETWORK, allowUnknownOutputs = false) {\n    // Unspendable\n    if (!internalPubKey && !tree)\n        throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n    const pubKey = typeof internalPubKey === 'string'\n        ? hex.decode(internalPubKey)\n        : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n    if (!isValidPubkey(pubKey, PubT.schnorr))\n        throw new Error('p2tr: non-schnorr pubkey');\n    let hashedTree = tree\n        ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs))\n        : undefined;\n    const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n    const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n    let leaves;\n    if (hashedTree) {\n        leaves = taprootWalkTree(hashedTree).map((l) => ({\n            ...l,\n            controlBlock: TaprootControlBlock.encode({\n                version: (l.version || TAP_LEAF_VERSION) + parity,\n                internalKey: pubKey,\n                merklePath: l.path,\n            }),\n        }));\n    }\n    let tapLeafScript;\n    if (leaves) {\n        tapLeafScript = leaves.map((l) => [\n            TaprootControlBlock.decode(l.controlBlock),\n            concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n        ]);\n    }\n    const res = {\n        type: 'tr',\n        script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n        address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n        // For tests\n        tweakedPubkey,\n        // PSBT stuff\n        tapInternalKey: pubKey,\n    };\n    // Just in case someone would want to select a specific script\n    if (leaves)\n        res.leaves = leaves;\n    if (tapLeafScript)\n        res.tapLeafScript = tapLeafScript;\n    if (tapMerkleRoot)\n        res.tapMerkleRoot = tapMerkleRoot;\n    return res;\n}\nconst OutTRNS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        // On error return, since it can be different script\n        for (let i = 0; i < last; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== 'CHECKSIGVERIFY' || i === last - 1)\n                    return;\n                continue;\n            }\n            if (!isBytes(elm))\n                return;\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ns', pubkeys };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ns')\n            return;\n        const out = [];\n        for (let i = 0; i < to.pubkeys.length - 1; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n        out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n        return out;\n    },\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n    const res = [];\n    if (!Array.isArray(list))\n        throw new Error('combinations: lst arg should be array');\n    const n = list.length;\n    if (m > n)\n        throw new Error('combinations: m > lst.length, no combinations possible');\n    /*\n    Basically works as M nested loops like:\n    for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n    but since we cannot create nested loops dynamically, we unroll it to a single loop\n    */\n    const idx = Array.from({ length: m }, (_, i) => i);\n    const last = idx.length - 1;\n    main: for (;;) {\n        res.push(idx.map((i) => list[i]));\n        idx[last] += 1;\n        let i = last;\n        // Propagate increment\n        // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n        for (; i >= 0 && idx[i] > n - m + i; i--) {\n            idx[i] = 0;\n            // Overflow in idx[0], break\n            if (i === 0)\n                break main;\n            idx[i - 1] += 1;\n        }\n        // Propagate: idx[i+1] = idx[idx]+1\n        for (i += 1; i < idx.length; i++)\n            idx[i] = idx[i - 1] + 1;\n    }\n    return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return combinations(m, pubkeys).map((i) => ({\n        type: 'tr_ns',\n        script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n    }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = (pubkey) => p2tr_ns(1, [pubkey], undefined)[0];\nconst OutTRMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        const m = OpToNum(from[last - 1]);\n        if (typeof m !== 'number')\n            return;\n        for (let i = 0; i < last - 1; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n                    throw new Error('OutScript.encode/tr_ms: wrong element');\n                continue;\n            }\n            if (!isBytes(elm))\n                throw new Error('OutScript.encode/tr_ms: wrong key element');\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ms', pubkeys, m };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ms')\n            return;\n        const out = [to.pubkeys[0], 'CHECKSIG'];\n        for (let i = 1; i < to.pubkeys.length; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGADD');\n        out.push(to.m, 'NUMEQUAL');\n        return out;\n    },\n};\nexport function p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return {\n        type: 'tr_ms',\n        script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n    };\n}\nconst OutUnknown = {\n    encode(from) {\n        return { type: 'unknown', script: Script.encode(from) };\n    },\n    decode: (to) => to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\nconst OutScripts = [\n    OutPK,\n    OutPKH,\n    OutSH,\n    OutWSH,\n    OutWPKH,\n    OutMS,\n    OutTR,\n    OutTRNS,\n    OutTRMS,\n    OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, (i) => {\n    if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa))\n        throw new Error('OutScript/pk: wrong key');\n    if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n        (!isBytes(i.hash) || i.hash.length !== 20))\n        throw new Error(`OutScript/${i.type}: wrong hash`);\n    if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32))\n        throw new Error(`OutScript/wsh: wrong hash`);\n    if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr)))\n        throw new Error('OutScript/tr: wrong taproot public key');\n    if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n        if (!Array.isArray(i.pubkeys))\n            throw new Error('OutScript/multisig: wrong pubkeys array');\n    if (i.type === 'ms') {\n        const n = i.pubkeys.length;\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.ecdsa))\n                throw new Error('OutScript/multisig: wrong pubkey');\n        if (i.m <= 0 || n > 16 || i.m > n)\n            throw new Error('OutScript/multisig: invalid params');\n    }\n    if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.schnorr))\n                throw new Error(`OutScript/${i.type}: wrong pubkey`);\n    }\n    if (i.type === 'tr_ms') {\n        const n = i.pubkeys.length;\n        if (i.m <= 0 || n > 999 || i.m > n)\n            throw new Error('OutScript/tr_ms: invalid params');\n    }\n    return i;\n});\n// Address\nfunction validateWitness(version, data) {\n    if (data.length < 2 || data.length > 40)\n        throw new Error('Witness: invalid length');\n    if (version > 16)\n        throw new Error('Witness: invalid version');\n    if (version === 0 && !(data.length === 20 || data.length === 32))\n        throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data, network = NETWORK) {\n    validateWitness(version, data);\n    const coder = version === 0 ? bech32 : bech32m;\n    return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n    return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF(network = NETWORK) {\n    return {\n        encode(privKey) {\n            const compressed = concat(privKey, new Uint8Array([0x01]));\n            return formatKey(compressed.subarray(0, 33), [network.wif]);\n        },\n        decode(wif) {\n            let parsed = base58check.decode(wif);\n            if (parsed[0] !== network.wif)\n                throw new Error('Wrong WIF prefix');\n            parsed = parsed.subarray(1);\n            // Check what it is. Compressed flag?\n            if (parsed.length !== 33)\n                throw new Error('Wrong WIF length');\n            if (parsed[32] !== 0x01)\n                throw new Error('Wrong WIF postfix');\n            return parsed.subarray(0, -1);\n        },\n    };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n    return {\n        encode(from) {\n            const { type } = from;\n            if (type === 'wpkh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'wsh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'tr')\n                return programToWitness(1, from.pubkey, network);\n            else if (type === 'pkh')\n                return formatKey(from.hash, [network.pubKeyHash]);\n            else if (type === 'sh')\n                return formatKey(from.hash, [network.scriptHash]);\n            throw new Error(`Unknown address type=${type}`);\n        },\n        decode(address) {\n            if (address.length < 14 || address.length > 74)\n                throw new Error('Invalid address length');\n            // Bech32\n            if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n                let res;\n                try {\n                    res = bech32.decode(address);\n                    if (res.words[0] !== 0)\n                        throw new Error(`bech32: wrong version=${res.words[0]}`);\n                }\n                catch (_) {\n                    // Starting from version 1 it is decoded as bech32m\n                    res = bech32m.decode(address);\n                    if (res.words[0] === 0)\n                        throw new Error(`bech32m: wrong version=${res.words[0]}`);\n                }\n                if (res.prefix !== network.bech32)\n                    throw new Error(`wrong bech32 prefix=${res.prefix}`);\n                const [version, ...program] = res.words;\n                const data = bech32.fromWords(program);\n                validateWitness(version, data);\n                if (version === 0 && data.length === 32)\n                    return { type: 'wsh', hash: data };\n                else if (version === 0 && data.length === 20)\n                    return { type: 'wpkh', hash: data };\n                else if (version === 1 && data.length === 32)\n                    return { type: 'tr', pubkey: data };\n                else\n                    throw new Error('Unknown witness program');\n            }\n            const data = base58check.decode(address);\n            if (data.length !== 21)\n                throw new Error('Invalid base58 address');\n            // Pay To Public Key Hash\n            if (data[0] === network.pubKeyHash) {\n                return { type: 'pkh', hash: data.slice(1) };\n            }\n            else if (data[0] === network.scriptHash) {\n                return {\n                    type: 'sh',\n                    hash: data.slice(1),\n                };\n            }\n            throw new Error(`Invalid address prefix=${data[0]}`);\n        },\n    };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n    SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n    SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n    SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n    SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n    SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n    SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n    SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n    SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n    SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n    if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n        throw new Error(`Invalid SigHash=${s}`);\n    return s;\n}\nfunction unpackSighash(hashType) {\n    const masked = hashType & 0b0011111;\n    return {\n        isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n        isNone: masked === SignatureHash.NONE,\n        isSingle: masked === SignatureHash.SINGLE,\n    };\n}\nexport const _sortPubkeys = (pubkeys) => Array.from(pubkeys).sort(_cmpBytes);\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n    if (i.txid === undefined || i.index === undefined)\n        throw new Error('Transaction/input: txid and index required');\n    return {\n        txid: i.txid,\n        index: i.index,\n        sequence: def(i.sequence, DEFAULT_SEQUENCE),\n        finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n    };\n}\nfunction cleanFinalInput(i) {\n    for (const _k in i) {\n        const k = _k;\n        if (!PSBTInputFinalKeys.includes(k))\n            delete i[k];\n    }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n    if (i.script === undefined || i.amount === undefined)\n        throw new Error('Transaction/output: script and amount required');\n    return { script: i.script, amount: i.amount };\n}\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script, version = TAP_LEAF_VERSION) => schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n    if (P.equalBytes(internalKey, pubKey)) {\n        privKey = taprootTweakPrivKey(privKey, merkleRoot);\n        pubKey = schnorr.getPublicKey(privKey);\n    }\n    return { privKey, pubKey };\n}\nconst toStr = {}.toString;\nfunction validateOpts(opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error(`Wrong object type for transaction options: ${opts}`);\n    const _opts = {\n        ...opts,\n        // Defaults\n        version: def(opts.version, DEFAULT_VERSION),\n        lockTime: def(opts.lockTime, 0),\n        PSBTVersion: def(opts.PSBTVersion, 0),\n    };\n    if (typeof _opts.allowUnknowInput !== 'undefined')\n        opts.allowUnknownInputs = _opts.allowUnknowInput;\n    if (typeof _opts.allowUnknowOutput !== 'undefined')\n        opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n    // 0 and -1 happens in tests\n    if (![-1, 0, 1, 2].includes(_opts.version))\n        throw new Error(`Unknown version: ${_opts.version}`);\n    if (typeof _opts.lockTime !== 'number')\n        throw new Error('Transaction lock time should be number');\n    P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n    // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n    // can lead to constructing broken transactions\n    if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n        throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n    // Flags\n    for (const k of [\n        'allowUnknownOutputs',\n        'allowUnknownInputs',\n        'disableScriptCheck',\n        'bip174jsCompat',\n        'allowLegacyWitnessUtxo',\n        'lowR',\n    ]) {\n        const v = _opts[k];\n        if (v === undefined)\n            continue; // optional\n        if (typeof v !== 'boolean')\n            throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n    }\n    return Object.freeze(_opts);\n}\n// Normalizes input\nfunction getPrevOut(input) {\n    if (input.nonWitnessUtxo) {\n        if (input.index === undefined)\n            throw new Error('Unknown input index');\n        return input.nonWitnessUtxo.outputs[input.index];\n    }\n    else if (input.witnessUtxo)\n        return input.witnessUtxo;\n    else\n        throw new Error('Cannot find previous output info');\n}\nfunction normalizeInput(i, cur, allowedFields, disableScriptCheck = false) {\n    let { nonWitnessUtxo, txid } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors\n    // like hex looking string accidentally passed, however, in case of nonWitnessUtxo\n    // it is better to expect string, since constructing this complex object will be\n    // difficult for user\n    if (typeof nonWitnessUtxo === 'string')\n        nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n    if (isBytes(nonWitnessUtxo))\n        nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n    if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined)\n        nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string')\n        txid = hex.decode(txid);\n    // TODO: if we have nonWitnessUtxo, we can extract txId from here\n    if (txid === undefined)\n        txid = cur?.txid;\n    let res = { ...cur, ...i, nonWitnessUtxo, txid };\n    if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined)\n        delete res.nonWitnessUtxo;\n    if (res.sequence === undefined)\n        res.sequence = DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null)\n        delete res.tapMerkleRoot;\n    res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n    PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined)\n        prevOut = res.nonWitnessUtxo.outputs[res.index];\n    else if (res.witnessUtxo)\n        prevOut = res.witnessUtxo;\n    if (prevOut && !disableScriptCheck)\n        checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n    return res;\n}\nfunction getInputType(input, allowLegacyWitnessUtxo = false) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = getPrevOut(input);\n    const first = OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n        defaultSighash = SignatureHash.DEFAULT;\n        return {\n            txType: 'taproot',\n            type: 'tr',\n            last: first,\n            lastScript: prevOut.script,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n    }\n    else {\n        if (first.type === 'wpkh' || first.type === 'wsh')\n            txType = 'segwit';\n        if (first.type === 'sh') {\n            if (!input.redeemScript)\n                throw new Error('inputType: sh without redeemScript');\n            let child = OutScript.decode(input.redeemScript);\n            if (child.type === 'wpkh' || child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        // wsh can be inside sh\n        if (cur.type === 'wsh') {\n            if (!input.witnessScript)\n                throw new Error('inputType: wsh without witnessScript');\n            let child = OutScript.decode(input.witnessScript);\n            if (child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        const last = stack[stack.length - 1];\n        if (last.type === 'sh' || last.type === 'wsh')\n            throw new Error('inputType: sh/wsh cannot be terminal type');\n        const lastScript = OutScript.encode(last);\n        const res = {\n            type,\n            txType,\n            last,\n            lastScript,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n        if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n            throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n        }\n        return res;\n    }\n}\nconst toVsize = (weight) => Math.ceil(weight / 4);\nexport class Transaction {\n    constructor(opts = {}) {\n        this.global = {};\n        this.inputs = []; // use getInput()\n        this.outputs = []; // use getOutput()\n        const _opts = (this.opts = validateOpts(opts));\n        // Merge with global structure of PSBTv2\n        if (_opts.lockTime !== DEFAULT_LOCKTIME)\n            this.global.fallbackLocktime = _opts.lockTime;\n        this.global.txVersion = _opts.version;\n    }\n    // Import\n    static fromRaw(raw, opts = {}) {\n        const parsed = RawTx.decode(raw);\n        const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n        for (const o of parsed.outputs)\n            tx.addOutput(o);\n        tx.outputs = parsed.outputs;\n        tx.inputs = parsed.inputs;\n        if (parsed.witnesses) {\n            for (let i = 0; i < parsed.witnesses.length; i++)\n                tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n        }\n        return tx;\n    }\n    // PSBT\n    static fromPSBT(psbt, opts = {}) {\n        let parsed;\n        try {\n            parsed = RawPSBTV0.decode(psbt);\n        }\n        catch (e0) {\n            try {\n                parsed = RawPSBTV2.decode(psbt);\n            }\n            catch (e2) {\n                // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n                throw e0;\n            }\n        }\n        const PSBTVersion = parsed.global.version || 0;\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const unsigned = parsed.global.unsignedTx;\n        const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n        const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n        const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n        // We need slice here, because otherwise\n        const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n        tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n            finalScriptSig: P.EMPTY,\n            ...parsed.global.unsignedTx?.inputs[j],\n            ...i,\n        }));\n        const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n        tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n            ...i,\n            ...parsed.global.unsignedTx?.outputs[j],\n        }));\n        tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n        if (lockTime !== DEFAULT_LOCKTIME)\n            tx.global.fallbackLocktime = lockTime;\n        return tx;\n    }\n    toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const inputs = this.inputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n        for (const inp of inputs) {\n            // Don't serialize empty fields\n            if (inp.partialSig && !inp.partialSig.length)\n                delete inp.partialSig;\n            if (inp.finalScriptSig && !inp.finalScriptSig.length)\n                delete inp.finalScriptSig;\n            if (inp.finalScriptWitness && !inp.finalScriptWitness.length)\n                delete inp.finalScriptWitness;\n        }\n        const outputs = this.outputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n        const global = { ...this.global };\n        if (PSBTVersion === 0) {\n            global.unsignedTx = RawTx.decode(this.unsignedTx);\n            delete global.fallbackLocktime;\n            delete global.txVersion;\n        }\n        else {\n            global.version = PSBTVersion;\n            global.txVersion = this.version;\n            global.inputCount = this.inputs.length;\n            global.outputCount = this.outputs.length;\n            if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n                delete global.fallbackLocktime;\n        }\n        if (this.opts.bip174jsCompat) {\n            if (!inputs.length)\n                inputs.push({});\n            if (!outputs.length)\n                outputs.push({});\n        }\n        return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n            global,\n            inputs,\n            outputs,\n        });\n    }\n    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n    get lockTime() {\n        let height = DEFAULT_LOCKTIME;\n        let heightCnt = 0;\n        let time = DEFAULT_LOCKTIME;\n        let timeCnt = 0;\n        for (const i of this.inputs) {\n            if (i.requiredHeightLocktime) {\n                height = Math.max(height, i.requiredHeightLocktime);\n                heightCnt++;\n            }\n            if (i.requiredTimeLocktime) {\n                time = Math.max(time, i.requiredTimeLocktime);\n                timeCnt++;\n            }\n        }\n        if (heightCnt && heightCnt >= timeCnt)\n            return height;\n        if (time !== DEFAULT_LOCKTIME)\n            return time;\n        return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n    }\n    get version() {\n        // Should be not possible\n        if (this.global.txVersion === undefined)\n            throw new Error('No global.txVersion');\n        return this.global.txVersion;\n    }\n    inputStatus(idx) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        // Finalized\n        if (input.finalScriptSig && input.finalScriptSig.length)\n            return 'finalized';\n        if (input.finalScriptWitness && input.finalScriptWitness.length)\n            return 'finalized';\n        // Signed taproot\n        if (input.tapKeySig)\n            return 'signed';\n        if (input.tapScriptSig && input.tapScriptSig.length)\n            return 'signed';\n        // Signed\n        if (input.partialSig && input.partialSig.length)\n            return 'signed';\n        return 'unsigned';\n    }\n    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n    // We will lose some vectors -> smaller test coverage of preimages (very important!)\n    inputSighash(idx) {\n        this.checkInputIdx(idx);\n        const sighash = getInputType(this.inputs[idx], this.opts.allowLegacyWitnessUtxo).sighash;\n        // ALL or DEFAULT -- everything signed\n        // NONE           -- all inputs + no outputs\n        // SINGLE         -- all inputs + output with same index\n        // ALL + ANYONE   -- specific input + all outputs\n        // NONE + ANYONE  -- specific input + no outputs\n        // SINGLE         -- specific inputs + output with same index\n        const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n        const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n        return { sigInputs, sigOutputs };\n    }\n    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n    // Some cache will be nice, but there chance to have bugs with cache invalidation\n    signStatus() {\n        // if addInput or addOutput is not possible, then all inputs or outputs are signed\n        let addInput = true, addOutput = true;\n        let inputs = [], outputs = [];\n        for (let idx = 0; idx < this.inputs.length; idx++) {\n            const status = this.inputStatus(idx);\n            // Unsigned input doesn't affect anything\n            if (status === 'unsigned')\n                continue;\n            const { sigInputs, sigOutputs } = this.inputSighash(idx);\n            // Input type\n            if (sigInputs === SignatureHash.ANYONECANPAY)\n                inputs.push(idx);\n            else\n                addInput = false;\n            // Output type\n            if (sigOutputs === SignatureHash.ALL)\n                addOutput = false;\n            else if (sigOutputs === SignatureHash.SINGLE)\n                outputs.push(idx);\n            else if (sigOutputs === SignatureHash.NONE) {\n                // Doesn't affect any outputs at all\n            }\n            else\n                throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n        }\n        return { addInput, addOutput, inputs, outputs };\n    }\n    get isFinal() {\n        for (let idx = 0; idx < this.inputs.length; idx++)\n            if (this.inputStatus(idx) !== 'finalized')\n                return false;\n        return true;\n    }\n    // Info utils\n    get hasWitnesses() {\n        let out = false;\n        for (const i of this.inputs)\n            if (i.finalScriptWitness && i.finalScriptWitness.length)\n                out = true;\n        return out;\n    }\n    // https://en.bitcoin.it/wiki/Weight_units\n    get weight() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        let out = 32;\n        // Outputs\n        const outputs = this.outputs.map(outputBeforeSign);\n        out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n        for (const o of outputs)\n            out += 32 + 4 * VarBytes.encode(o.script).length;\n        // Inputs\n        if (this.hasWitnesses)\n            out += 2;\n        out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n        for (const i of this.inputs) {\n            out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n            if (this.hasWitnesses && i.finalScriptWitness)\n                out += RawWitness.encode(i.finalScriptWitness).length;\n        }\n        return out;\n    }\n    get vsize() {\n        return toVsize(this.weight);\n    }\n    toBytes(withScriptSig = false, withWitness = false) {\n        return RawTx.encode({\n            version: this.version,\n            lockTime: this.lockTime,\n            inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n                ...i,\n                finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n            })),\n            outputs: this.outputs.map(outputBeforeSign),\n            witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n            segwitFlag: withWitness && this.hasWitnesses,\n        });\n    }\n    get unsignedTx() {\n        return this.toBytes(false, false);\n    }\n    get hex() {\n        return hex.encode(this.toBytes(true, this.hasWitnesses));\n    }\n    get hash() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)));\n    }\n    get id() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)).reverse());\n    }\n    // Input stuff\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n    }\n    getInput(idx) {\n        this.checkInputIdx(idx);\n        return cloneDeep(this.inputs[idx]);\n    }\n    get inputsLength() {\n        return this.inputs.length;\n    }\n    // Modification\n    addInput(input, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addInput)\n            throw new Error('Tx has signed inputs, cannot add new one');\n        this.inputs.push(normalizeInput(input, undefined, undefined, this.opts.disableScriptCheck));\n        return this.inputs.length - 1;\n    }\n    updateInput(idx, input, _ignoreSignStatus = false) {\n        this.checkInputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addInput || status.inputs.includes(idx))\n                allowedFields = PSBTInputUnsignedKeys;\n        }\n        this.inputs[idx] = normalizeInput(input, this.inputs[idx], allowedFields, this.opts.disableScriptCheck);\n    }\n    // Output stuff\n    checkOutputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n            throw new Error(`Wrong output index=${idx}`);\n    }\n    getOutput(idx) {\n        this.checkOutputIdx(idx);\n        return cloneDeep(this.outputs[idx]);\n    }\n    get outputsLength() {\n        return this.outputs.length;\n    }\n    normalizeOutput(o, cur, allowedFields) {\n        let { amount, script } = o;\n        if (amount === undefined)\n            amount = cur?.amount;\n        if (typeof amount !== 'bigint')\n            throw new Error('amount must be bigint sats');\n        if (typeof script === 'string')\n            script = hex.decode(script);\n        if (script === undefined)\n            script = cur?.script;\n        let res = { ...cur, ...o, amount, script };\n        if (res.amount === undefined)\n            delete res.amount;\n        res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n        PSBTOutputCoder.encode(res);\n        if (res.script &&\n            !this.opts.allowUnknownOutputs &&\n            OutScript.decode(res.script).type === 'unknown') {\n            throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n        }\n        if (!this.opts.disableScriptCheck)\n            checkScript(res.script, res.redeemScript, res.witnessScript);\n        return res;\n    }\n    addOutput(o, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addOutput)\n            throw new Error('Tx has signed outputs, cannot add new one');\n        this.outputs.push(this.normalizeOutput(o));\n        return this.outputs.length - 1;\n    }\n    updateOutput(idx, output, _ignoreSignStatus = false) {\n        this.checkOutputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addOutput || status.outputs.includes(idx))\n                allowedFields = PSBTOutputUnsignedKeys;\n        }\n        this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n    }\n    addOutputAddress(address, amount, network = NETWORK) {\n        return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n    }\n    // Utils\n    get fee() {\n        let res = 0n;\n        for (const i of this.inputs) {\n            const prevOut = getPrevOut(i);\n            if (!prevOut)\n                throw new Error('Empty input amount');\n            res += prevOut.amount;\n        }\n        const outputs = this.outputs.map(outputBeforeSign);\n        for (const o of outputs)\n            res -= o.amount;\n        return res;\n    }\n    // Signing\n    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n    // but we are trying to be less complicated for audit purpose for now.\n    preimageLegacy(idx, prevOutScript, hashType) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        if (idx < 0 || !Number.isSafeInteger(idx))\n            throw new Error(`Invalid input idx=${idx}`);\n        if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n            return P.U256BE.encode(1n);\n        prevOutScript = Script.encode(Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR'));\n        let inputs = this.inputs\n            .map(inputBeforeSign)\n            .map((input, inputIdx) => ({\n            ...input,\n            finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n        }));\n        if (isAny)\n            inputs = [inputs[idx]];\n        else if (isNone || isSingle) {\n            inputs = inputs.map((input, inputIdx) => ({\n                ...input,\n                sequence: inputIdx === idx ? input.sequence : 0,\n            }));\n        }\n        let outputs = this.outputs.map(outputBeforeSign);\n        if (isNone)\n            outputs = [];\n        else if (isSingle) {\n            outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n        }\n        const tmpTx = RawTx.encode({\n            lockTime: this.lockTime,\n            version: this.version,\n            segwitFlag: false,\n            inputs,\n            outputs,\n        });\n        return sha256x2(tmpTx, P.I32LE.encode(hashType));\n    }\n    preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        let inputHash = EMPTY32;\n        let sequenceHash = EMPTY32;\n        let outputHash = EMPTY32;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (!isAny)\n            inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n        if (!isAny && !isSingle && !isNone)\n            sequenceHash = sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n        if (!isSingle && !isNone) {\n            outputHash = sha256x2(...outputs.map(RawOutput.encode));\n        }\n        else if (isSingle && idx < outputs.length)\n            outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n        const input = inputs[idx];\n        return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n    }\n    preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n        if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n            throw new Error(`Invalid amounts array=${amount}`);\n        if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n            throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n        const out = [\n            P.U8.encode(0),\n            P.U8.encode(hashType), // U8 sigHash\n            P.I32LE.encode(this.version),\n            P.U32LE.encode(this.lockTime),\n        ];\n        const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n        const inType = hashType & SignatureHash.ANYONECANPAY;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (inType !== SignatureHash.ANYONECANPAY) {\n            out.push(...[\n                inputs.map(TxHashIdx.encode),\n                amount.map(P.U64LE.encode),\n                prevOutScript.map(VarBytes.encode),\n                inputs.map((i) => P.U32LE.encode(i.sequence)),\n            ].map((i) => sha256(concat(...i))));\n        }\n        if (outType === SignatureHash.ALL) {\n            out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n        }\n        const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n        out.push(new Uint8Array([spendType]));\n        if (inType === SignatureHash.ANYONECANPAY) {\n            const inp = inputs[idx];\n            out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n        }\n        else\n            out.push(P.U32LE.encode(idx));\n        if (spendType & 1)\n            out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n        if (outType === SignatureHash.SINGLE)\n            out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n        if (leafScript)\n            out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n        return schnorr.utils.taggedHash('TapSighash', ...out);\n    }\n    // Signer can be privateKey OR instance of bip32 HD stuff\n    signIdx(privateKey, idx, allowedSighash, _auxRand) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Handle BIP32 HDKey\n        if (!isBytes(privateKey)) {\n            if (!input.bip32Derivation || !input.bip32Derivation.length)\n                throw new Error('bip32Derivation: empty');\n            const signers = input.bip32Derivation\n                .filter((i) => i[1].fingerprint == privateKey.fingerprint)\n                .map(([pubKey, { path }]) => {\n                let s = privateKey;\n                for (const i of path)\n                    s = s.deriveChild(i);\n                if (!P.equalBytes(s.publicKey, pubKey))\n                    throw new Error('bip32Derivation: wrong pubKey');\n                if (!s.privateKey)\n                    throw new Error('bip32Derivation: no privateKey');\n                return s;\n            });\n            if (!signers.length)\n                throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n            let signed = false;\n            for (const s of signers)\n                if (this.signIdx(s.privateKey, idx))\n                    signed = true;\n            return signed;\n        }\n        // Sighash checks\n        // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n        if (!allowedSighash)\n            allowedSighash = [inputType.defaultSighash];\n        else\n            allowedSighash.forEach(validateSigHash);\n        const sighash = inputType.sighash;\n        if (!allowedSighash.includes(sighash)) {\n            throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n        }\n        // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n        // however this was because of bug in bitcoin-core, which remains here because of consensus.\n        // If this is absolutely neccessary for your case, please open issue.\n        // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n        const { sigOutputs } = this.inputSighash(idx);\n        if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n            throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n        }\n        // Actual signing\n        // Taproot\n        const prevOut = getPrevOut(input);\n        if (inputType.txType === 'taproot') {\n            if (input.tapBip32Derivation)\n                throw new Error('tapBip32Derivation unsupported');\n            const prevOuts = this.inputs.map(getPrevOut);\n            const prevOutScript = prevOuts.map((i) => i.script);\n            const amount = prevOuts.map((i) => i.amount);\n            let signed = false;\n            let schnorrPub = schnorr.getPublicKey(privateKey);\n            let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n            if (input.tapInternalKey) {\n                // internal + tweak = tweaked key\n                // if internal key == current public key, we need to tweak private key,\n                // otherwise sign as is. bitcoinjs implementation always wants tweaked\n                // priv key to be provided\n                const { pubKey, privKey } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n                const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n                if (P.equalBytes(taprootPubKey, pubKey)) {\n                    const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n                    const sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapKeySig: sig }, true);\n                    signed = true;\n                }\n            }\n            if (input.tapLeafScript) {\n                input.tapScriptSig = input.tapScriptSig || [];\n                for (const [_, _script] of input.tapLeafScript) {\n                    const script = _script.subarray(0, -1);\n                    const scriptDecoded = Script.decode(script);\n                    const ver = _script[_script.length - 1];\n                    const hash = tapLeafHash(script, ver);\n                    // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n                    const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, schnorrPub));\n                    // Skip if there is no public key in tapLeafScript\n                    if (pos === -1)\n                        continue;\n                    const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n                    const sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] }, true);\n                    signed = true;\n                }\n            }\n            if (!signed)\n                throw new Error('No taproot scripts signed');\n            return true;\n        }\n        else {\n            // only compressed keys are supported for now\n            const pubKey = _pubECDSA(privateKey);\n            // TODO: replace with explicit checks\n            // Check if script has public key or its has inside\n            let hasPubkey = false;\n            const pubKeyHash = hash160(pubKey);\n            for (const i of Script.decode(inputType.lastScript)) {\n                if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash)))\n                    hasPubkey = true;\n            }\n            if (!hasPubkey)\n                throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n            let hash;\n            if (inputType.txType === 'legacy') {\n                hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n            }\n            else if (inputType.txType === 'segwit') {\n                let script = inputType.lastScript;\n                // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n                if (inputType.last.type === 'wpkh')\n                    script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n                hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n            }\n            else\n                throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n            const sig = signECDSA(hash, privateKey, this.opts.lowR);\n            this.updateInput(idx, {\n                partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]],\n            }, true);\n        }\n        return true;\n    }\n    // This is bad API. Will work if user creates and signs tx, but if\n    // there is some complex workflow with exchanging PSBT and signing them,\n    // then it is better to validate which output user signs. How could a better API look like?\n    // Example: user adds input, sends to another party, then signs received input (mixer etc),\n    // another user can add different input for same key and user will sign it.\n    // Even worse: another user can add bip32 derivation, and spend money from different address.\n    // Better api: signIdx\n    sign(privateKey, allowedSighash, _auxRand) {\n        let num = 0;\n        for (let i = 0; i < this.inputs.length; i++) {\n            try {\n                if (this.signIdx(privateKey, i, allowedSighash, _auxRand))\n                    num++;\n            }\n            catch (e) { }\n        }\n        if (!num)\n            throw new Error('No inputs signed');\n        return num;\n    }\n    finalizeIdx(idx) {\n        this.checkInputIdx(idx);\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Taproot finalize\n        if (inputType.txType === 'taproot') {\n            if (input.tapKeySig)\n                input.finalScriptWitness = [input.tapKeySig];\n            else if (input.tapLeafScript && input.tapScriptSig) {\n                // Sort leafs by control block length.\n                const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n                for (const [cb, _script] of leafs) {\n                    // Last byte is version\n                    const script = _script.slice(0, -1);\n                    const ver = _script[_script.length - 1];\n                    const outScript = OutScript.decode(script);\n                    const hash = tapLeafHash(script, ver);\n                    const scriptSig = input.tapScriptSig.filter((i) => P.equalBytes(i[0].leafHash, hash));\n                    let signatures = [];\n                    if (outScript.type === 'tr_ms') {\n                        const m = outScript.m;\n                        const pubkeys = outScript.pubkeys;\n                        let added = 0;\n                        for (const pub of pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            // Should have exact amount of signatures (more -- will fail)\n                            if (added === m || sigIdx === -1) {\n                                signatures.push(P.EMPTY);\n                                continue;\n                            }\n                            signatures.push(scriptSig[sigIdx][1]);\n                            added++;\n                        }\n                        // Should be exact same as m\n                        if (added !== m)\n                            continue;\n                    }\n                    else if (outScript.type === 'tr_ns') {\n                        for (const pub of outScript.pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            if (sigIdx === -1)\n                                continue;\n                            signatures.push(scriptSig[sigIdx][1]);\n                        }\n                        if (signatures.length !== outScript.pubkeys.length)\n                            continue;\n                    }\n                    else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n                        // Trying our best to sign what we can\n                        const scriptDecoded = Script.decode(script);\n                        signatures = scriptSig\n                            .map(([{ pubKey }, signature]) => {\n                            const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, pubKey));\n                            if (pos === -1)\n                                throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                            return { signature, pos };\n                        })\n                            // Reverse order (because witness is stack and we take last element first from it)\n                            .sort((a, b) => a.pos - b.pos)\n                            .map((i) => i.signature);\n                        if (!signatures.length)\n                            continue;\n                    }\n                    else\n                        throw new Error('Finalize: Unknown tapLeafScript');\n                    // Witness is stack, so last element will be used first\n                    input.finalScriptWitness = signatures\n                        .reverse()\n                        .concat([script, TaprootControlBlock.encode(cb)]);\n                    break;\n                }\n                if (!input.finalScriptWitness)\n                    throw new Error('finalize/taproot: empty witness');\n            }\n            else\n                throw new Error('finalize/taproot: unknown input');\n            input.finalScriptSig = P.EMPTY;\n            cleanFinalInput(input);\n            return;\n        }\n        if (!input.partialSig || !input.partialSig.length)\n            throw new Error('Not enough partial sign');\n        let inputScript = P.EMPTY;\n        let witness = [];\n        // TODO: move input scripts closer to payments/output scripts\n        // Multisig\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const pubkeys = inputType.last.pubkeys;\n            let signatures = [];\n            // partial: [pubkey, sign]\n            for (const pub of pubkeys) {\n                const sign = input.partialSig.find((s) => P.equalBytes(pub, s[0]));\n                if (!sign)\n                    continue;\n                signatures.push(sign[1]);\n            }\n            signatures = signatures.slice(0, m);\n            if (signatures.length !== m) {\n                throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n            }\n            inputScript = Script.encode([0, ...signatures]);\n        }\n        else if (inputType.last.type === 'pk') {\n            inputScript = Script.encode([input.partialSig[0][1]]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            witness = [input.partialSig[0][1], input.partialSig[0][0]];\n        }\n        else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        // Create final scripts (generic part)\n        let finalScriptSig, finalScriptWitness;\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                witness = Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if (isBytes(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            witness = witness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            finalScriptWitness = witness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            finalScriptSig = inputScript;\n        if (!finalScriptSig && !finalScriptWitness)\n            throw new Error('Unknown error finalizing input');\n        if (finalScriptSig)\n            input.finalScriptSig = finalScriptSig;\n        if (finalScriptWitness)\n            input.finalScriptWitness = finalScriptWitness;\n        cleanFinalInput(input);\n    }\n    finalize() {\n        for (let i = 0; i < this.inputs.length; i++)\n            this.finalizeIdx(i);\n    }\n    extract() {\n        if (!this.isFinal)\n            throw new Error('Transaction has unfinalized inputs');\n        if (!this.outputs.length)\n            throw new Error('Transaction has no outputs');\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        return this.toBytes(true, true);\n    }\n    combine(other) {\n        for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n            if (this.opts[k] !== other.opts[k]) {\n                throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n            }\n        }\n        for (const k of ['inputs', 'outputs']) {\n            if (this[k].length !== other[k].length) {\n                throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n            }\n        }\n        const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n        const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n        if (!P.equalBytes(thisUnsigned, otherUnsigned))\n            throw new Error(`Transaction/combine: different unsigned tx`);\n        this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n        for (let i = 0; i < this.inputs.length; i++)\n            this.updateInput(i, other.inputs[i], true);\n        for (let i = 0; i < this.outputs.length; i++)\n            this.updateOutput(i, other.outputs[i], true);\n        return this;\n    }\n    clone() {\n        // deepClone probably faster, but this enforces that encoding is valid\n        return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);\n    }\n}\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey, network = NETWORK) {\n    if (type === 'tr') {\n        return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n    }\n    const pubKey = _pubECDSA(privKey);\n    if (type === 'pkh')\n        return p2pkh(pubKey, network).address;\n    if (type === 'wpkh')\n        return p2wpkh(pubKey, network).address;\n    throw new Error(`getAddress: unknown type=${type}`);\n}\nexport function multisig(m, pubkeys, sorted = false, witness = false) {\n    const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n    return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys, witness = false) {\n    return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n    const out = [];\n    if (!/^[mM]'?/.test(path))\n        throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(path))\n        return out;\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    for (const c of parts) {\n        const m = /^(\\d+)('?)$/.exec(c);\n        if (!m || m.length !== 3)\n            throw new Error(`Invalid child index: ${c}`);\n        let idx = +m[1];\n        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET)\n            throw new Error('Invalid index');\n        // hardened key\n        if (m[2] === \"'\")\n            idx += HARDENED_OFFSET;\n        out.push(idx);\n    }\n    return out;\n}\nexport function PSBTCombine(psbts) {\n    if (!psbts || !Array.isArray(psbts) || !psbts.length)\n        throw new Error('PSBTCombine: wrong PSBT list');\n    const tx = Transaction.fromPSBT(psbts[0]);\n    for (let i = 1; i < psbts.length; i++)\n        tx.combine(Transaction.fromPSBT(psbts[i]));\n    return tx.toPSBT();\n}\nfunction estimateInput(inputType, input, opts) {\n    let script = P.EMPTY, witness;\n    // schnorr sig is always 64 bytes. except for cases when sighash is not default!\n    if (inputType.txType === 'taproot') {\n        const SCHNORR_SIG_SIZE = inputType.sighash !== SignatureHash.DEFAULT ? 65 : 64;\n        if (input.tapInternalKey && !P.equalBytes(input.tapInternalKey, TAPROOT_UNSPENDABLE_KEY)) {\n            witness = [new Uint8Array(SCHNORR_SIG_SIZE)];\n        }\n        else if (input.tapLeafScript) {\n            // If user want to select specific leaf (which can signed, it is possible to remove all other leafs manually);\n            // Sort leafs by control block length.\n            const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n            for (const [cb, _script] of leafs) {\n                // Last byte is version\n                const script = _script.slice(0, -1);\n                const outScript = OutScript.decode(script);\n                let signatures = [];\n                if (outScript.type === 'tr_ms') {\n                    const m = outScript.m;\n                    for (let i = 0; i < m; i++)\n                        signatures.push(new Uint8Array(SCHNORR_SIG_SIZE));\n                    const n = outScript.pubkeys.length - m;\n                    for (let i = 0; i < n; i++)\n                        signatures.push(P.EMPTY);\n                }\n                else if (outScript.type === 'tr_ns') {\n                    for (const _pub of outScript.pubkeys)\n                        signatures.push(new Uint8Array(SCHNORR_SIG_SIZE));\n                }\n                else\n                    throw new Error('Finalize: Unknown tapLeafScript');\n                // Witness is stack, so last element will be used first\n                witness = signatures.reverse().concat([script, TaprootControlBlock.encode(cb)]);\n                break;\n            }\n        }\n        else\n            throw new Error('estimateInput/taproot: unknown input');\n    }\n    else {\n        // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),\n        // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).\n        const SIG_SIZE = 72; // Maximum size of signatures\n        const PUB_KEY_SIZE = 33;\n        let inputScript = P.EMPTY;\n        let inputWitness = [];\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const sig = [0];\n            for (let i = 0; i < m; i++)\n                sig.push(new Uint8Array(SIG_SIZE));\n            inputScript = Script.encode(sig);\n        }\n        else if (inputType.last.type === 'pk') {\n            // 71 sig + 1 sighash\n            inputScript = Script.encode([new Uint8Array(SIG_SIZE)]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = Script.encode([new Uint8Array(SIG_SIZE), new Uint8Array(PUB_KEY_SIZE)]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            inputWitness = [new Uint8Array(SIG_SIZE), new Uint8Array(PUB_KEY_SIZE)];\n        }\n        else if (inputType.last.type === 'unknown' && !opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                inputWitness = Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if (isBytes(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            inputWitness = inputWitness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            witness = inputWitness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            script = Script.encode([Script.encode([0, new Uint8Array(sha256.outputLen)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            script = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            script = inputScript;\n    }\n    let weight = 160 + 4 * VarBytes.encode(script).length;\n    let hasWitnesses = false;\n    if (witness) {\n        weight += RawWitness.encode(witness).length;\n        hasWitnesses = true;\n    }\n    return { weight, hasWitnesses };\n}\n// Exported for tests, internal method\nexport const _cmpBig = (a, b) => {\n    const n = a - b;\n    if (n < 0n)\n        return -1;\n    else if (n > 0n)\n        return 1;\n    return 0;\n};\nfunction getScript(o, opts = {}, network = NETWORK) {\n    let script;\n    if ('script' in o && o.script instanceof Uint8Array) {\n        script = o.script;\n    }\n    if ('address' in o) {\n        if (typeof o.address !== 'string')\n            throw new Error(`Estimator: wrong output address=${o.address}`);\n        script = OutScript.encode(Address(network).decode(o.address));\n    }\n    if (!script)\n        throw new Error('Estimator: wrong output script');\n    if (typeof o.amount !== 'bigint')\n        throw new Error(`Estimator: wrong output amount=${o.amount}`);\n    if (script && !opts.allowUnknownOutputs && OutScript.decode(script).type === 'unknown') {\n        throw new Error('Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n    }\n    if (!opts.disableScriptCheck)\n        checkScript(script);\n    return script;\n}\n// class, because we need to re-use normalized inputs, instead of parsing each time\n// internal stuff, exported for tests only\nexport class _Estimator {\n    constructor(inputs, outputs, opts) {\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.opts = opts;\n        // https://github.com/bitcoin/bitcoin/blob/f90603ac6d24f5263649675d51233f1fce8b2ecd/src/policy/policy.cpp#L44\n        // 32 + 4 + 1 + 107 + 4\n        // Dust used in accumExact + change address algo\n        // - change address: can be smaller for segwit\n        // - accumExact: ???\n        this.dust = 148n; // compat with coinselect\n        if (typeof opts.feePerByte !== 'bigint')\n            throw new Error(`Estimator: wrong feePerByte=${opts.feePerByte}`);\n        if (opts.dust) {\n            if (typeof opts.dust !== 'bigint')\n                throw new Error(`Estimator: wrong dust=${opts.dust}`);\n            this.dust = opts.dust;\n        }\n        const network = opts.network || NETWORK;\n        let amount = 0n;\n        // Base weight: tx with outputs, no inputs\n        let baseWeight = 32;\n        for (const o of outputs) {\n            const script = getScript(o, opts, opts.network);\n            baseWeight += 32 + 4 * VarBytes.encode(script).length;\n            amount += o.amount;\n        }\n        if (typeof opts.changeAddress !== 'string')\n            throw new Error(`Estimator: wrong change address=${opts.changeAddress}`);\n        let changeWeight = baseWeight +\n            32 +\n            4 * VarBytes.encode(OutScript.encode(Address(network).decode(opts.changeAddress))).length;\n        baseWeight += 4 * CompactSizeLen.encode(outputs.length).length;\n        // If there a lot of outputs change can change fee\n        changeWeight += 4 * CompactSizeLen.encode(outputs.length + 1).length;\n        this.baseWeight = baseWeight;\n        this.changeWeight = changeWeight;\n        this.amount = amount;\n        this.normalizedInputs = this.inputs.map((i) => {\n            const normalized = normalizeInput(i, undefined, undefined, opts.disableScriptCheck);\n            inputBeforeSign(normalized); // check fields\n            const inputType = getInputType(normalized, opts.allowLegacyWitnessUtxo);\n            const prev = getPrevOut(normalized);\n            const estimate = estimateInput(inputType, normalized, this.opts);\n            const value = prev.amount - opts.feePerByte * BigInt(toVsize(estimate.weight)); // value = amount-fee\n            return { inputType, normalized, amount: prev.amount, value, estimate };\n        });\n    }\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n        return idx;\n    }\n    sortIndices(indices) {\n        return indices.slice().sort((a, b) => {\n            const ai = this.normalizedInputs[this.checkInputIdx(a)];\n            const bi = this.normalizedInputs[this.checkInputIdx(b)];\n            const out = _cmpBytes(ai.normalized.txid, bi.normalized.txid);\n            if (out !== 0)\n                return out;\n            return ai.normalized.index - bi.normalized.index;\n        });\n    }\n    sortOutputs(outputs) {\n        const scripts = outputs.map((o) => getScript(o, this.opts, this.opts.network));\n        const indices = outputs.map((_, j) => j);\n        return indices.sort((a, b) => {\n            const aa = outputs[a].amount;\n            const ba = outputs[b].amount;\n            const out = _cmpBig(aa, ba);\n            if (out !== 0)\n                return out;\n            return _cmpBytes(scripts[a], scripts[b]);\n        });\n    }\n    getSatoshi(weigth) {\n        return this.opts.feePerByte * BigInt(toVsize(weigth));\n    }\n    // Sort by value instead of amount\n    get biggest() {\n        return this.inputs\n            .map((_i, j) => j)\n            .sort((a, b) => _cmpBig(this.normalizedInputs[b].value, this.normalizedInputs[a].value));\n    }\n    get smallest() {\n        return this.biggest.reverse();\n    }\n    // These assume that UTXO array has historical order.\n    // Otherwise, we have no way to know which tx is oldest\n    // Explorers usually give UTXO in this order.\n    get oldest() {\n        return this.inputs.map((_i, j) => j);\n    }\n    get newest() {\n        return this.oldest.reverse();\n    }\n    // exact - like blackjack from coinselect.\n    // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.\n    // If not, it will accumulate largest utxo until value is close to targetValue+dust.\n    accumulate(indices, exact = false, skipNegative = true, all = false) {\n        const { feePerByte } = this.opts;\n        // TODO: how to handle change addresses?\n        // - cost of input\n        // - cost of change output (if input requires change)\n        // - cost of output spending\n        // Dust threshold should be significantly bigger, no point in\n        // creating an output, which cannot be spent.\n        // coinselect doesn't consider cost of output address for dust.\n        // Changing that can actually reduce privacy\n        let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;\n        let hasWitnesses = false;\n        let num = 0;\n        let inputsAmount = 0n;\n        const targetAmount = this.amount;\n        const res = [];\n        let fee;\n        for (const idx of indices) {\n            this.checkInputIdx(idx);\n            const { estimate, amount, value } = this.normalizedInputs[idx];\n            let newWeight = weight + estimate.weight;\n            if (!hasWitnesses && estimate.hasWitnesses)\n                newWeight += 2; // enable witness if needed\n            const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n            fee = this.getSatoshi(totalWeight);\n            // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold\n            if (exact) {\n                const dust = this.dust * feePerByte;\n                // skip if added value is bigger than dust\n                if (amount + inputsAmount > targetAmount + fee + dust)\n                    continue;\n            }\n            // Negative: cost of using input is more than value provided (negative)\n            // By default 'blackjack' mode in coinselect doesn't use that, which means\n            // it will use negative output if sorted by 'smallest'\n            if (skipNegative && value <= 0n)\n                continue;\n            weight = newWeight;\n            if (estimate.hasWitnesses)\n                hasWitnesses = true;\n            num++;\n            inputsAmount += amount;\n            res.push(idx);\n            // inputsAmount is enough to cover cost of tx\n            if (!all && targetAmount + fee < inputsAmount)\n                return { indices: res, fee, weight: totalWeight, total: inputsAmount };\n        }\n        if (all) {\n            const newWeight = weight + 4 * CompactSizeLen.encode(num).length;\n            return { indices: res, fee, weight: newWeight, total: inputsAmount };\n        }\n        return undefined;\n    }\n    // Works like coinselect default method\n    default() {\n        const { biggest } = this;\n        const exact = this.accumulate(biggest, true, false);\n        if (exact)\n            return exact;\n        return this.accumulate(biggest);\n    }\n    select(strategy) {\n        if (strategy === 'all') {\n            return this.accumulate(this.inputs.map((_, j) => j), false, true, true);\n        }\n        if (strategy === 'default')\n            return this.default();\n        const data = {\n            Oldest: () => this.oldest,\n            Newest: () => this.newest,\n            Smallest: () => this.smallest,\n            Biggest: () => this.biggest,\n        };\n        if (strategy.startsWith('exact')) {\n            const [exactData, left] = strategy.slice(5).split('/');\n            if (!data[exactData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            strategy = left;\n            const exact = this.accumulate(data[exactData](), true, true);\n            if (exact)\n                return exact;\n        }\n        if (strategy.startsWith('accum')) {\n            const accumData = strategy.slice(5);\n            if (!data[accumData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            return this.accumulate(data[accumData]());\n        }\n        throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n    }\n    result(strategy) {\n        const s = this.select(strategy);\n        if (!s)\n            return;\n        const { indices, weight, total } = s;\n        let needChange = this.opts.alwaysChange;\n        const changeWeight = this.opts.alwaysChange\n            ? weight\n            : weight + (this.changeWeight - this.baseWeight);\n        const changeFee = this.getSatoshi(changeWeight);\n        let fee = s.fee;\n        const change = total - this.amount - changeFee;\n        if (change > this.dust)\n            needChange = true;\n        let inputs = indices;\n        let outputs = Array.from(this.outputs);\n        if (needChange) {\n            fee = changeFee;\n            // this shouldn't happen!\n            if (change < 0n)\n                throw new Error(`Estimator.result: negative change=${change}`);\n            outputs.push({ address: this.opts.changeAddress, amount: change });\n        }\n        if (this.opts.bip69) {\n            inputs = this.sortIndices(inputs);\n            outputs = this.sortOutputs(outputs).map((i) => outputs[i]);\n        }\n        const res = {\n            inputs: inputs.map((i) => this.inputs[i]),\n            outputs,\n            fee,\n            weight: this.opts.alwaysChange ? s.weight : changeWeight,\n            change: !!needChange,\n        };\n        let tx;\n        if (this.opts.createTx) {\n            const { inputs, outputs } = res;\n            tx = new Transaction(this.opts);\n            for (const i of inputs)\n                tx.addInput(i);\n            for (const o of outputs)\n                tx.addOutput({ ...o, script: getScript(o, this.opts, this.opts.network) });\n        }\n        return { ...res, tx };\n    }\n}\nexport function selectUTXO(inputs, outputs, strategy, opts) {\n    // Defaults: do we want bip69 by default?\n    const _opts = { createTx: true, bip69: true, ...opts };\n    const est = new _Estimator(inputs, outputs, _opts);\n    return est.result(strategy);\n}\n","'use strict';\n\nexport default function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n","'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  value = +value;\n  return Number.isFinite(value) ? value : defaultValue;\n}\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0]\n  }\n\n  return str;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n};\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nexport default AxiosError;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\nimport PlatformFormData from '../platform/node/classes/FormData.js';\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (PlatformFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nexport default toFormData;\n","'use strict';\n\nimport toFormData from './toFormData.js';\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nexport default AxiosURLSearchParams;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosURLSearchParams from '../helpers/AxiosURLSearchParams.js';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nexport default function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n","'use strict';\n\nexport default {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","import URLSearchParams from './classes/URLSearchParams.js'\nimport FormData from './classes/FormData.js'\nimport Blob from './classes/Blob.js'\n\nexport default {\n  isBrowser: true,\n  classes: {\n    URLSearchParams,\n    FormData,\n    Blob\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n","'use strict';\n\nimport AxiosURLSearchParams from '../../../helpers/AxiosURLSearchParams.js';\nexport default typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n","'use strict';\n\nexport default typeof FormData !== 'undefined' ? FormData : null;\n","'use strict'\n\nexport default typeof Blob !== 'undefined' ? Blob : null\n","const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = (\n  (product) => {\n    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0\n  })(typeof navigator !== 'undefined' && navigator.product);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nexport {\n  hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv\n}\n","import platform from './node/index.js';\nimport * as utils from './common/utils.js';\n\nexport default {\n  ...utils,\n  ...platform\n}\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nexport default formDataToJSON;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport transitionalDefaults from './transitional.js';\nimport toFormData from '../helpers/toFormData.js';\nimport toURLEncodedForm from '../helpers/toURLEncodedForm.js';\nimport platform from '../platform/index.js';\nimport formDataToJSON from '../helpers/formDataToJSON.js';\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      if (!hasJSONContentType) {\n        return data;\n      }\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nexport default defaults;\n","'use strict';\n\nimport utils from '../utils.js';\nimport toFormData from './toFormData.js';\nimport platform from '../platform/index.js';\n\nexport default function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexport default rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n","'use strict';\n\nimport utils from './../utils.js';\nimport defaults from '../defaults/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nexport default function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n","'use strict';\n\nexport default function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport utils from '../utils.js';\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nexport default CanceledError;\n","import utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push('path=' + path);\n\n      utils.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n","'use strict';\n\nimport isAbsoluteURL from '../helpers/isAbsoluteURL.js';\nimport combineURLs from '../helpers/combineURLs.js';\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nexport default function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nexport default function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nexport default function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n","'use strict';\n\nimport utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    const msie = /(msie|trident)/i.test(navigator.userAgent);\n    const urlParsingNode = document.createElement('a');\n    let originURL;\n\n    /**\n    * Parse a URL to discover its components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      let href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n          urlParsingNode.pathname :\n          '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n          parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })();\n","'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport cookies from './../helpers/cookies.js';\nimport buildURL from './../helpers/buildURL.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport isURLSameOrigin from './../helpers/isURLSameOrigin.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport speedometer from '../helpers/speedometer.js';\n\nfunction progressEventReducer(listener, isDownloadStream) {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e\n    };\n\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n\n    listener(data);\n  };\n}\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    let requestData = config.data;\n    const requestHeaders = AxiosHeaders.from(config.headers).normalize();\n    let {responseType, withXSRFToken} = config;\n    let onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let contentType;\n\n    if (utils.isFormData(requestData)) {\n      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n        requestHeaders.setContentType(false); // Let the browser set it\n      } else if ((contentType = requestHeaders.getContentType()) !== false) {\n        // fix semicolon duplication issue for ReactNative FormData implementation\n        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));\n    }\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if(platform.hasStandardBrowserEnv) {\n      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));\n\n      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {\n        // Add xsrf header\n        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);\n\n        if (xsrfValue) {\n          requestHeaders.set(config.xsrfHeaderName, xsrfValue);\n        }\n      }\n    }\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(fullPath);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n","'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n","import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\nexport default {\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n}\n","// eslint-disable-next-line strict\nexport default null;\n","'use strict';\n\nimport AxiosError from './AxiosError.js';\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nexport default function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n","'use strict';\n\nexport default function parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n","'use strict';\n\nimport transformData from './transformData.js';\nimport isCancel from '../cancel/isCancel.js';\nimport defaults from '../defaults/index.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport adapters from \"../adapters/adapters.js\";\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nexport default function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? thing.toJSON() : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n","export const VERSION = \"1.6.6\";","'use strict';\n\nimport {VERSION} from '../env/data.js';\nimport AxiosError from '../core/AxiosError.js';\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nexport default {\n  assertOptions,\n  validators\n};\n","'use strict';\n\nimport utils from './../utils.js';\nimport buildURL from '../helpers/buildURL.js';\nimport InterceptorManager from './InterceptorManager.js';\nimport dispatchRequest from './dispatchRequest.js';\nimport mergeConfig from './mergeConfig.js';\nimport buildFullPath from './buildFullPath.js';\nimport validator from '../helpers/validator.js';\nimport AxiosHeaders from './AxiosHeaders.js';\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      const dummy = {}\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(dummy)\n      } else {\n        dummy.stack = new Error().stack;\n      }\n      // slice off the Error: ... line\n      dummy.stack = dummy.stack.replace(/^.+\\n/, '');\n      // match without the 2 top stack lines\n      if (!err.stack.endsWith(dummy.stack.replace(/^.+\\n.+\\n/, ''))) {\n        err.stack += '\\n' + dummy.stack\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nexport default Axios;\n","'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n","const HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nexport default HttpStatusCode;\n","'use strict';\n\nimport utils from './utils.js';\nimport bind from './helpers/bind.js';\nimport Axios from './core/Axios.js';\nimport mergeConfig from './core/mergeConfig.js';\nimport defaults from './defaults/index.js';\nimport formDataToJSON from './helpers/formDataToJSON.js';\nimport CanceledError from './cancel/CanceledError.js';\nimport CancelToken from './cancel/CancelToken.js';\nimport isCancel from './cancel/isCancel.js';\nimport {VERSION} from './env/data.js';\nimport toFormData from './helpers/toFormData.js';\nimport AxiosError from './core/AxiosError.js';\nimport spread from './helpers/spread.js';\nimport isAxiosError from './helpers/isAxiosError.js';\nimport AxiosHeaders from \"./core/AxiosHeaders.js\";\nimport adapters from './adapters/adapters.js';\nimport HttpStatusCode from './helpers/HttpStatusCode.js';\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders;\n\naxios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nexport default function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nexport default function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n","// index.js\r\n\r\n// class with helper functions for reading file data and converting plain text to UTF-8 byte array\r\n\r\n// import necessary libraries\r\nimport * as bip39 from '@scure/bip39';\r\nimport { wordlist } from '@scure/bip39/wordlists/english';\r\nimport { HDKey } from '@scure/bip32';\r\nimport * as btc from '@scure/btc-signer';\r\nimport axios from 'axios';\r\n\r\nclass HelperFunctions {\r\n    constructor() {\r\n        this.feeEstiamtor = '' //new btc._Estimator();\r\n    }\r\n\r\n    // read file using the FileReader API\r\n    async readFileAsByteArray(file, callback){\r\n        const reader = new FileReader();\r\n\r\n        // set up an event listener for when the file is loaded\r\n        reader.onload = function (event) {\r\n            // access the result property which contain the file content as an ArrayBuffer\r\n            const arrayBuffer = event.target.result;\r\n\r\n            // convert the ArrayBuffer to a Uint8Array (byte array)\r\n            const byteArray = new Uint8Array(arrayBuffer);\r\n\r\n            // call the provided callback with byte array\r\n            callback(null, byteArray);\r\n        };\r\n\r\n        // set up an event listener for when an error occurs\r\n        reader.onerror = function(event) {\r\n            // call the callback with an error object\r\n            callback(new Error('Error reading the file', event.target.error));\r\n        };\r\n\r\n        // read the file as an array buffer\r\n        reader.readAsArrayBuffer(file);\r\n    }\r\n\r\n    // convert plain text to UTF-8 array\r\n    textToUTF8Array(plainText) {\r\n        // create a TextEncoder instance\r\n        const textEncoder = new TextEncoder();\r\n\r\n        // use the encode method to convert the text to a UintArray (UTF-8 byte array)\r\n        const byteArray = textEncoder.encode(plainText);\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    // generate mnemonic\r\n    generateMnemonic() {\r\n        return bip39.generateMnemonic(wordlist, 128);\r\n    }\r\n\r\n    // validate menmonic\r\n    validateMnemonic(mnemonic) {\r\n        return bip39.validateMnemonic(mnemonic, wordlist);\r\n    }\r\n\r\n    // get estimated fee\r\n    async getEstimatedFee() {\r\n        try {\r\n            const feeRate = await this.feeEstiamtor.getFeeRate();\r\n            return feeRate;\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // get inputs\r\n    async getInputs(amount, privateKey) {\r\n        try {\r\n            const nodeUrl = process.env.BITCOIN_API;\r\n            const response = await axios.get(`${nodeUrl}/unspent/${privateKey.getAddress()}`);\r\n            const inputs = response.data;\r\n\r\n            // filter inputs until the required amount is covered\r\n            let totalAmount = 0;\r\n            const selectedInputs = [];\r\n            for(const input of inputs){\r\n                totalAmount += input.amount;\r\n                selectedInputs.push(input);\r\n                if(totalAmount >= amount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // check if inputs cover the required amount\r\n            if(totalAmount < amount) {\r\n                this.handleError(\"Insufficient funds\");\r\n            }\r\n\r\n            return selectedInputs;\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // derive key pairs\r\n    derivePrivateKey(seed){\r\n        const masterKey = HDKey.fromMasterSeed(seed);\r\n        const path = \"m/44' /0' /0' /0/0\"; //bip44 path\r\n        const privateKey = masterKey.derive(path).privateKey;\r\n        return privateKey;\r\n    }\r\n\r\n    // create a transaction\r\n    async createTransaction(data, privateKey) {\r\n        try {\r\n            // initislize transaction builder\r\n            const txBuilder = new btc.Transaction();\r\n\r\n            // define output with OP_PUSHDATA (creating an output script containig OP_PUSHDATA prefix indicating variable length, bytelendgth of the data and the actual data byte array)\r\n            const outputScript = new Uint8Array([0x4c, data.length]).join(data);\r\n\r\n            // add the output with a value of 0 (no value transfer)\r\n            txBuilder.addOutput({\r\n                script: outputScript,\r\n                value: 0,\r\n            });\r\n\r\n            // set teh network parameters\r\n            txBuilder.setNetwork(\"testnet\"); // here you can use the other networks i.e mainnet, regtest as needed\r\n\r\n            // estimate the transaction fee\r\n            const feeRate = await this.getEstimatedFee();\r\n            const estimatedFee = Math.ceil(txBuilder.fee({feeRate}));\r\n\r\n            // add inputs to cover the data output and transaction fee\r\n            const inputs = await this.getInputs(estimatedFee, privateKey);\r\n\r\n            // add the inputs to the transaction\r\n            for(const input of inputs){\r\n                txBuilder.addInput(input.txid, input.vout, 0xffffffff, Buffer.from(input.script, 'hex'))\r\n            }\r\n\r\n            // sign the transaction\r\n            txBuilder.sign(0, privateKey);\r\n\r\n            // return the signed transaction\r\n            return txBuilder.build();\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // broadcast the transaction\r\n    async broadcastTx(signedTx) {\r\n        try {\r\n            // the bitcoin node API for broadcasting\r\n            const nodeUrl = process.env.BITCOIN_API;\r\n\r\n            // build the request body\r\n            const requestBody = {\r\n                txid: signedTx.id,\r\n                hex: signedTx.toHex(),\r\n            };\r\n\r\n             // send the POST request to broadcast the transaction\r\n            const response = await axios.post(nodeUrl, requestBody);\r\n\r\n            console.log(\"Transaction broadcast successfully: \", response.data);\r\n            this.displayResults(response.data);\r\n        } catch(error) {\r\n            console.error(\"Error broadcasting transaction: \", error);\r\n            this.handleError(error);\r\n        }\r\n        \r\n    }\r\n\r\n    // upload file or write plain text to bitcoin mainchain\r\n    uploadToBitcoin(data) {\r\n        try {\r\n            const mnemonic = this.generateMnemonic();\r\n            console.log(\"Generated mnemonic: \", mnemonic);\r\n\r\n            // valiadet mnemonic for being 12 words\r\n            if(this.validateMnemonic(mnemonic)) {\r\n                // derive key data from mnemonic(generate seed)\r\n                const seed = bip39.mnemonicToSeedSync(mnemonic, process.env.PASSWORD); // password is optional\r\n\r\n                //derive private key from master key for address (\"m/44' /0' /0' /0/0\")\r\n                const privateKey = this.derivePrivateKey(seed);\r\n\r\n                // build the transaction (signed)\r\n                const transaction = this.createTransaction(data, privateKey);\r\n\r\n                // broadcast the transaction\r\n                this.broadcastTx(transaction);         \r\n            \r\n            } else {\r\n                this.handleError(\"Invalid mnemonic\");\r\n            }\r\n        } catch(error) {\r\n            this.handleError(error);\r\n        }\r\n    }\r\n\r\n    // display results\r\n    displayResults(message) {\r\n        const resultDiv = document.getElementById('result');\r\n        resultDiv.innerHTML = `Broadcasting transaction: ${message}`;\r\n    }\r\n\r\n    // handle errors\r\n    handleError(message) {\r\n        console.error(message);\r\n        const resultDiv = document.getElementById('result');\r\n        resultDiv.innerHTML = `<span style=\"color: red;\">Error: ${message}</span>`;\r\n    }\r\n}\r\n\r\n// export class as a module\r\nexport {HelperFunctions};","// main.js\r\n\r\n// import necessary libraries\r\nimport { HelperFunctions } from \"./helperfns\";\r\n\r\nconst helper = new HelperFunctions();\r\n\r\nfunction processInputs() {\r\n    \r\n    const fileInput = document.getElementById('fileInput');\r\n    const textInput = document.getElementById('textInput');\r\n    const resultDiv = document.getElementById('result');\r\n\r\n    // handle file input\r\n    if(fileInput.files.length > 0) {\r\n        const file = fileInput.files[0];\r\n        helper.readFileAsByteArray(file, (error, byteArray) => {\r\n            if(error) {\r\n                resultDiv.innerHTML = `<span style=\"color: red;\">Error reading file: ${error.message}</span>`;\r\n            } else {\r\n                resultDiv.innerHTML = `<p style=\"color: black;\"> File Content (as byte array): ${byteArray.join(',')}</p>`;\r\n            }\r\n        });\r\n    }\r\n\r\n    // handle text input\r\n    const plainText = textInput.value.trim();\r\n    if(plainText !== '') {\r\n        const textByteArray = helper.textToUTF8Array(plainText);\r\n        resultDiv.innerHTML += `<p style=\"color: black;\"> Text Content (as utf-8 array): ${textByteArray.join(',')}</p>`;\r\n    }\r\n}\r\n\r\n// expose the processInputs function globally for the onclick attribute\r\nwindow.processInputs = processInputs;"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","number","n","Number","isSafeInteger","Error","bytes","b","lengths","a","Uint8Array","constructor","name","length","includes","hash","create","outputLen","blockLen","exists","instance","checkFinished","destroyed","finished","globalThis","crypto","undefined","arr","DataView","buffer","byteOffset","byteLength","rotr","word","shift","Uint32Array","hexes","Array","from","_","i","toString","padStart","asciis","_0","_9","_A","_F","_a","_f","asciiToBase16","char","utf8ToBytes","str","TextEncoder","encode","toBytes","data","concatBytes","arrays","sum","res","pad","set","Hash","clone","this","_cloneInto","toStr","hashCons","hashC","msg","update","digest","tmp","randomBytes","bytesLength","getRandomValues","HMAC","_key","super","iHash","oHash","fill","buf","digestInto","out","destroy","to","getPrototypeOf","hmac","message","SHA2","padOffset","isLE","pos","view","len","take","Math","min","subarray","process","dataView","roundClean","output","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","oview","outLen","state","slice","Maj","c","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","s1","T1","T2","U32_MASK64","fromBig","le","lst","Ah","Al","_l","s","Bh","Bl","Cl","low","Ch","Dl","Dh","Eh","El","SHA512_Kh","SHA512_Kl","map","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","assertNumber","chain","args","id","wrap","x","reduceRight","decode","reduce","alphabet","digits","isArray","input","letter","index","indexOf","join","separator","split","padding","bits","chr","push","end","normalize","fn","convertRadix","forEach","d","carry","done","digit","digitBase","rounded","floor","reverse","gcd","radix2carry","convertRadix2","mask","radix","num","radix2","revPadding","unsafeWrapper","apply","e","checksum","payload","newChecksum","oldChecksum","utils","base58","toUpperCase","replace","abc","createBase58check","sha256","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","TypeError","lowered","toLowerCase","sepIndex","lastIndexOf","endsWith","actualLength","decodeToBytes","decodeUnsafe","bech32","bech32m","TextDecoder","nfkd","norm","assertEntropy","entropy","calcChecksum","bitsLeft","getCoder","wordlist","mnemonicToSeedSync","mnemonic","passphrase","password","salt","opts","dkLen","DK","PRF","PRFSalt","_password","_salt","_opts","defaults","assign","asyncTick","checkOpts","pbkdf2Init","prfW","u","ti","Ti","setInt32","ui","pbkdf2Output","pbkdf2","Rho","Id","idxL","idxR","j","k","shifts","shiftsL","idx","shiftsR","Kl","Kr","rotl","f","group","y","z","BUF","RIPEMD160","h0","h1","h2","h3","h4","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","_1n","_2n","hex","hexToNumber","hl","array","ai","hi","n1","n2","numberToBytesBE","numberToBytesLE","title","expectedLength","bitMask","u8n","u8fr","createHmacDrbg","hashLen","qByteLen","hmacFn","reset","reseed","seed","gen","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","field","object","Fp","isValid","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","entries","_3n","_4n","_5n","_8n","result","pow","power","modulo","pow2","invert","q","r","m","FIELD_FIELDS","nLength","nBitLength","_nBitLength","nByteLength","ceil","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","validateBasic","curve","ORDER","MASK","BYTES","BITS","Gx","Gy","freeze","p","bytesToNumberBE","b2n","hexToBytes","h2b","DER","Err","_parseInt","toSig","sBytes","rBytesLeft","hexFromSig","sig","parseInt","shl","rhl","weierstrass","curveDef","CURVE","bits2int","bits2int_modN","lowS","validateOpts","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","ProjectivePoint","Point","normPrivateKeyToScalar","weierstrassEquation","isWithinCurveOrder","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","endo","eql","ZERO","beta","splitScalar","validatePointOpts","_c","point","_isCompressed","toAffine","tail","x2","sqr","x3","mul","add","assertGE","error","pointPrecomputes","Map","assertPrjPoint","other","px","py","pz","fromAffine","is0","ONE","normalizeZ","points","toInv","invertBatch","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","delete","left","right","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","wNAF","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","scalar","fake","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","iz","inv","ax","ay","zz","cofactor","toRawBytes","isCompressed","toHex","_bits","condition","item","W","windows","elm","precomputeWindow","base","window","precomputes","maxNumber","shiftBy","wbits","offset1","offset2","abs","cond1","cond2","precomputesMap","transform","weierstrassPoints","cat","head","y2","sqrt","numToNByteStr","isBiggerThanHalfOrder","slcNum","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","R","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","isValidPrivateKey","randomPrivateKey","fieldLen","minLen","reduced","precompute","isProbPub","delta","ORDER_MASK","int2octets","defaultSigOpts","prehash","defaultVerOpts","getPublicKey","getSharedSecret","privateA","publicB","sign","privKey","k2sig","some","extraEntropy","ent","h1int","seedArgs","kBytes","ik","normS","prepSig","drbg","verify","signature","publicKey","sg","_sig","derError","is","getHash","msgs","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","root","bitLen","redef","sqrtP","p1div4","c1","nv","legendreC","S","Z","Q1div2","g","ge","tonelliShanks","FpSqrt","lhs","rhs","FpPow","div","sqrN","addN","subN","mulN","nums","lastMultiplied","acc","inverted","FpInvertBatch","cmov","Field","secp256k1","defHash","createCurve","a1","b1","a2","POW_2_128","c2","fe","TAGGED_HASH_PREFIXES","taggedHash","tag","messages","tagP","tagH","pointToBytes","numTo32b","modP","GmulAdd","schnorrGetExtPubKey","priv","d_","lift_x","xx","challenge","schnorrGetPublicKey","schnorrSign","auxRand","t","rand","k_","rx","schnorrVerify","pub","mod","bytesToNumber","bytesToHex","MASTER_SECRET","BITCOIN_VERSIONS","private","public","HARDENED_OFFSET","toU32","HDKey","fingerprint","pubHash","identifier","pubKeyHash","privKeyBytes","pubKey","privateExtendedKey","serialize","versions","publicExtendedKey","fromMasterSeed","chainCode","fromExtendedKey","base58key","keyBuffer","keyView","version","opt","depth","parentFingerprint","isPriv","fromJSON","json","xpriv","derive","path","test","parts","child","exec","m1","deriveChild","childTweak","added","err","wipePrivateData","toJSON","xpub","EMPTY","NULL","_bitset","FULL_MASK","clean","bs","debug","checkLen","chunkLen","bsLen","chunk","allowRewrite","indices","lastMask","range","cur","rangeDebug","setRange","first","lastPos","last","Reader","fieldPath","parent","parentOffset","bitBuf","bitPos","enablePtr","allowMultipleReads","markBytesBS","markBytes","absBytes","offsetReader","peek","isFinite","byte","leftBytes","isEnd","byteLen","isCoder","decodeStream","getPath","find","needle","finish","allowUnreadBytes","notRead","formatted","fieldPathPush","fieldPathPop","pop","Writer","buffers","ptrs","ptr","encodeStream","swap","checkBounds","signed","signBit","inner","w","objPath","coders","dict","MAX_SAFE_INTEGER","precision","decimalMask","sep","int","frac","startsWith","intS","fracS","fracLen","size","_value","bLen","U256BE","U64LE","I64LE","U32LE","U32BE","I32LE","U16LE","U8","tPos","innerValue","validate","magic","constant","check","sizeof","fields","struct","values","startPos","ProjPoint","_signECDSA","_pubECDSA","def","sha256x2","concat","cloneDeep","fromEntries","PubT","validatePubkey","ecdsa","schnorr","isValidPubkey","hasLowR","tapTweak","tn","PubKeyECDSA","PubKeySchnorr","SignatureSchnorr","NETWORK","scriptHash","wif","DEFAULT_SEQUENCE","EMPTY32","_cmpBytes","OP","decimal","Script","OP_1","ScriptNum","PUSHDATA1","PUSHDATA2","PUSHDATA4","OP_0","OP_16","op","bytesLimit","forceMinimal","CSLimits","CompactSize","flag","start","stop","b0","CompactSizeLen","BTCArray","VarBytes","RawInput","txid","finalScriptSig","sequence","RawOutput","amount","script","EMPTY_OUTPUT","RawWitness","RawTx","segwitFlag","flagValue","xor","hasFlag","inputs","outputs","witnesses","lockTime","tx","PSBTKeyInfo","info","kc","vc","reqInc","allowInc","silentIgnore","BIP32Der","TaprootControlBlock","internalKey","merklePath","cb","TaprootBIP32Der","hashes","der","GlobalXPUB","tapScriptSigKey","leafHash","tapTree","BytesInf","Bytes20","Bytes32","PSBTGlobal","unsignedTx","txVersion","fallbackLocktime","inputCount","outputCount","txModifiable","proprietary","PSBTInput","nonWitnessUtxo","witnessUtxo","partialSig","sighashType","redeemScript","witnessScript","bip32Derivation","finalScriptWitness","porCommitment","hash160","hash256","requiredTimeLocktime","requiredHeightLocktime","tapKeySig","tapScriptSig","tapLeafScript","tapBip32Derivation","tapInternalKey","tapMerkleRoot","PSBTInputFinalKeys","PSBTInputUnsignedKeys","PSBTOutput","PSBTOutputUnsignedKeys","PSBTKeyPair","wChild","PSBTKeyMap","psbtEnum","byType","kv","sort","unknown","raw","noKey","_name","checkWSH","OutScript","checkScript","PSBTInputCoder","prevOut","Transaction","fromRaw","allowUnknownOutputs","disableScriptCheck","allowUnknownInputs","isFinal","PSBTOutputCoder","PSBTGlobalCoder","inp","_RawPSBTV0","global","_RawPSBTV2","validatePSBTFields","cleanPSBTFields","_k","validatePSBT","inputsLeft","keys","outputsLeft","mergeKeyMap","allowedFields","kC","vC","cannotChange","oldKV","newKV","kStr","oldVal","newVal","items","withZero","RawPSBTV0","RawPSBTV2","TxHashIdx","OutPK","pubkey","OutPKH","OutSH","OutWSH","OutWPKH","OutMS","pubkeys","OutTR","OutScripts","OpToNum","match","validateWitness","programToWitness","network","coder","formatKey","hashed","Address","address","program","SignatureHash","SigHash","validateSigHash","unpackSighash","hashType","masked","isAny","ANYONECANPAY","isNone","NONE","isSingle","SINGLE","inputBeforeSign","cleanFinalInput","outputBeforeSign","tapLeafHash","getPrevOut","normalizeInput","getInputType","allowLegacyWitnessUtxo","txType","defaultSighash","ALL","stack","DEFAULT","lastScript","sighash","PSBTVersion","allowUnknowInput","allowUnknowOutput","parsed","addOutput","fromPSBT","psbt","e0","e2","unsigned","toPSBT","bip174jsCompat","height","heightCnt","time","timeCnt","max","inputStatus","checkInputIdx","inputSighash","sigOutputs","sigInputs","signStatus","addInput","hasWitnesses","weight","vsize","withScriptSig","withWitness","getInput","inputsLength","_ignoreSignStatus","updateInput","status","checkOutputIdx","getOutput","outputsLength","normalizeOutput","updateOutput","addOutputAddress","fee","preimageLegacy","prevOutScript","filter","inputIdx","tmpTx","preimageWitnessV0","inputHash","sequenceHash","outputHash","preimageWitnessV1","codeSeparator","leafScript","leafVer","annex","outType","inType","spendType","signIdx","allowedSighash","_auxRand","inputType","signers","prevOuts","schnorrPub","merkleRoot","seckey0","seckey","taprootTweakPrivKey","getTaprootKeys","taprootPubKey","parity","taprootTweakPubkey","_script","scriptDecoded","ver","findIndex","hasPubkey","lowR","cnt","signECDSA","finalizeIdx","leafs","outScript","scriptSig","signatures","sigIdx","inputScript","witness","finalize","extract","combine","bind","thisArg","arguments","kindOf","cache","thing","kindOfTest","typeOfTest","isUndefined","isArrayBuffer","isString","isFunction","isNumber","isObject","isPlainObject","iterator","isDate","isFile","isBlob","isFileList","isURLSearchParams","allOwnKeys","getOwnPropertyNames","findKey","_global","self","isContextDefined","context","isTypedArray","TypedArray","isHTMLForm","isRegExp","reduceDescriptors","reducer","descriptors","getOwnPropertyDescriptors","reducedDescriptors","descriptor","ret","defineProperties","ALPHA","DIGIT","ALPHABET","ALPHA_DIGIT","isAsyncFn","isBuffer","isFormData","kind","FormData","append","isArrayBufferView","ArrayBuffer","isView","isBoolean","isStream","pipe","merge","caseless","assignValue","targetKey","extend","trim","stripBOM","content","inherits","superConstructor","props","toFlatObject","sourceObj","destObj","propFilter","merged","searchString","position","lastIndex","toArray","forEachEntry","next","pair","matchAll","regExp","matches","hasOwnProp","freezeMethods","writable","toObjectSet","arrayOrString","delimiter","define","toCamelCase","p1","p2","noop","toFiniteNumber","defaultValue","generateString","random","isSpecCompliantForm","toJSONObject","visit","source","target","reducedValue","isThenable","then","catch","AxiosError","code","config","request","response","captureStackTrace","description","fileName","lineNumber","columnNumber","customProps","axiosError","cause","isVisitable","removeBrackets","renderKey","dots","token","predicates","formData","options","metaTokens","indexes","option","visitor","defaultVisitor","useBlob","Blob","convertValue","toISOString","Buffer","JSON","stringify","isFlatArray","exposedHelpers","build","charMap","encodeURIComponent","AxiosURLSearchParams","params","_pairs","encoder","_encode","buildURL","url","serializeFn","serializedParams","hashmarkIndex","handlers","use","fulfilled","rejected","synchronous","runWhen","eject","clear","silentJSONParsing","forcedJSONParsing","clarifyTimeoutError","isBrowser","classes","URLSearchParams","protocols","hasBrowserEnv","document","hasStandardBrowserEnv","product","navigator","hasStandardBrowserWebWorkerEnv","WorkerGlobalScope","importScripts","buildPath","isNumericKey","isLast","arrayToObject","parsePropPath","transitional","adapter","transformRequest","headers","contentType","getContentType","hasJSONContentType","isObjectPayload","setContentType","platform","helpers","isNode","toURLEncodedForm","formSerializer","_FormData","env","rawValue","parser","parse","stringifySafely","transformResponse","JSONRequested","responseType","strictJSONParsing","ERR_BAD_RESPONSE","timeout","xsrfCookieName","xsrfHeaderName","maxContentLength","maxBodyLength","validateStatus","common","method","ignoreDuplicateOf","$internals","normalizeHeader","header","normalizeValue","matchHeaderValue","isHeaderNameFilter","AxiosHeaders","valueOrRewrite","rewrite","setHeader","_header","_rewrite","lHeader","setHeaders","rawHeaders","line","substring","parseHeaders","tokens","tokensRE","parseTokens","has","matcher","deleted","deleteHeader","format","normalized","formatHeader","targets","asStrings","computed","accessor","accessors","defineAccessor","accessorName","methodName","arg1","arg2","arg3","configurable","buildAccessors","mapped","headerValue","transformData","fns","isCancel","__CANCEL__","CanceledError","ERR_CANCELED","write","expires","domain","secure","cookie","Date","toGMTString","read","RegExp","decodeURIComponent","remove","now","buildFullPath","baseURL","requestedURL","relativeURL","combineURLs","msie","userAgent","urlParsingNode","createElement","originURL","resolveURL","href","setAttribute","protocol","host","search","hostname","port","pathname","charAt","location","requestURL","progressEventReducer","listener","isDownloadStream","bytesNotified","_speedometer","samplesCount","timestamps","firstSampleTS","chunkLength","startedAt","bytesCount","passed","round","loaded","total","lengthComputable","progressBytes","rate","progress","estimated","event","knownAdapters","http","xhr","XMLHttpRequest","Promise","resolve","reject","requestData","requestHeaders","onCanceled","withXSRFToken","cancelToken","unsubscribe","signal","removeEventListener","Boolean","auth","username","unescape","btoa","fullPath","onloadend","responseHeaders","getAllResponseHeaders","ERR_BAD_REQUEST","settle","responseText","statusText","open","paramsSerializer","onreadystatechange","readyState","responseURL","setTimeout","onabort","ECONNABORTED","onerror","ERR_NETWORK","ontimeout","timeoutErrorMessage","ETIMEDOUT","isURLSameOrigin","xsrfValue","cookies","setRequestHeader","withCredentials","onDownloadProgress","addEventListener","onUploadProgress","upload","cancel","abort","subscribe","aborted","parseProtocol","send","renderReason","reason","isResolvedHandle","adapters","nameOrAdapter","rejectedReasons","reasons","throwIfCancellationRequested","throwIfRequested","dispatchRequest","headersToObject","mergeConfig","config1","config2","getMergedValue","mergeDeepProperties","valueFromConfig2","defaultToConfig2","mergeDirectKeys","mergeMap","timeoutMessage","decompress","beforeRedirect","transport","httpAgent","httpsAgent","socketPath","responseEncoding","configValue","deprecatedWarnings","validator","formatMessage","desc","ERR_DEPRECATED","console","warn","assertOptions","schema","allowUnknown","ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","Axios","instanceConfig","interceptors","configOrUrl","_request","dummy","contextHeaders","requestInterceptorChain","synchronousRequestInterceptors","interceptor","unshift","responseInterceptorChain","promise","newConfig","onFulfilled","onRejected","getUri","generateHTTPMethod","isForm","CancelToken","executor","resolvePromise","_listeners","onfulfilled","_resolve","splice","HttpStatusCode","Continue","SwitchingProtocols","Processing","EarlyHints","Ok","Created","Accepted","NonAuthoritativeInformation","NoContent","ResetContent","PartialContent","MultiStatus","AlreadyReported","ImUsed","MultipleChoices","MovedPermanently","Found","SeeOther","NotModified","UseProxy","Unused","TemporaryRedirect","PermanentRedirect","BadRequest","Unauthorized","PaymentRequired","Forbidden","NotFound","MethodNotAllowed","NotAcceptable","ProxyAuthenticationRequired","RequestTimeout","Conflict","Gone","LengthRequired","PreconditionFailed","PayloadTooLarge","UriTooLong","UnsupportedMediaType","RangeNotSatisfiable","ExpectationFailed","ImATeapot","MisdirectedRequest","UnprocessableEntity","Locked","FailedDependency","TooEarly","UpgradeRequired","PreconditionRequired","TooManyRequests","RequestHeaderFieldsTooLarge","UnavailableForLegalReasons","InternalServerError","NotImplemented","BadGateway","ServiceUnavailable","GatewayTimeout","HttpVersionNotSupported","VariantAlsoNegotiates","InsufficientStorage","LoopDetected","NotExtended","NetworkAuthenticationRequired","axios","createInstance","defaultConfig","VERSION","toFormData","Cancel","all","promises","spread","callback","isAxiosError","formToJSON","getAdapter","default","_regeneratorRuntime","asyncIterator","Generator","Context","makeInvokeMethod","tryCatch","arg","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","_invoke","AsyncIterator","invoke","_typeof","__await","callInvokeWithMethodAndArg","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","resultName","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","isNaN","displayName","isGeneratorFunction","mark","setPrototypeOf","__proto__","awrap","async","prev","rval","handle","complete","delegateYield","asyncGeneratorStep","_next","_throw","_asyncToGenerator","_defineProperties","_toPropertyKey","toPrimitive","_toPrimitive","helper","HelperFunctions","Constructor","_classCallCheck","feeEstiamtor","protoProps","_broadcastTx","_createTransaction","_getInputs","_getEstimatedFee","_readFileAsByteArray","_callee","file","reader","_context","FileReader","onload","arrayBuffer","byteArray","readAsArrayBuffer","_x","_x2","plainText","strength","isJapanese","entropyToMnemonic","bip39","mnemonicToEntropy","_callee2","feeRate","_context2","getFeeRate","handleError","_callee3","nodeUrl","totalAmount","selectedInputs","_iterator","_step","_context3","BITCOIN_API","getAddress","_createForOfIteratorHelper","_x3","_x4","_callee4","txBuilder","outputScript","estimatedFee","_iterator2","_step2","_context4","btc","setNetwork","getEstimatedFee","getInputs","vout","_x5","_x6","_callee5","signedTx","requestBody","_context5","post","log","displayResults","_x7","generateMnemonic","validateMnemonic","PASSWORD","derivePrivateKey","transaction","createTransaction","broadcastTx","getElementById","innerHTML","processInputs","fileInput","textInput","resultDiv","files","readFileAsByteArray","textByteArray","textToUTF8Array"],"sourceRoot":""}